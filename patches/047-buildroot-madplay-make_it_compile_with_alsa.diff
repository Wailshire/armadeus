Now this patch is needed for madplay to compile when ALSA is configured with
 --with-versioned=no option.
madplay is compiling but still crashes when used... :-(

Index: package/madplay/madplay-audio-alsa.patch
===================================================================
--- buildroot.org/package/madplay/madplay-audio-alsa.patch	(revision 0)
+++ buildroot/package/madplay/madplay-audio-alsa.patch	(revision 0)
@@ -0,0 +1,107 @@
+--- madplay-0.15.2b/audio_alsa.c	2004-02-23 22:35:23.000000000 +0100
++++ madplay-0.15.2b-new/audio_alsa.c	2007-12-02 16:40:38.000000000 +0100
+@@ -28,31 +28,28 @@
+ 
+ #include <errno.h>
+ 
+-#define ALSA_PCM_OLD_HW_PARAMS_API
+-#define ALSA_PCM_OLD_SW_PARAMS_API
+ #include <alsa/asoundlib.h>
+ 
+ #include <mad.h>
+ 
+ #include "audio.h"
+ 
+-char *buf	= NULL;
+-int paused	= 0;
++unsigned char *buf  = NULL;
++int paused	    = 0;
+ 
+-int rate	= -1;
+-int channels	= -1;
+-int bitdepth	= -1;
+-int sample_size	= -1;
+-
+-int buffer_time		= 500000;
+-int period_time		= 100000;
+-char *defaultdev	= "plughw:0,0";
++unsigned int rate           = 0;
++unsigned int channels	    = -1;
++unsigned int bitdepth	    = -1;
++unsigned int sample_size    = -1;
++
++unsigned int buffer_time    = 500000;
++unsigned int period_time    = 100000;
++char *defaultdev	    = "plughw:0,0";
+ 
+ snd_pcm_hw_params_t *alsa_hwparams;
+ snd_pcm_sw_params_t *alsa_swparams;
+ 
+-snd_pcm_sframes_t buffer_size;
+-snd_pcm_sframes_t period_size;
++snd_pcm_uframes_t buffer_size;
+ 
+ snd_pcm_format_t  alsa_format = -1;
+ snd_pcm_access_t  alsa_access = SND_PCM_ACCESS_MMAP_INTERLEAVED;
+@@ -87,29 +84,28 @@
+ 		return err;
+ 	}
+ 	/* set the stream rate */
+-	err = snd_pcm_hw_params_set_rate_near(handle, params, rate, 0);
++	err = snd_pcm_hw_params_set_rate(handle, params, rate, 0);
+ 	if (err < 0) {
+ 		printf("Rate %iHz not available for playback: %s\n", rate, snd_strerror(err));
+ 		return err;
+ 	}
+-	if (err != rate) {
+-		printf("Rate doesn't match (requested %iHz, get %iHz)\n", rate, err);
+-		return -EINVAL;
+-	}
+ 	/* set buffer time */
+-	err = snd_pcm_hw_params_set_buffer_time_near(handle, params, buffer_time, &dir);
++	err = snd_pcm_hw_params_set_buffer_time_near(handle, params, &buffer_time, &dir);
+ 	if (err < 0) {
+ 		printf("Unable to set buffer time %i for playback: %s\n", buffer_time, snd_strerror(err));
+ 		return err;
+ 	}
+-	buffer_size = snd_pcm_hw_params_get_buffer_size(params);
++	err = snd_pcm_hw_params_get_buffer_size(params, &buffer_size);
++        if (err < 0) {
++                printf("Unable to retrieve buffer size: %s\n", snd_strerror(err));
++                return err;
++        }
+ 	/* set period time */
+-	err = snd_pcm_hw_params_set_period_time_near(handle, params, period_time, &dir);
++	err = snd_pcm_hw_params_set_period_time_near(handle, params, &period_time, &dir);
+ 	if (err < 0) {
+ 		printf("Unable to set period time %i for playback: %s\n", period_time, snd_strerror(err));
+ 		return err;
+ 	}
+-	period_size = snd_pcm_hw_params_get_period_size(params, &dir);
+ 	/* write the parameters to device */
+ 	err = snd_pcm_hw_params(handle, params);
+ 	if (err < 0) {
+@@ -136,13 +132,7 @@
+         if (err < 0) {
+                 printf("Unable to set start threshold mode for playback: %s\n", snd_strerror(err));
+                 return err;
+-										        }
+-        /* allow transfer when at least period_size samples can be processed */
+-        err = snd_pcm_sw_params_set_avail_min(handle, params, period_size);
+-        if (err < 0) {
+-                printf("Unable to set avail min for playback: %s\n", snd_strerror(err));
+-                return err;
+-												        }
++	}
+         /* align all transfers to 1 samples */
+         err = snd_pcm_sw_params_set_xfer_align(handle, params, 1);
+         if (err < 0) {
+@@ -279,7 +269,7 @@
+ int play(struct audio_play *play)
+ {
+ 	int err, len;
+-	char *ptr;
++	unsigned char *ptr;
+ 
+ 	ptr = buf;
+ 	len = play->nsamples;
