COPY IT IN buildroot/target/device/armadeus/linux/kernel-patches/2.6.23.1/
diff -urN -X buildroot/build_arm/linux-2.6.23.1/Documentation/dontdiff buildroot/build_arm/linux-2.6.23.1/drivers/serial/8250.c buildroot/build_arm/linux-2.6.23.1.irq_manager/drivers/serial/8250.c
--- buildroot/build_arm/linux-2.6.23.1/drivers/serial/8250.c	2007-10-12 18:43:44.000000000 +0200
+++ buildroot/build_arm/linux-2.6.23.1.irq_manager/drivers/serial/8250.c	2008-07-23 15:20:08.000000000 +0200
@@ -58,7 +58,7 @@
 /*
  * Debugging.
  */
-#if 0
+#if 1
 #define DEBUG_AUTOCONF(fmt...)	printk(fmt)
 #else
 #define DEBUG_AUTOCONF(fmt...)	do { } while (0)
@@ -77,7 +77,7 @@
  * machine types want others as well - they're free
  * to redefine this in their header file.
  */
-#define is_real_interrupt(irq)	((irq) != 0)
+#define is_real_interrupt(irq)	((irq) != 65)
 
 #ifdef CONFIG_SERIAL_8250_DETECT_IRQ
 #define CONFIG_SERIAL_DETECT_IRQ 1
@@ -992,6 +992,8 @@
 	unsigned char save_lcr, save_mcr;
 	unsigned long flags;
 
+	printk("autoconfig\n");
+
 	if (!up->port.iobase && !up->port.mapbase && !up->port.membase)
 		return;
 
@@ -1170,6 +1172,8 @@
 	unsigned long irqs;
 	int irq;
 
+	printk("autoconfig_irq\n");
+
 	if (up->port.flags & UPF_FOURPORT) {
 		ICP = (up->port.iobase & 0xfe0) | 0x1f;
 		save_ICP = inb_p(ICP);
@@ -1746,6 +1750,8 @@
 	unsigned char lsr, iir;
 	int retval;
 
+	printk("serial8250_startup\n");
+
 	up->capabilities = uart_config[up->port.type].flags;
 	up->mcr = 0;
 
@@ -1840,7 +1846,7 @@
 		 * kick the UART on a regular basis.
 		 */
 		if (iir & UART_IIR_NO_INT) {
-			pr_debug("ttyS%d - using backup timer\n", port->line);
+			printk("ttyS%d - using backup timer\n", port->line);
 			up->timer.function = serial8250_backup_timeout;
 			up->timer.data = (unsigned long)up;
 			mod_timer(&up->timer, jiffies +
@@ -2195,6 +2201,8 @@
 	unsigned int size = 8 << up->port.regshift;
 	int ret = 0;
 
+	printk("serial8250_request_std_resource: ");
+
 	switch (up->port.iotype) {
 	case UPIO_AU:
 		size = 0x100000;
@@ -2208,6 +2216,7 @@
 
 		if (!request_mem_region(up->port.mapbase, size, "serial")) {
 			ret = -EBUSY;
+			printk("BUSY");
 			break;
 		}
 
@@ -2216,6 +2225,7 @@
 			if (!up->port.membase) {
 				release_mem_region(up->port.mapbase, size);
 				ret = -ENOMEM;
+				printk("NOMEM");
 			}
 		}
 		break;
@@ -2226,6 +2236,7 @@
 			ret = -EBUSY;
 		break;
 	}
+	printk("\n");
 	return ret;
 }
 
@@ -2233,6 +2244,7 @@
 {
 	unsigned int size = 8 << up->port.regshift;
 
+	printk("serial8250_release_std_resource\n");
 	switch (up->port.iotype) {
 	case UPIO_AU:
 		size = 0x100000;
@@ -2296,6 +2308,8 @@
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
+	printk("serial8250_release_port\n");
+
 	serial8250_release_std_resource(up);
 	if (up->port.type == PORT_RSA)
 		serial8250_release_rsa_resource(up);
@@ -2306,6 +2320,8 @@
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 	int ret = 0;
 
+	printk("serial8250_request_port\n");
+
 	ret = serial8250_request_std_resource(up);
 	if (ret == 0 && up->port.type == PORT_RSA) {
 		ret = serial8250_request_rsa_resource(up);
@@ -2322,6 +2338,7 @@
 	int probeflags = PROBE_ANY;
 	int ret;
 
+	printk("serial8250_config_port 0x%x\n", flags);
 	/*
 	 * Find the region that we can probe for.  This in turn
 	 * tells us whether we can probe for the type of port.
@@ -2341,8 +2358,9 @@
 
 	if (up->port.type != PORT_RSA && probeflags & PROBE_RSA)
 		serial8250_release_rsa_resource(up);
-	if (up->port.type == PORT_UNKNOWN)
+	if (up->port.type == PORT_UNKNOWN) {
 		serial8250_release_std_resource(up);
+	}
 }
 
 static int
@@ -2661,7 +2679,9 @@
 
 	memset(&port, 0, sizeof(struct uart_port));
 
+	printk("serial8250_probe\n");
 	for (i = 0; p && p->flags != 0; p++, i++) {
+		printk("---\n");
 		port.iobase	= p->iobase;
 		port.membase	= p->membase;
 		port.irq	= p->irq;
@@ -2764,6 +2784,7 @@
 		if (uart_match_port(&serial8250_ports[i].port, port))
 			return &serial8250_ports[i];
 
+	printk("serial8250_find_match_or_unused: 1\n");
 	/*
 	 * We didn't find a matching entry, so look for the first
 	 * free entry.  We look for one which hasn't been previously
@@ -2774,6 +2795,8 @@
 		    serial8250_ports[i].port.iobase == 0)
 			return &serial8250_ports[i];
 
+	printk("serial8250_find_match_or_unused: 2\n");
+
 	/*
 	 * That also failed.  Last resort is to find any entry which
 	 * doesn't have a real port associated with it.
@@ -2782,6 +2805,8 @@
 		if (serial8250_ports[i].port.type == PORT_UNKNOWN)
 			return &serial8250_ports[i];
 
+	printk("serial8250_find_match_or_unused: none\n");
+
 	return NULL;
 }
 
@@ -2803,6 +2828,8 @@
 	struct uart_8250_port *uart;
 	int ret = -ENOSPC;
 
+	printk("serial8250_register_port\n");
+
 	if (port->uartclk == 0)
 		return -EINVAL;
 
