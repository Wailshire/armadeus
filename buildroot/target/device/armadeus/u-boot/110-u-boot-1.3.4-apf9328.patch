diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/apf9328.c u-boot-1.3.4/board/armadeus/apf9328/apf9328.c
--- u-boot-1.3.4.ref/board/armadeus/apf9328/apf9328.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/apf9328.c	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2004 Sascha Hauer, Synertronixx GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <asm/arch/imx-regs.h>
+#include "apf9328fpga.h"
+
+extern void imx_gpio_mode (int gpio_mode);
+
+int
+board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_arch_number = CONFIG_MACH_TYPE;
+	gd->bd->bi_boot_params = CONFIG_BOOT_PARAMS_ADDR;
+
+	return 0;
+}
+
+int
+dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#if ( CONFIG_NR_DRAM_BANKS > 0 )
+	gd->bd->bi_dram[0].start = CFG_SDRAM_1_BASE;
+	gd->bd->bi_dram[0].size = CFG_SDRAM_1_SIZE;
+#endif
+#if ( CONFIG_NR_DRAM_BANKS > 1 )
+	gd->bd->bi_dram[1].start = CFG_SDRAM_2_BASE;
+	gd->bd->bi_dram[1].size = CFG_SDRAM_2_SIZE;
+#endif
+
+	return 0;
+}
+
+/*
+ * Miscellaneous intialization
+ */
+int
+misc_init_r (void)
+{
+#if (CONFIG_FPGA)
+	apf9328_init_fpga ();
+#endif
+
+#if (CONFIG_DRIVER_DM9000)
+	imx_gpio_mode (GPIO_PORTB | GPIO_DR | GPIO_IN | 14);
+#endif
+	return 0;
+}
+
+void
+show_boot_progress (int status)
+{
+	return;
+}
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/apf9328fpga.c u-boot-1.3.4/board/armadeus/apf9328/apf9328fpga.c
--- u-boot-1.3.4.ref/board/armadeus/apf9328/apf9328fpga.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/apf9328fpga.c	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,100 @@
+/*
+ * (C) Copyright 2005
+ * Nicolas Colombin <thom25@users.sourceforge.net>
+ * Eric Jarrige <jorasse@users.sourceforge.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+/*
+ * Spartan 3 FPGA configuration support for the APF9328 daughter board
+ */
+
+#include <common.h>
+#include <spartan3.h>
+#include <command.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/io.h>
+#include "apf9328fpga.h"
+
+#if (CONFIG_FPGA)
+#if 0
+#define FPGA_DEBUG
+#endif
+
+#ifdef FPGA_DEBUG
+#define	PRINTF(fmt,args...)	printf (fmt ,##args)
+#else
+#define	PRINTF(fmt,args...)
+#endif
+
+/* Note that these are pointers to code that is in Flash.  They will be
+ * relocated at runtime.
+ * Spartan3 code is used to download our Spartan 3 :) code is compatible. 
+ * Just take care about the file size  
+*/
+Xilinx_Spartan3_Slave_Serial_fns fpga_fns = {
+	fpga_pre_fn,
+	fpga_pgm_fn,
+	fpga_clk_fn,
+	fpga_init_fn,
+	fpga_done_fn,
+	fpga_wr_fn,
+};
+
+Xilinx_desc fpga[CONFIG_FPGA_COUNT] = {
+	{Xilinx_Spartan3,
+	 slave_serial,
+	 XILINX_XC3S400_SIZE,
+	 (void *) &fpga_fns,
+	 0}
+};
+
+/*
+ * Initialize the fpga.  Return 1 on success, 0 on failure.
+ */
+int
+apf9328_init_fpga (void)
+{
+	char *autoload = getenv ("firmware_autoload");
+	DECLARE_GLOBAL_DATA_PTR;
+
+	int i,lout=1;
+
+	PRINTF ("%s:%d: Initialize FPGA interface (relocation offset = 0x%.8lx)\n",
+		__FUNCTION__, __LINE__, gd->reloc_off);
+	fpga_init (gd->reloc_off);
+
+	for (i = 0; i < CONFIG_FPGA_COUNT; i++) {
+		PRINTF ("%s:%d: Adding fpga %d\n", __FUNCTION__, __LINE__, i);
+		fpga_add (fpga_xilinx, &fpga[i]);
+	}
+
+	if (( autoload ) && (0 == strcmp(autoload, "1"))) {
+		if (FPGA_SUCCESS != fpga_load( 0, (void *)CONFIG_FIRMWARE_ADDR, 
+				(size_t) CONFIG_FIRMWARE_LEN )) {
+			lout = 0;
+			printf("Firmware not loaded!\n");
+		}
+	}
+	return 1;
+}
+
+#endif /* CONFIG_FPGA */
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/apf9328fpga.h u-boot-1.3.4/board/armadeus/apf9328/apf9328fpga.h
--- u-boot-1.3.4.ref/board/armadeus/apf9328/apf9328fpga.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/apf9328fpga.h	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2002
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+/*
+ * Spartan 3 FPGA configuration support for the APF9328 daughter board
+ */
+ 
+#include "fpga.h"
+extern int apf9328_init_fpga (void);
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/config.mk u-boot-1.3.4/board/armadeus/apf9328/config.mk
--- u-boot-1.3.4.ref/board/armadeus/apf9328/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/config.mk	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,10 @@
+#
+# This config file is used for compilation of armadeus sources
+#
+# You might change location of U-Boot in memory by setting right TEXT_BASE.
+# This allows for example having one copy located at the end of ram and stored
+# in flash device and later on while developing use other location to test
+# the code in RAM device only.
+#
+
+TEXT_BASE = 0x0BF80000
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/fpga.c u-boot-1.3.4/board/armadeus/apf9328/fpga.c
--- u-boot-1.3.4.ref/board/armadeus/apf9328/fpga.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/fpga.c	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,140 @@
+/*
+ * (C) Copyright 2002
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#include <common.h>
+
+#if (CONFIG_FPGA)
+
+#include <asm/arch/imx-regs.h>
+#include <asm/io.h>
+#include <config.h>
+
+extern void imx_gpio_mode (int gpio_mode);
+
+
+#define GPIO_PORT(x)  ((x >> 5) & 3)
+#define GPIO_SET(x)   (DR(GPIO_PORT(x)) |= (1<<(x & GPIO_PIN_MASK)))
+#define GPIO_CLEAR(x) (DR(GPIO_PORT(x)) &= ~(1<<(x & GPIO_PIN_MASK)))
+#define GPIO_WRITE(x,y) ( y ? GPIO_SET(x) : GPIO_CLEAR(x) )
+#define GPIO_READ(x)  ((SSR (GPIO_PORT(x)) & (1<<(x & GPIO_PIN_MASK))))
+
+#if 0
+#define FPGA_DEBUG
+#endif
+
+#ifdef FPGA_DEBUG
+#define	PRINTF(fmt,args...)	printf (fmt ,##args)
+#else
+#define	PRINTF(fmt,args...)
+#endif
+
+/*
+ * Port bit numbers for the serial slave controls
+ */
+#define FPGA_INIT	CFG_FPGA_INIT
+#define FPGA_DONE	CFG_FPGA_DONE
+#define FPGA_DIN	CFG_FPGA_DATA
+#define FPGA_PROGRAM	CFG_FPGA_PRG
+#define FPGA_CLOCK	CFG_FPGA_CLK
+
+/* Note that these are pointers to code that is in Flash.  They will be
+ * relocated at runtime.
+ * Spartan2 code is used to download our Spartan 3 :) code is compatible. 
+ * Just take care about the file size  
+*/
+
+/*
+ * nitialize GPIO port B before download
+ */
+int
+fpga_pre_fn (int cookie)
+{
+	PRINTF ("%s:%d: FPGA PRE ", __FUNCTION__, __LINE__);
+
+	// Initialize GPIO pins
+	imx_gpio_mode (FPGA_INIT | GPIO_DR | GPIO_IN );
+	imx_gpio_mode (FPGA_DONE | GPIO_DR | GPIO_IN );
+	imx_gpio_mode (FPGA_DIN  | GPIO_DR | GPIO_OUT );
+	imx_gpio_mode (FPGA_PROGRAM | GPIO_DR | GPIO_OUT );
+	imx_gpio_mode (FPGA_CLOCK | GPIO_DR | GPIO_OUT );
+	return cookie;
+}
+
+/*
+ * Set the FPGA's active-low program line to the specified level
+ */
+int
+fpga_pgm_fn (int assert, int flush, int cookie)
+{
+	PRINTF ("%s:%d: FPGA PROGRAM %s", __FUNCTION__, __LINE__, 
+					assert?"high":"low");
+	GPIO_WRITE( FPGA_PROGRAM, !assert);
+	return assert;
+}
+
+/*
+ * Set the FPGA's active-high clock line to the specified level
+ */
+int
+fpga_clk_fn (int assert_clk, int flush, int cookie)
+{
+	PRINTF ("%s:%d: FPGA CLOCK %s", __FUNCTION__, __LINE__, 
+					assert_clk?"high":"low");
+	GPIO_WRITE( FPGA_CLOCK, assert_clk);
+	return assert_clk;
+}
+
+/*
+ * Test the state of the active-low FPGA INIT line.  Return 1 on INIT
+ * asserted (low).
+ */
+int
+fpga_init_fn (int cookie)
+{
+	PRINTF ("%s:%d: INIT check... ", __FUNCTION__, __LINE__);
+	return(!GPIO_READ(FPGA_INIT));
+}
+
+/*
+ * Test the state of the active-high FPGA DONE pin
+ */
+int
+fpga_done_fn (int cookie)
+{
+	PRINTF ("%s:%d: DONE check... ", __FUNCTION__, __LINE__);
+	return(GPIO_READ(FPGA_DONE));
+}
+
+/*
+ * Set the FPGA's data line to the specified level
+ */
+int
+fpga_wr_fn (int assert_write, int flush, int cookie)
+{
+	PRINTF ("%s:%d: DATA write... ", __FUNCTION__, __LINE__);
+	GPIO_WRITE( FPGA_DIN, assert_write);
+	return assert_write;
+}
+
+#endif /* CONFIG_FPGA */
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/fpga.h u-boot-1.3.4/board/armadeus/apf9328/fpga.h
--- u-boot-1.3.4.ref/board/armadeus/apf9328/fpga.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/fpga.h	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ * (C) Copyright 2002
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+extern int fpga_pre_fn (int cookie);
+extern int fpga_pgm_fn (int assert_pgm, int flush, int cookie);
+extern int fpga_init_fn (int cookie);
+extern int fpga_done_fn (int cookie);
+extern int fpga_clk_fn (int assert_clk, int flush, int cookie);
+extern int fpga_wr_fn (int assert_write, int flush, int cookie);
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/i2c.c u-boot-1.3.4/board/armadeus/apf9328/i2c.c
--- u-boot-1.3.4.ref/board/armadeus/apf9328/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/i2c.c	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,327 @@
+/*
+ * Eric Jarrige <jorasse@users.sourceforge.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ *
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_HARD_I2C
+
+#include <asm/io.h>
+#include <asm/arch/imx-regs.h>
+#include <i2c.h>
+
+/*#define       DEBUG_I2C*/
+
+extern void imx_gpio_mode (int gpio_mode);
+
+/*-----------------------------------------------------------------------
+ * Definitions
+ */
+
+#define I2C_ACK		0	/* level to ack a byte */
+#define I2C_NOACK	1	/* level to noack a byte */
+
+
+#ifdef DEBUG_I2C
+#define PRINTD(fmt,args...)	do {	\
+	DECLARE_GLOBAL_DATA_PTR;	\
+	if (gd->have_console)		\
+		printf (fmt ,##args);	\
+	} while (0)
+#else
+#define PRINTD(fmt,args...)
+#endif
+
+/*-----------------------------------------------------------------------
+ * Local functions
+ */
+
+/*-----------------------------------------------------------------------
+ * START: High -> Low on SDA while SCL is High
+ * after check for a bus free
+ */
+static void
+imxi2c_send_start (void)
+{
+	while ((I2SR & I2SR_IBB)) ;
+	I2CR |= I2CR_MSTA;
+	I2SR &= ~I2SR_IIF;
+}
+
+/*-----------------------------------------------------------------------
+ * STOP: Low -> High on SDA while SCL is High
+ * after the end of previous transfer
+ */
+static void
+imxi2c_send_stop (void)
+{
+	while (!(I2SR & I2SR_ICF)) ;
+	I2CR &= ~I2CR_MSTA;
+}
+
+/*-----------------------------------------------------------------------
+ * Send 8 bits and look for an acknowledgement.
+ */
+static int
+imxi2c_write_byte (uchar data)
+{
+	while (!(I2SR & I2SR_ICF)) ;	/* Wait end of transfer */
+
+	I2CR |= I2CR_MTX;
+	I2SR &= ~I2SR_IIF;
+	I2DR = data;
+
+	while (!(I2SR & I2SR_IIF)) ;	/* checking IIF before ICF seems required */
+
+	I2SR &= ~I2SR_IIF;
+
+	while (!(I2SR & I2SR_ICF)) ;	/* Wait end of transfer */
+
+	return (I2SR & I2SR_RXAK);	/* not a nack is an ack */
+}
+
+/*-----------------------------------------------------------------------
+ * if ack == I2C_ACK, ACK the byte so can continue reading, else
+ * send I2C_NOACK to end the read.
+ */
+static uchar
+imxi2c_read_byte (int ack)
+{
+	int data;
+
+	while (!(I2SR & I2SR_ICF)) ;
+	I2CR &= ~I2CR_MTX;
+
+	if (ack)
+	{
+		I2CR |= I2CR_TXAK;
+	}
+	else
+	{
+		I2CR &= ~I2CR_TXAK;
+	}
+
+	data = I2DR;
+	return (data);
+}
+
+/* ------------------------------------------------------------------------
+ * API Functions
+ * ------------------------------------------------------------------------
+ */
+
+/*-----------------------------------------------------------------------
+ * i2c_init compute the i2c divider to reach the requested speed
+ * see mxl reference manual
+ */
+void
+i2c_init (int speed, int slaveaddr)
+{
+	int hclk_dividers[] = {
+		30, 32, 36, 42, 48, 52, 60, 72,
+		80, 88, 104, 128, 144, 160, 192, 240,
+		288, 320, 384, 480, 576, 640, 768, 960,
+		1152, 1280, 1536, 1920, 2304, 2560, 3072, 3840,
+		22, 24, 26, 26, 32, 36, 40, 44,
+		48, 56, 64, 72, 80, 96, 112, 128,
+		160, 192, 224, 256, 320, 384, 448, 512,
+		640, 768, 896, 1024, 1280, 1536, 1792, 2048
+	};
+	int refDiv = get_HCLK () / speed;
+	int i, tmpIC;
+
+	imx_gpio_mode (PA15_PF_I2C_SDA);
+	imx_gpio_mode (PA16_PF_I2C_SCL);
+
+	tmpIC = (sizeof (hclk_dividers) / sizeof (int)) - 1;
+	for (i = tmpIC; i >= 0; i--)
+	{
+		if ((hclk_dividers[i] >= refDiv)
+		    && (hclk_dividers[i] < hclk_dividers[tmpIC]))
+		{
+			tmpIC = i;
+		}
+	}
+	
+	IFDR = tmpIC;
+	IADR = slaveaddr << 1;
+
+	if (I2SR & I2SR_IBB)
+		imxi2c_send_stop ();
+
+	I2CR |= I2CR_IEN;
+}
+
+/*-----------------------------------------------------------------------
+ * Probe to see if a chip is present. Also good for checking for the
+ * completion of EEPROM writes since the chip stops responding until
+ * the write completes (typically 10mSec).
+ * probe sends a read command to probe a an address
+ */
+int
+i2c_probe (uchar addr)
+{
+	int rc;
+
+	imxi2c_send_start ();
+	rc = imxi2c_write_byte ((addr << 1) | 0);
+	imxi2c_send_stop ();
+
+	return (rc ? 1 : 0);
+}
+
+/*-----------------------------------------------------------------------
+ * Read bytes
+ */
+int
+i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int shift;
+	PRINTD ("i2c_read: chip %02X addr %02X alen %d buffer %p len %d\n",
+		chip, addr, alen, buffer, len);
+
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	/*
+	 * EEPROM chips that implement "address overflow" are ones
+	 * like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	 * address and the extra bits end up in the "chip address"
+	 * bit slots. This makes a 24WC08 (1Kbyte) chip look like
+	 * four 256 byte chips.
+	 *
+	 * Note that we consider the length of the address field to
+	 * still be one byte because the extra address bits are
+	 * hidden in the chip address.
+	 */
+	chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+
+	PRINTD ("i2c_read: fix addr_overflow: chip %02X addr %02X\n",
+		chip, addr);
+#endif
+
+	/*
+	 * Do the addressing portion of a write cycle to set the
+	 * chip's address pointer. If the address length is zero,
+	 * don't do the normal write cycle to set the address pointer,
+	 * there is no address pointer in this chip.
+	 */
+	imxi2c_send_start ();
+	if (alen > 0)
+	{
+		if (imxi2c_write_byte (chip << 1))
+		{		/* write cycle */
+			imxi2c_send_stop ();
+			PRINTD ("i2c_read, no chip responded %02X\n", chip);
+			return (1);
+		}
+		shift = (alen - 1) * 8;
+		while (alen-- > 0)
+		{
+			if (imxi2c_write_byte (addr >> shift))
+			{
+				PRINTD ("i2c_read, address not <ACK>ed\n");
+				return (1);
+			}
+			shift -= 8;
+		}
+		imxi2c_send_stop ();	/* reportedly some chips need a full stop */
+		imxi2c_send_start ();
+	}
+	/*
+	 * Send the chip address again, this time for a read cycle.
+	 * Then read the data. On the last byte, we do a NACK instead
+	 * of an ACK(len == 0) to terminate the read.
+	 */
+	imxi2c_write_byte ((chip << 1) | 1);	/* read cycle */
+	imxi2c_read_byte (len <= 2);
+	while (len-- > 1)
+	{
+		*buffer++ = imxi2c_read_byte (len == 1);
+	}
+	imxi2c_send_stop ();
+	*buffer++ = imxi2c_read_byte (0);
+	return (0);
+}
+
+/*-----------------------------------------------------------------------
+ * Write bytes
+ */
+int
+i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int shift, failures = 0;
+
+	PRINTD ("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
+		chip, addr, alen, buffer, len);
+
+	imxi2c_send_start ();
+	if (imxi2c_write_byte (chip << 1))
+	{			/* write cycle */
+		imxi2c_send_stop ();
+		PRINTD ("i2c_write, no chip responded %02X\n", chip);
+		return (1);
+	}
+	shift = (alen - 1) * 8;
+	while (alen-- > 0)
+	{
+		if (imxi2c_write_byte (addr >> shift))
+		{
+			PRINTD ("i2c_write, address not <ACK>ed\n");
+			return (1);
+		}
+		shift -= 8;
+	}
+
+	while (len-- > 0)
+	{
+		if (imxi2c_write_byte (*buffer++))
+		{
+			failures++;
+		}
+	}
+	imxi2c_send_stop ();
+	return (failures);
+}
+
+/*-----------------------------------------------------------------------
+ * Read a register
+ */
+uchar
+i2c_reg_read (uchar i2c_addr, uchar reg)
+{
+	char buf;
+
+	i2c_read (i2c_addr, reg, 1, &buf, 1);
+
+	return (buf);
+}
+
+/*-----------------------------------------------------------------------
+ * Write a register
+ */
+void
+i2c_reg_write (uchar i2c_addr, uchar reg, uchar val)
+{
+	i2c_write (i2c_addr, reg, 1, &val, 1);
+}
+
+#endif /* CONFIG_HARD_I2C */
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/lowlevel_init.S u-boot-1.3.4/board/armadeus/apf9328/lowlevel_init.S
--- u-boot-1.3.4.ref/board/armadeus/apf9328/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/lowlevel_init.S	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,443 @@
+/*
+ * Copyright (C) 2004 Sascha Hauer, Synertronixx GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/imx-regs.h>
+
+.globl lowlevel_init
+lowlevel_init:
+
+	mov	r10, lr
+
+/* Change PERCLK1DIV to 14 ie 14+1 */
+	ldr		r0,	=PCDR
+	ldr		r1,	=CFG_PCDR_VAL
+	str		r1,	[r0]
+
+/* set MCU PLL Control Register 0 */
+
+	ldr		r0,	=MPCTL0
+	ldr		r1,	=CFG_MPCTL0_VAL
+	str		r1,	[r0]
+
+/* set MCU PLL Control Register 1 */
+
+	ldr		r0,	=MPCTL1
+	ldr		r1,	=CFG_MPCTL1_VAL
+	str		r1,	[r0]
+
+/* set mpll restart bit */
+	ldr		r0, =CSCR
+	ldr		r1, [r0]
+	orr		r1,r1,#(1<<21)
+	str		r1, [r0]
+
+	mov		r2,#0x10
+1:
+	mov		r3,#0x2000
+2:
+	subs	r3,r3,#1
+	bne		2b
+
+	subs	r2,r2,#1
+	bne		1b
+
+/* set System PLL Control Register 0 */
+
+	ldr		r0,	=SPCTL0
+	ldr		r1,	=CFG_SPCTL0_VAL
+	str		r1,	[r0]
+
+/* set System PLL Control Register 1 */
+
+	ldr		r0,	=SPCTL1
+	ldr		r1,	=CFG_SPCTL1_VAL
+	str		r1,	[r0]
+
+/* set spll restart bit */
+	ldr		r0, =CSCR
+	ldr		r1, [r0]
+	orr		r1,r1,#(1<<22)
+	str		r1, [r0]
+
+	mov		r2,#0x10
+1:
+	mov		r3,#0x2000
+2:
+	subs	r3,r3,#1
+	bne		2b
+
+	subs	r2,r2,#1
+	bne		1b
+
+	ldr		r0,	=CSCR
+	ldr		r1,	=CFG_CSCR_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GPCR
+	ldr		r1,	=CFG_GPCR_VAL
+	str		r1,	[r0]
+
+/* I have now read the ARM920 DataSheet back-to-Back, and have stumbled upon
+ *this.....
+ *
+ * It would appear that from a Cold-Boot the ARM920T enters "FastBus" mode CP15
+ * register 1, this stops it using the output of the PLL and thus runs at the
+ * slow rate. Unless you place the Core into "Asynch" mode, the CPU will never
+ * use the value set in the CM_OSC registers...regardless of what you set it
+ * too!  Thus, although i thought i was running at 140MHz, i'm actually running
+ * at 40!..
+
+ * Slapping this into my bootloader does the trick...
+
+ * MRC p15,0,r0,c1,c0,0	 ; read core configuration register
+ * ORR r0,r0,#0xC0000000	; set asynchronous clocks and not fastbus mode
+ * MCR p15,0,r0,c1,c0,0	 ; write modified value to core configuration
+ * register
+ */
+	MRC p15,0,r0,c1,c0,0
+	ORR r0,r0,#0xC0000000
+	MCR p15,0,r0,c1,c0,0
+
+/*	ldr		r0,	=GPR(0) 
+	ldr		r1,	=CFG_GPR_A_VAL
+	str		r1,	[r0]
+*/
+
+	ldr		r0,	=DR(0)
+	ldr		r1,	=CFG_DR_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR1(0)
+	ldr		r1,	=CFG_OCR1_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR2(0)
+	ldr		r1,	=CFG_OCR2_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA1(0)
+	ldr		r1,	=CFG_ICFA1_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA2(0)
+	ldr		r1,	=CFG_ICFA2_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB1(0)
+	ldr		r1,	=CFG_ICFB1_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB2(0)
+	ldr		r1,	=CFG_ICFB2_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR1(0)
+	ldr		r1,	=CFG_ICR1_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR2(0)
+	ldr		r1,	=CFG_ICR2_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=IMR(0)
+	ldr		r1,	=CFG_IMR_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=DDIR(0)
+	ldr		r1,	=CFG_DDIR_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GPR(0)
+	ldr		r1,	=CFG_GPR_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=PUEN(0)
+	ldr		r1,	=CFG_PUEN_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GIUS(0)
+	ldr		r1,	=CFG_GIUS_A_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=DR(1)
+	ldr		r1,	=CFG_DR_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR1(1)
+	ldr		r1,	=CFG_OCR1_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR2(1)
+	ldr		r1,	=CFG_OCR2_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA1(1)
+	ldr		r1,	=CFG_ICFA1_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA2(1)
+	ldr		r1,	=CFG_ICFA2_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB1(1)
+	ldr		r1,	=CFG_ICFB1_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB2(1)
+	ldr		r1,	=CFG_ICFB2_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR1(1)
+	ldr		r1,	=CFG_ICR1_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR2(1)
+	ldr		r1,	=CFG_ICR2_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=IMR(1)
+	ldr		r1,	=CFG_IMR_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=DDIR(1)
+	ldr		r1,	=CFG_DDIR_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GPR(1)
+	ldr		r1,	=CFG_GPR_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=PUEN(1)
+	ldr		r1,	=CFG_PUEN_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GIUS(1)
+	ldr		r1,	=CFG_GIUS_B_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=DR(2)
+	ldr		r1,	=CFG_DR_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR1(2)
+	ldr		r1,	=CFG_OCR1_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR2(2)
+	ldr		r1,	=CFG_OCR2_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA1(2)
+	ldr		r1,	=CFG_ICFA1_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA2(2)
+	ldr		r1,	=CFG_ICFA2_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB1(2)
+	ldr		r1,	=CFG_ICFB1_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB2(2)
+	ldr		r1,	=CFG_ICFB2_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR1(2)
+	ldr		r1,	=CFG_ICR1_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR2(2)
+	ldr		r1,	=CFG_ICR2_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=IMR(2)
+	ldr		r1,	=CFG_IMR_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=DDIR(2)
+	ldr		r1,	=CFG_DDIR_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GPR(2)
+	ldr		r1,	=CFG_GPR_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=PUEN(2)
+	ldr		r1,	=CFG_PUEN_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GIUS(2)
+	ldr		r1,	=CFG_GIUS_C_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=DR(3)
+	ldr		r1,	=CFG_DR_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR1(3)
+	ldr		r1,	=CFG_OCR1_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=OCR2(3)
+	ldr		r1,	=CFG_OCR2_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA1(3)
+	ldr		r1,	=CFG_ICFA1_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFA2(3)
+	ldr		r1,	=CFG_ICFA2_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB1(3)
+	ldr		r1,	=CFG_ICFB1_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICONFB2(3)
+	ldr		r1,	=CFG_ICFB2_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR1(3)
+	ldr		r1,	=CFG_ICR1_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=ICR2(3)
+	ldr		r1,	=CFG_ICR2_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=IMR(3)
+	ldr		r1,	=CFG_IMR_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=DDIR(3)
+	ldr		r1,	=CFG_DDIR_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GPR(3)
+	ldr		r1,	=CFG_GPR_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=PUEN(3)
+	ldr		r1,	=CFG_PUEN_D_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GIUS(3)
+	ldr		r1,	=CFG_GIUS_D_VAL
+	str		r1,	[r0]
+
+/* CS3 becomes CS3 by clearing reset default bit 1 in FMCR */
+
+	ldr		r0,	=FMCR
+	ldr		r1,	=CFG_FMCR_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS0U
+	ldr		r1,	=CFG_CS0U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS0L
+	ldr		r1,	=CFG_CS0L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS1U
+	ldr		r1,	=CFG_CS1U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS1L
+	ldr		r1,	=CFG_CS1L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS2U
+	ldr		r1,	=CFG_CS2U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS2L
+	ldr		r1,	=CFG_CS2L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS3U
+	ldr		r1,	=CFG_CS3U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS3L
+	ldr		r1,	=CFG_CS3L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS4U
+	ldr		r1,	=CFG_CS4U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS4L
+	ldr		r1,	=CFG_CS4L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS5U
+	ldr		r1,	=CFG_CS5U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS5L
+	ldr		r1,	=CFG_CS5L_VAL
+	str		r1,	[r0]
+
+	adr	r0, sdramsetup	/* r0 <- current position of code */
+	ldr	r1, =CFG_SDRAM_1_BASE	/* test if we run from flash or RAM */
+	cmp	r1, r0		/* don't reloc during debug*/
+	bhi		sdramsetup
+	ldr	r1, =CFG_FLASH_BASE	/* test if we run from flash or RAM */
+	cmp	r0, r1		/* don't reloc during debug */
+	bmi		endofmemsetup
+
+/* SDRAM Setup */
+sdramsetup:
+	ldr		r0, =SDCTL0
+	ldr		r1, =CFG_PRECHARGE_CMD
+	str		r1,	[r0]
+
+	ldr		r1, =CFG_SDRAM_1_BASE+CFG_SDRAM_PRECHARGE_ALL_VAL
+	ldr		r2,	[r1]
+
+	ldr		r1, =CFG_AUTOREFRESH_CMD
+	str		r1,	[r0]
+
+	ldr		r1, =CFG_SDRAM_1_BASE
+	ldr		r2,	[r1] /* Issue AutoRefresh Command */
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+
+	ldr		r1, =CFG_SET_MODE_REG_CMD
+	str		r1,	[r0]
+
+	ldr		r1, =CFG_SDRAM_1_BASE+CFG_SDRAM_MODE_REGISTER_VAL
+	str		r2,	[r1]
+
+	ldr		r1, =CFG_NORMAL_RW_CMD 
+	str		r1,	[r0]
+
+endofmemsetup:
+	mov	pc,r10
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/Makefile u-boot-1.3.4/board/armadeus/apf9328/Makefile
--- u-boot-1.3.4.ref/board/armadeus/apf9328/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/Makefile	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= apf9328.o i2c.o apf9328fpga.o fpga.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -purN u-boot-1.3.4.ref/board/armadeus/apf9328/u-boot.lds u-boot-1.3.4/board/armadeus/apf9328/u-boot.lds
--- u-boot-1.3.4.ref/board/armadeus/apf9328/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/board/armadeus/apf9328/u-boot.lds	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+		cpu/arm920t/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -purN u-boot-1.3.4.ref/include/configs/apf9328.h u-boot-1.3.4/include/configs/apf9328.h
--- u-boot-1.3.4.ref/include/configs/apf9328.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.4/include/configs/apf9328.h	2008-09-13 16:21:18.000000000 +0200
@@ -0,0 +1,1010 @@
+/*
+ * Eric Jarrige <jorasse@users.sourceforge.net>
+ *
+ * Configuation settings for the Armadeus Project motherboard 9328 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * 2005/01/14 Initial version taken from the scb9328 configuration file
+ * 2005/03/10 apf9328 configuration file and trial to improve of
+ *		hardware register control.
+ * 2005/08/16 added APF9328 fpgas and ethernet
+ * 2005/12/02 added filesystem boot over NFS
+ * 2006/11/26 added filesystem boot over NFS
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	" apf9328 patch 3.0"
+
+#define CONFIG_ARM920T		1	/* this is an ARM920T CPU */
+#define CONFIG_IMX		1	/* in a Motorola MC9328MXL Chip */
+#define CONFIG_apf9328		1	/* on a Armadeus project board */
+#undef	CONFIG_USE_IRQ			/* don't need use IRQ/FIQ */
+
+/*
+ * Enable the call to misc_init_r() for miscellaneous platform
+ * dependent initialization.
+ */
+
+#define CONFIG_MISC_INIT_R
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+/*
+ * Select serial console configuration
+ */
+#define CONFIG_IMX_SERIAL1
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200, 230400 }
+#define CONFIG_BAUDRATE 	115200
+
+/*
+ * Definition of u-boot build in commands. Check out CONFIG_CMD_DFL if
+ * neccessary in include/cmd_confdefs.h file. (Un)comment for getting
+ * functionality or size of u-boot code.
+ */
+/*#define CONFIG_COMMANDS		(CONFIG_CMD_DFL		\
+				| CFG_CMD_NET		\
+				| CFG_CMD_PING		\
+				| CFG_CMD_DHCP		\
+				| CFG_CMD_JFFS2		\
+				| CFG_CMD_I2C		\
+				| CFG_CMD_DATE		\
+				| CFG_CMD_EEPROM	\
+				| CONFIG_CMD_ALL	\
+				)
+
+#include <cmd_confdefs.h>
+*/
+#include <config_cmd_default.h>
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ASKENV
+/*#define CONFIG_CMD_CACHE*/	/* icache, dcache		*/
+#define CONFIG_CMD_DATE		/* support for RTC, date/time...*/
+#define CONFIG_CMD_DIAG		/* Diagnostics			*/
+#define CONFIG_CMD_EEPROM	/* EEPROM read/write support	*/
+/*#define CONFIG_CMD_EXT2*/		/* EXT2 Support			*/
+/*#define CONFIG_CMD_FAT*/		/* FAT support			*/
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_IMI		/* iminfo			*/
+#define CONFIG_CMD_IMLS		/* List all found images	*/
+/*#define CONFIG_CMD_IMMAP*/	/* IMMR dump support		*/
+#define CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+/*#define CONFIG_CMD_MII*/		/* MII support			*/
+#define CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+/*#define CONFIG_CMD_MMC*/
+/*#define CONFIG_CMD_PORTIO*/	/* Port I/O			*/
+/*#define CONFIG_CMD_REGINFO*/	/* Register dump		*/
+#define CONFIG_CMD_RUN		/* run command in env variable	*/
+#define CONFIG_CMD_SAVES	/* save S record dump		*/
+/*#define CONFIG_CMD_SDRAM*/	/* SDRAM DIMM SPD info printout */
+#define CONFIG_CMD_SNTP		/* SNTP support			*/
+/*#define CONFIG_CMD_SPI */		/* SPI utility			*/
+/*#define CONFIG_CMD_XIMG*/		/* Load part of Multi Image	*/
+ 
+/*#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_AUTOSCRIPT
+*/
+#undef CONFIG_CMD_REISER
+#define CONFIG_DOS_PARTITION
+/*#define CONFIG_ISO_PARTITION
+*/
+#undef CONFIG_CMD_NAND
+#undef CONFIG_CMD_ONENAND
+#undef CONFIG_CMD_PCMCIA
+#undef CONFIG_CMD_USB
+#undef CONFIG_CMD_BMP
+#undef CONFIG_CMD_DISPLAY
+#undef CONFIG_CMD_BEDBUG
+#undef CONFIG_CMD_DOC
+ 
+/*
+ * Select some advanced features of the commande line parser
+ */
+#define CONFIG_AUTO_COMPLETE 	1	/* Enable auto completion of */
+					/* commands using TAB */
+#define CFG_HUSH_PARSER		1	/* enable the "hush" shell */
+#define CFG_PROMPT_HUSH_PS2	"> "	/* secondary prompt string */
+#define CONFIG_CMDLINE_EDITING  1
+/* eval_board=evk9328
+ * Boot options. Setting delay to -1 stops autostart count down.
+ */
+#define CONFIG_BOOTDELAY	20
+
+#define CONFIG_BOOTARGS \
+	CONFIG_CONSOLE " root=/dev/mtdblock4 rootfstype=jffs2 "CONFIG_MTDPARTS
+
+#define CONFIG_CONSOLE "console=ttySMX0,"MK_STR(CONFIG_BAUDRATE)"n8"
+#define CONFIG_MTDMAP  "apf9328_flash"
+#define CONFIG_MTDPARTS "mtdparts=" CONFIG_MTDMAP ":256k(U-boot)ro,"    \
+			"128k(U-boot_env),256k(firmware),1536k(kernel),6016k(root)"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"fileaddr="		MK_STR(CFG_LOAD_ADDR)		"\0"	\
+	"filesize="		MK_STR(CFG_MONITOR_LEN)		"\0"	\
+	"console="		CONFIG_CONSOLE			"\0"	\
+	"mtdparts="		CONFIG_MTDPARTS			"\0"	\
+	"uboot_addr="		MK_STR(CFG_MONITOR_BASE)	"\0"	\
+	"uboot_len="		MK_STR(CFG_MONITOR_LEN)		"\0"	\
+	"env_addr="		MK_STR(CFG_ENV_ADDR)		"\0"	\
+	"env_len="		MK_STR(CFG_ENV_SIZE)		"\0"	\
+	"firmware_addr="	MK_STR(CONFIG_FIRMWARE_ADDR)	"\0"	\
+	"firmware_len="	MK_STR(CONFIG_FIRMWARE_LEN)	"\0"	\
+	"kernel_addr="		MK_STR(CONFIG_KERNEL_ADDR)	"\0"	\
+	"kernel_len="		MK_STR(CONFIG_KERNEL_LEN)	"\0"	\
+	"rootfs_addr="		MK_STR(CONFIG_ROOTFS_ADDR)	"\0"	\
+	"rootfs_len="		MK_STR(CONFIG_ROOTFS_LEN)	"\0"	\
+	"mmcroot=/dev/mmcblk0p1\0"					\
+	"mmcrootfstype=ext2\0"						\
+	"addnfsargs=setenv bootargs ${bootargs} "			\
+		"root=/dev/nfs rw nfsroot=${serverip}:${rootpath}\0"    \
+	"addjffsargs=setenv bootargs ${bootargs} "			\
+		"root=/dev/mtdblock4 rootfstype=jffs2\0"   		\
+	"addmmcargs=setenv bootargs ${bootargs} "			\
+		"root=${mmcroot} rootfstype=${mmcrootfstype}\0"   		\
+	"addipargs=setenv bootargs ${bootargs} "			\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}::off \0"\
+	"nfsboot=setenv bootargs ${console} ${mtdparts};"		\
+		"run addnfsargs addipargs; bootm ${kernel_addr}\0"	\
+	"jffsboot=setenv bootargs ${console} ${mtdparts};"		\
+		"run addjffsargs addipargs; bootm ${kernel_addr}\0"	\
+	"mmcboot=setenv bootargs ${console} ${mtdparts};"		\
+		"run addmmcargs addipargs; bootm ${kernel_addr}\0"	\
+	"firmware_autoload=0\0"						\
+	"flash_uboot=protect off ${uboot_addr} +${uboot_len};"		\
+		"era ${uboot_addr} +${uboot_len};"			\
+		"if cp.b ${fileaddr} ${uboot_addr} ${filesize};"	\
+			"then protect on ${uboot_addr} +${uboot_len};"	\
+				"echo Flashing uboot succeed;"		\
+			"else echo Flashing uboot failed;"		\
+		"fi; \0"						\
+	"flash_firmware=era ${firmware_addr} +${firmware_len};"		\
+		"if cp.b ${fileaddr} ${firmware_addr} ${filesize} ;"	\
+			"then echo Flashing Firmware succeed;"		\
+			"else echo Flashing Firmware failed;"		\
+		"fi\0"							\
+	"flash_kernel=era ${kernel_addr} +${kernel_len};"		\
+		"if cp.b ${fileaddr} ${kernel_addr} ${filesize} ;"	\
+			"then echo Flashing kernel succeed;"		\
+			"else echo Flashing kernel failed;"		\
+		"fi\0"							\
+	"flash_rootfs=era ${rootfs_addr} +${rootfs_len};"		\
+		"if cp.b ${fileaddr} ${rootfs_addr} ${filesize};"	\
+			"then echo Flashing rootfs succeed;"		\
+			"else echo Flashing rootfs failed;"		\
+		"fi\0"							\
+	"flash_reset_env=protect off ${env_addr} +${env_len};"		\
+		"era ${env_addr} +${env_len};"				\
+		"echo Erasinf flash environment variables done!"	\
+
+#define CONFIG_BOOTCOMMAND	"run jffsboot"
+#define CFG_AUTOLOAD		"no"
+
+#define MACH_TYPE_apf9328	MACH_TYPE_SCB9328
+
+#define CONFIG_MACH_TYPE MACH_TYPE_APF9328
+#define CONFIG_BOOT_PARAMS_ADDR	0x08000100
+
+/*
+ * #define CONFIG_SHOW_BOOT_PROGRESS
+ */
+
+#define CONFIG_ETHADDR		00:1E:AC:00:00:01
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_IPADDR		192.168.000.10
+#define CONFIG_HOSTNAME		"armadeus"
+#define CONFIG_GATEWAYIP	192.168.000.1
+#define CONFIG_SERVERIP		192.168.000.1
+#define CONFIG_ROOTPATH		"/tftpboot/root"
+
+/*
+ * General options for u-boot. Modify to save memory foot print
+ */
+
+#define CFG_LONGHELP
+#define CFG_PROMPT		"BIOS> "	/* prompt string      */
+#define CFG_CBSIZE		256		/* console I/O buffer */
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)	/* print buffer size  */
+#define CFG_MAXARGS		16		/* max command args   */
+#define CFG_BARGSIZE		CFG_CBSIZE	/* boot args buf size */
+
+#define CFG_MEMTEST_START	0x08000000	/* memtest test area  */
+#define CFG_MEMTEST_END		0x08700000
+
+#undef	CFG_CLKS_IN_HZ				/* use HZ for freq. display  */
+#define CFG_HZ			1000000		/* incrementer freq: 1 MHz   */
+
+/*
+ * Definitions related to passing arguments to kernel.
+ */
+
+#define CONFIG_CMDLINE_TAG	1	/* send commandline to Kernel        */
+#define CONFIG_SETUP_MEMORY_TAGS 1	/* send memory definition to kernel */
+#define CONFIG_INITRD_TAG	1	/* send initrd params                */
+#undef	CONFIG_VFD			/* do not send framebuffer setup    */
+
+/*
+ * Malloc pool need to host env + 128 Kb reserve for other allocations.
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + (128<<10) )
+
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+#define CONFIG_STACKSIZE	(120<<10)	/* stack size                 */
+
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4<<10)		/* IRQ stack                  */
+#define CONFIG_STACKSIZE_FIQ	(4<<10)		/* FIQ stack                  */
+#endif
+
+/*
+* Clocks configuration
+*/
+/*
+ * PLL configuration
+
+   f_{dpll}=2*f{ref}*(MFI+MFN/(MFD+1))/(PD+1)
+   f_ref=16,777216MHz
+   32768 Hz xtal
+   0x07B32DA5: 192.0000173
+   0x002a141f: 191,9944MHz
+   0x040b2007: 144MHz
+   0x0FB32DA5: 96.00000864 MHz
+   0x042a141f: 96MHz
+   0x0811140d: 64MHz
+   0x040e200e: 150MHz
+   0x00321431: 200MHz
+
+  16 MHz xtal 
+   0x08001800: 64MHz mit 16er Quarz
+   0x04001800: 96MHz mit 16er Quarz
+   0x04002400: 144MHz mit 16er Quarz
+
+   31 |x x x x|x x x x|x x x x|x x x x|x x x x|x x x x|x x x x|x x x x| 0
+      |XXX|--PD---|-------MFD---------|XXX|--MFI--|-----MFN-----------|
+ */
+
+#define CFG_OSC32	32768	/* 32768 or 32000 Hz crystal */
+#undef  CFG_OSC16		/* there is no external 16MHz external clock */
+
+/* MPU CLOCK source before PLL  (should be named CFG_SYS_CLK_FREQ) */
+#define CONFIG_SYS_CLK_FREQ	(512*CFG_OSC32)
+#define CFG_MPCTL0_VAL		0x07B32DA5	/* 192.000017 MHz */
+#define CFG_MPCTL1_VAL		0
+
+/* system clock source before PLL (should be named CFG_SYSPLL_CLK_FREQ) */
+#ifndef CFG_OSC16
+#define CONFIG_SYSPLL_CLK_FREQ	(512*CFG_OSC32)
+#if (CFG_OSC32 == 32000)
+#define CFG_SPCTL0_VAL		0x043F1437	/* 96 MHz */
+#define CFG_SPCTL1_VAL		0
+#define CONFIG_SYS_FREQ		96		/* MHz */
+#else /* CFG_OSC32 == 32768*/
+#define CFG_SPCTL0_VAL		0x0FB32DA5	/* 96.000009 MHz */
+#define CFG_SPCTL1_VAL		0
+#define CONFIG_SYS_FREQ		96		/* MHz */
+#endif /* CFG_OSC32 */
+#else /* CFG_OSC16 in use*/
+#define CONFIG_SYSPLL_CLK_FREQ	CFG_OSC16
+#define CFG_SPCTL0_VAL		0x04001401	/* 96 MHz */
+#define CFG_SPCTL1_VAL		0x0C000040
+#define CONFIG_SYS_FREQ		96		/* MHz */
+#endif /* CFG_OSC16 */
+
+/* external bus frequency (have to be a CONFIG_SYS_FREQ ratio) */
+#define CONFIG_SYS_BUS_FREQ 	96	/* 96|48... MHz (BCLOCK and HCLOCK) */
+#define CONFIG_USB_FREQ		48	/* 48 MHz */
+#define CONFIG_PERIF1_FREQ	16	/* 16 MHz UART, Timer PWM*/
+#define CONFIG_PERIF2_FREQ 	48	/* 48 MHz LCD SD SPI*/
+#define CONFIG_PERIF3_FREQ	16	/* 16 MHz SSI*/
+
+
+/*
+ * SDRAM definition parameter
+ */
+#define CONFIG_NR_DRAM_BANKS	1	/* we have and support only 1 bank of SDRAM */
+
+#define CFG_SDRAM_MBYTE_SYZE 16
+
+#if (CFG_SDRAM_MBYTE_SYZE == 8)
+/* micron 8MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits         */
+#define CFG_SDRAM_1_SIZE	0x00800000 /* 8 MB                */
+#define CFG_SDRAM_NUM_COL		8  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		11 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		2  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+#if (CFG_SDRAM_MBYTE_SYZE == 16)
+/* micron 16MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits    */
+#define CFG_SDRAM_1_SIZE	0x01000000 /* 16 MB                   */
+#define CFG_SDRAM_NUM_COL		8  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		12 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		2  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+#if (CFG_SDRAM_MBYTE_SYZE == 32)
+/* micron 32MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits    */
+#define CFG_SDRAM_1_SIZE	0x02000000 /* 32 MB                   */
+#define CFG_SDRAM_NUM_COL		9  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		12 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		2  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+#if (CFG_SDRAM_MBYTE_SYZE == 64)
+/* micron 64MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits    */
+#define CFG_SDRAM_1_SIZE	0x04000000 /* 64 MB                   */
+#define CFG_SDRAM_NUM_COL		9  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		13 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		3  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+/*
+ * Configuration for a maximum 32MB of FLASH memory
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* FLASH banks count (not chip count) */
+#define CFG_MAX_FLASH_SECT	256	/* number of sector in FLASH bank     */
+#define CFG_FLASH_BASE		0x10000000 /* location of flash memory        */
+
+/* This should be defined if CFI FLASH device is present. */
+#define	CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+#define CFG_FLASH_USE_BUFFER_WRITE 	1 /* use buffered writes (20x faster) */
+#define CFG_FLASH_PROTECTION		1
+
+/*
+ * This is setting for JFFS2 support in u-boot.
+ * NOTE: Enable CFG_CMD_JFFS2 for JFFS2 support.
+ */
+#define CFG_JFFS2_FIRST_BANK		0
+#define CFG_JFFS2_FIRST_SECTOR		5
+#define CFG_JFFS2_NUM_BANKS		1
+/*
+ * Environment setup. Definitions of monitor location and size with
+ * definition of environment setup ends up in 2 possibilities.
+ * 1. Embeded environment - in u-boot code is space for environment
+ * 2. Environment is read from predefined sector of flash
+ * Right now we support 2. possiblity, but expecting no env placed
+ * on mentioned address right now. This also needs to provide whole
+ * sector for it - for us 256Kb is really waste of memory. U-boot uses
+ * default env. and until kernel parameters could be sent to kernel
+ * env. has no sense to us.
+ */
+
+#define	CFG_MONITOR_BASE	0x10000000
+#define	CFG_MONITOR_LEN		0x00040000	/* 256kB ( 2 flash sector )  */
+#define	CFG_ENV_IS_IN_FLASH	1
+#define	CFG_ENV_ADDR		0x10040000	/* absolute address for now  */
+#define	CFG_ENV_SIZE		0x00020000
+#define	CFG_ENV_SECT_SIZE	0x00020000
+#define	CONFIG_ENV_OVERWRITE	1		/* env is writable now   */
+#define	CONFIG_FIRMWARE_ADDR	0x10060000
+#define	CONFIG_FIRMWARE_LEN	0x00040000	/* 256kB ( 2 flash sector )  */
+#define	CONFIG_KERNEL_ADDR	0x100A0000
+#define	CONFIG_KERNEL_LEN	0x00180000	/* 1.5MB */
+#define	CONFIG_ROOTFS_ADDR	0x10220000
+#define	CONFIG_ROOTFS_LEN	0x005E0000	/* almost 6MB */
+
+/*
+ * Default load address for user programs and kernel
+ */
+#define CFG_LOAD_ADDR		0x08000000
+#define	CONFIG_LOADADDR		0x08000000
+#define CFG_TFTP_LOADADDR	0x08000000
+/*
+ * Hardware drivers
+ */
+
+/* DM9000 ethernet chipset assigned to CS4 */
+/* For the apf board DM9000 base is 0x15C00000 and data is base+2	*/
+/* For the apm board DM9000 base is 0x15C3FFFC and data is base+4	*/
+#define CONFIG_DRIVER_DM9000	1
+#undef  CONFIG_DM9000_DEBUG
+#define CONFIG_DM9000_BASE    0x15C00000
+#define DM9000_IO		CONFIG_DM9000_BASE
+#define DM9000_DATA		(CONFIG_DM9000_BASE+2)
+#define CONFIG_DM9000_USE_16BIT
+
+/*-----------------------------------------------------------------------
+ * FPGA stuff
+ */
+#define CONFIG_FPGA_COUNT	1
+/* only digital value for CONFIG_FPGA is supported (investigation pending)    */
+#define CONFIG_FPGA		0x801		/* CFG_XILINX_SPARTAN3 */
+#define CONFIG_FPGA_XILINX
+#define CONFIG_FPGA_SPARTAN3
+#define CFG_FPGA_WAIT		250
+#define CFG_FPGA_PROG_FEEDBACK
+#define CFG_FPGA_CHECK_CTRLC
+#define CFG_FPGA_CHECK_ERROR
+/* FPGA program pin configuration */
+#define CFG_FPGA_PRG	(GPIO_PORTB | 18)	/* FPGA prog pin (SSI output) */
+#define CFG_FPGA_CLK	(GPIO_PORTB | 19)	/* FPGA clk pin  (SSI output) */
+#define CFG_FPGA_DATA	(GPIO_PORTB | 17)	/* FPGA data pin (SSI output) */
+#define CFG_FPGA_INIT	(GPIO_PORTB | 15)	/* FPGA init pin (SSI input)  */
+#define CFG_FPGA_DONE	(GPIO_PORTB | 16)	/* FPGA done pin (SSI input)  */
+
+/*
+ * I2C bus
+ */
+
+#define	CONFIG_HARD_I2C		1	/* I2C with hardware support    */
+
+#define CFG_I2C_SPEED		400000	/* 400 kHz */
+#define CFG_I2C_SLAVE		0x7F
+
+# define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM 24LC256               */
+# define CFG_I2C_EEPROM_ADDR_LEN 2	/* bytes of address             */
+/* mask of address bits that overflow into the "EEPROM chip address"    */
+/*#define CFG_I2C_EEPROM_ADDR_OVERFLOW	0x00*/
+#define CFG_EEPROM_PAGE_WRITE_BITS	6
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	10	/* takes up to 10 msec */
+
+#define CONFIG_RTC_DS1374
+/*#define CONFIG_MMC		1
+*/
+/*
+ * External interfaces module
+ *
+ * CSxU_VAL:
+ * 63|    x    |x|x x|x x x x|x x| x | x  |x x x x|48
+ *   |DTACK_SEL|0|BCD|  BCS  |PSZ|PME|SYNC|  DOL  |
+ *
+ * 47| x x  | x x x x x x | x | x x x x | x x x x |32
+ *   | CNC  |     WSC     | 0 |   WWS   |   EDC   |
+ *
+ * CSxL_VAL:
+ * 31|  x x x x  | x x x x  | x x x x  | x x x x  |24
+ *   |    OEA    |   OEN    |   WEA    |   WEN    |
+ * 23|x x x x| x | x x x | x x  x x |x x| x |  x  | 0
+ *   |  CSA  |EBC|  DSZ  | 0|SP|0|WP|0 0|PA |CSEN |
+ */
+
+/* CS0 configuration for  flash memory Micron MT28F128J3-150 */
+#define CFG_CS0_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals */
+#define CFG_CS0_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins  */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS0_SUPERVISOR_PROTECT	0   /* 1 : user mode access prohibited  */
+#define CFG_CS0_WRITE_PROTECT		0   /* 1 : write access prohibited  */
+#define CFG_CS0_EB_SIGNAL_CONTROL_WRITE	1   /* 1 when EB is used as write signal */
+#define CFG_CS0_READ_CYC_LGTH		150	/* ns */
+#define CFG_CS0_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS0_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS0_CS_NEG_LGTH 	0	/* ns CS HIGH to CS LOW : tCWH */
+#define CFG_CS0_XTRA_DEAD_CYC	35	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS0_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS0_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS0_EB_NEG_DLY		0	/* ns */
+#define CFG_CS0_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS0_SYNC_ENABLE		1	/* enable synchronous burst mode */
+#define CFG_CS0_SYNC_PAGE_MODE_EMUL	1	/* enable page mode emulation */
+#define CFG_CS0_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS0_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS0_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS0_SYNC_DAT_OUT_LGTH	25	/* ns */
+
+/* CS1 configuration for  */
+#define CFG_CS1_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals  */
+#define CFG_CS1_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS1_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins*/
+						/* 3=8bits on D[7:0] 6=32 bits..*/ 
+#define CFG_CS1_SUPERVISOR_PROTECT	0	/* 1 : user mode access prohibited  */
+#define CFG_CS1_WRITE_PROTECT		0	/* 1 : write access prohibited  */
+#define CFG_CS1_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal */
+
+#define CFG_CS1_READ_CYC_LGTH		50	/* ns */
+#define CFG_CS1_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS1_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS1_CS_NEG_LGTH 	0	/* max 30 ns CS HIGH to CS LOW at 100MHz */
+#define CFG_CS1_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS1_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS1_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS1_EB_NEG_DLY		0	/* ns */
+#define CFG_CS1_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS1_SYNC_ENABLE		0	/* enable synchronous burst mode */
+#define CFG_CS1_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation */
+#define CFG_CS1_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS1_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS1_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS1_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS2 configuration for  */
+#define CFG_CS2_CHIP_SELECT_ENABLE	0	/* 1 : enable CS0 peripherals  */
+#define CFG_CS2_PIN_ASSERT		0	/* chip select pin state when */
+						/*chip select disabled  */
+#define CFG_CS2_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS2_SUPERVISOR_PROTECT	0	/* 1 : user mode access prohibited  */
+#define CFG_CS2_WRITE_PROTECT		0	/* 1 : write access prohibited  */
+#define CFG_CS2_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal */
+
+#define CFG_CS2_READ_CYC_LGTH		0	/* ns */
+#define CFG_CS2_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS2_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS2_CS_NEG_LGTH 	0	/* max 30 ns CS HIGH to CS LOW at 100MHz */
+#define CFG_CS2_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS2_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS2_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS2_EB_NEG_DLY		0	/* ns */
+#define CFG_CS2_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS2_SYNC_ENABLE		0	/* enable synchronous burst mode */
+#define CFG_CS2_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation*/
+#define CFG_CS2_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS2_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS2_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS2_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS3 configuration for  */
+#define CFG_CS3_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals  */
+#define CFG_CS3_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS3_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS3_SUPERVISOR_PROTECT	0	/* 1: user mode access prohibited*/
+#define CFG_CS3_WRITE_PROTECT		0	/* 1: write access prohibited  */
+#define CFG_CS3_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal*/
+
+#define CFG_CS3_READ_CYC_LGTH		0	/* ns */
+#define CFG_CS3_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS3_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS3_CS_NEG_LGTH 	0	/* max 30 ns CS HIGH to CS LOW at 100MHz */
+#define CFG_CS3_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS3_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS3_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS3_EB_NEG_DLY		0	/* ns */
+#define CFG_CS3_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS3_SYNC_ENABLE		0	/* enable synchronous burst mode*/
+#define CFG_CS3_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation*/
+#define CFG_CS3_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS3_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS3_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS3_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS4 configuration for DM9000 ethernet chipset */
+#define CFG_CS4_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals  */
+#define CFG_CS4_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS4_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS4_SUPERVISOR_PROTECT	0	/* 1 : user mode access prohibited*/
+#define CFG_CS4_WRITE_PROTECT		0	/* 1 : write access prohibited  */
+#define CFG_CS4_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal*/
+
+#define CFG_CS4_READ_CYC_LGTH		72	/* ns */
+#define CFG_CS4_OE_ASSERT_DLY		5	/* ns */
+#define CFG_CS4_OE_NEG_DLY		45	/* ns */
+
+#define CFG_CS4_CS_NEG_LGTH 	30	/* max 30 ns CS HIGH to CS LOW at 100MHz*/
+#define CFG_CS4_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS4_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS4_EB_ASSERT_DLY		5	/* ns */
+#define CFG_CS4_EB_NEG_DLY		45	/* ns */
+#define CFG_CS4_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS4_SYNC_ENABLE		0	/* enable synchronous burst mode*/
+#define CFG_CS4_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation */
+#define CFG_CS4_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS4_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS4_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS4_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS5 configuration for  */
+#define CFG_CS5_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals */
+#define CFG_CS5_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS5_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS5_SUPERVISOR_PROTECT	0	/* 1: user mode access prohibited*/
+#define CFG_CS5_WRITE_PROTECT		0	/* 1 : write access prohibited*/
+#define CFG_CS5_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal*/
+#define CFG_CS5_DTACK_SELECT		1	/* Activate DTACK fonction */
+						/* (asynchrone bus) */
+
+#define CFG_CS5_READ_CYC_LGTH		-1	/* ns or -1 to DTACK function */
+#define CFG_CS5_OE_ASSERT_DLY		10	/* ns */
+#define CFG_CS5_OE_NEG_DLY		10	/* ns */
+
+#define CFG_CS5_CS_NEG_LGTH 	10	/* max 30 ns CS HIGH to CS LOW at 100MHz*/
+#define CFG_CS5_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS5_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS5_EB_ASSERT_DLY		10	/* ns */
+#define CFG_CS5_EB_NEG_DLY		10	/* ns */
+#define CFG_CS5_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS5_SYNC_ENABLE		0	/* enable synchron burst mode */
+#define CFG_CS5_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation */
+#define CFG_CS5_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS5_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS5_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS5_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/*
+ * Default configuration for GPIOs and peripherals
+ */
+#define CFG_DDIR_A_VAL		0x00000000
+#define CFG_OCR1_A_VAL		0x00000000
+#define CFG_OCR2_A_VAL		0x00000000
+#define CFG_ICFA1_A_VAL		0xFFFFFFFF
+#define CFG_ICFA2_A_VAL		0xFFFFFFFF
+#define CFG_ICFB1_A_VAL		0xFFFFFFFF
+#define CFG_ICFB2_A_VAL		0xFFFFFFFF
+#define CFG_DR_A_VAL		0x00000000
+
+/* Setup for PA23 which is Reset Default PA23 but has to become
+   CS5 */
+#define CFG_GIUS_A_VAL		0x00007FF8
+#define CFG_ICR1_A_VAL		0x00000000
+#define CFG_ICR2_A_VAL		0x00000000
+#define CFG_IMR_A_VAL		0x00000000
+#define CFG_GPR_A_VAL		0x00000000
+#define CFG_PUEN_A_VAL		0xFFFFFFFF
+
+#define CFG_DDIR_B_VAL		0x00000000
+#define CFG_OCR1_B_VAL		0x00000000
+#define CFG_OCR2_B_VAL		0x00000000
+#define CFG_ICFA1_B_VAL		0xFFFFFFFF
+#define CFG_ICFA2_B_VAL		0xFFFFFFFF
+#define CFG_ICFB1_B_VAL		0xFFFFFFFF
+#define CFG_ICFB2_B_VAL		0xFFFFFFFF
+#define CFG_DR_B_VAL		0x00000000
+#define CFG_GIUS_B_VAL		0xFFFFFFFF
+#define CFG_ICR1_B_VAL		0x00000000
+#define CFG_ICR2_B_VAL		0x00000000
+#define CFG_IMR_B_VAL		0x00000000
+#define CFG_GPR_B_VAL		0x00000000
+#define CFG_PUEN_B_VAL		0xFFFFFFFF
+
+#define CFG_DDIR_C_VAL		0x00000000
+#define CFG_OCR1_C_VAL		0x00000000
+#define CFG_OCR2_C_VAL		0x00000000
+#define CFG_ICFA1_C_VAL		0xFFFFFFFF
+#define CFG_ICFA2_C_VAL		0xFFFFFFFF
+#define CFG_ICFB1_C_VAL		0xFFFFFFFF
+#define CFG_ICFB2_C_VAL		0xFFFFFFFF
+#define CFG_DR_C_VAL		0x00000000
+#define CFG_GIUS_C_VAL		0x0007FFFF
+#define CFG_ICR1_C_VAL		0x00000000
+#define CFG_ICR2_C_VAL		0x00000000
+#define CFG_IMR_C_VAL		0x00000000
+#define CFG_GPR_C_VAL		0x00000000
+#define CFG_PUEN_C_VAL		0xF913FFFF
+
+#define CFG_DDIR_D_VAL		0x00000000
+#define CFG_OCR1_D_VAL		0x00000000
+#define CFG_OCR2_D_VAL		0x00000000
+#define CFG_ICFA1_D_VAL		0xFFFFFFFF
+#define CFG_ICFA2_D_VAL		0xFFFFFFFF
+#define CFG_ICFB1_D_VAL		0xFFFFFFFF
+#define CFG_ICFB2_D_VAL		0xFFFFFFFF
+#define CFG_DR_D_VAL		0x00000000
+#define CFG_GIUS_D_VAL		0xFFFFFFFF
+#define CFG_ICR1_D_VAL		0x00000000
+#define CFG_ICR2_D_VAL		0x00000000
+#define CFG_IMR_D_VAL		0x00000000
+#define CFG_GPR_D_VAL		0x00000000
+#define CFG_PUEN_D_VAL		0xFFFFFFFF
+
+#define CFG_GPCR_VAL		0x000003AB
+
+/* FMCR Bit 1 becomes 0 to make CS3 if we have only one sdram bank*/
+#if (CONFIG_NR_DRAM_BANKS == 1)
+#define CFG_FMCR_VAL 0x00000001
+#elif (CONFIG_NR_DRAM_BANKS == 2)
+#define CFG_FMCR_VAL 0x00000003
+#endif
+
+/*
+ * FIXME: From here, there should not be any user configuration.
+ * All Equations are automatic
+ */
+
+
+#define CFG_HCLK_LGTH		(1000/CONFIG_SYS_BUS_FREQ)	/* ns */
+
+/* USB 48 MHz ; BUS 96MHz*/
+#ifdef CFG_OSC16
+#define CSCR_MASK 0x23030003
+#else
+#define CSCR_MASK 0x23000003
+#endif
+#define CFG_CSCR_VAL\
+	(CSCR_MASK 						\
+	|((((CONFIG_SYS_FREQ/CONFIG_USB_FREQ)-1)&0x07)<<26)	\
+	|((((CONFIG_SYS_FREQ/CONFIG_SYS_BUS_FREQ)-1)&0x0F)<<10))
+
+/* PERCLKx 16MHz */
+#define CFG_PCDR_VAL\
+	(((((CONFIG_SYS_FREQ/CONFIG_PERIF1_FREQ)-1)&0x0F)<<0)	\
+	|((((CONFIG_SYS_FREQ/CONFIG_PERIF2_FREQ)-1)&0x0F)<<4)	\
+	|((((CONFIG_SYS_FREQ/CONFIG_PERIF3_FREQ)-1)&0x7F)<<16))
+
+/* SDRAM controller programming Values */
+#if ((CFG_SDRAM_CLOCK_CYCLE_CL_1>(3*CFG_HCLK_LGTH))\
+	||(CFG_SDRAM_CLOCK_CYCLE_CL_1<1))
+#define REG_FIELD_SCL_VAL 3
+#else
+#define REG_FIELD_SCL_VAL\
+	((CFG_SDRAM_CLOCK_CYCLE_CL_1+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)
+#endif
+
+#if ((CFG_SDRAM_ROW_PRECHARGE_DELAY>(2*CFG_HCLK_LGTH))\
+	||(CFG_SDRAM_ROW_PRECHARGE_DELAY<1))
+#define REG_FIELD_SRP_VAL 0
+#else
+#define REG_FIELD_SRP_VAL 1
+#endif
+
+#if (CFG_SDRAM_ROW_2_COL_DELAY>(3*CFG_HCLK_LGTH))
+#define REG_FIELD_SRCD_VAL 0
+#else
+#define REG_FIELD_SRCD_VAL\
+	((CFG_SDRAM_ROW_2_COL_DELAY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)
+#endif
+
+#if (CFG_SDRAM_ROW_CYCLE_DELAY>(7*CFG_HCLK_LGTH))
+#define REG_FIELD_SRC_VAL 0
+#else
+#define REG_FIELD_SRC_VAL\
+	((CFG_SDRAM_ROW_CYCLE_DELAY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)
+#endif
+
+#define REG_SDCTL_BASE_CONFIG (0x800a1000\
+				| (((CFG_SDRAM_NUM_ROW-11)&0x3)<<24)\
+				| (((CFG_SDRAM_NUM_COL-8)&0x3)<<20)\
+				| (((CFG_SDRAM_REFRESH)&0x3)<<14)\
+				| (((REG_FIELD_SCL_VAL)&0x3)<<8)\
+				| (((REG_FIELD_SRP_VAL)&0x1)<<6)\
+				| (((REG_FIELD_SRCD_VAL)&0x3)<<4)\
+				| (((REG_FIELD_SRC_VAL)&0x7)<<0))
+
+#define CFG_NORMAL_RW_CMD	((0x0<<28)+REG_SDCTL_BASE_CONFIG)
+#define CFG_PRECHARGE_CMD	((0x1<<28)+REG_SDCTL_BASE_CONFIG)
+#define CFG_AUTOREFRESH_CMD	((0x2<<28)+REG_SDCTL_BASE_CONFIG)
+#define CFG_SET_MODE_REG_CMD	((0x3<<28)+REG_SDCTL_BASE_CONFIG)
+
+/* Issue Mode register Command to SDRAM*/
+#define CFG_SDRAM_MODE_REGISTER_VAL\
+	((((CFG_SDRAM_BURST_LENGTH)&0x7)<<(CFG_SDRAM_NUM_COL+4))\
+	| (((REG_FIELD_SCL_VAL)&0x3)<<(CFG_SDRAM_NUM_COL+4+4))\
+	| (((CFG_SDRAM_SINGLE_ACCESS)&0x1)<<(CFG_SDRAM_NUM_COL+4+9)))
+
+/* Issue Precharge all Command to SDRAM*/
+#define CFG_SDRAM_PRECHARGE_ALL_VAL\
+	(((CFG_SDRAM_SINGLE_ACCESS)&0x1)<<(CFG_SDRAM_NUM_COL+4+9))
+
+/* undef CONFIG_INIT_CRITICAL is no more required to boot from sdram */
+#undef CONFIG_INIT_CRITICAL
+
+/*
+ * CSxU_VAL:
+ * 63|    x    |x|x x|x x x x|x x| x | x  |x x x x|48
+ *   |DTACK_SEL|0|BCD|  BCS  |PSZ|PME|SYNC|  DOL  |
+ *
+ * 47| x x  | x x x x x x | x | x x x x | x x x x |32
+ *   | CNC  |     WSC     | 0 |   WWS   |   EDC   |
+ *
+ * CSxL_VAL:
+ * 31|  x x x x  | x x x x  | x x x x  | x x x x  |24
+ *   |    OEA    |   OEN    |   WEA    |   WEN    |
+ * 23|x x x x| x | x x x | x x  x x |x x| x |  x  | 0
+ *   |  CSA  |EBC|  DSZ  | 0|SP|0|WP|0 0|PA |CSEN |
+ */
+#define CFG_CS0U_VAL\
+	((((CFG_CS0_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS0_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS0_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS0_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS0_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS0_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS0_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS0_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS0_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS0_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS0L_VAL\
+	((CFG_CS0_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS0_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS0_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS0_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS0_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS0_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS0_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS0_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS0_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS0_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS1U_VAL\
+	((((CFG_CS1_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS1_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS1_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS1_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS1_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS1_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS1_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS1_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS1_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS1_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS1L_VAL\
+	((CFG_CS1_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS1_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS1_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS1_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS1_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS1_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS1_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS1_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS1_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS1_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS1_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS2U_VAL\
+	(((((CFG_CS2_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS2_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS2_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS2_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|(((CFG_CS2_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS2_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS2_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS2_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS2_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS2_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS2L_VAL\
+	((CFG_CS2_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS2_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS2_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS2_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS2_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS2_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS2_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS2_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS2_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS2_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS2_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS3U_VAL\
+	((((CFG_CS3_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS3_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS3_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS3_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS3_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS3_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS3_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS3_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS3_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS3_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS3L_VAL\
+	((CFG_CS3_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS3_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS3_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS3_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS3_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS3_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS3_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS3_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS3_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS3_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS3_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS4U_VAL\
+	(((((CFG_CS4_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS4_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS4_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS4_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS4_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16))\
+	|((CFG_CS4_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS4_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS4_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS4_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS4_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS4L_VAL\
+	((CFG_CS4_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS4_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS4_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS4_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS4_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS4_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS4_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS4_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS4_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS4_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS4_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS5U_VAL\
+	((((CFG_CS5_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS5_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS5_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS5_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS5_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS5_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS5_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS5_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS5_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS5_SYNC_BURST_CLK_DIV&0x03)<<28)\
+	|((CFG_CS5_DTACK_SELECT&0x01)<<31))
+
+#define CFG_CS5L_VAL\
+	((CFG_CS5_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS5_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS5_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS5_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS5_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS5_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS5_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS5_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS5_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS5_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS5_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#endif /* __CONFIG_H */
