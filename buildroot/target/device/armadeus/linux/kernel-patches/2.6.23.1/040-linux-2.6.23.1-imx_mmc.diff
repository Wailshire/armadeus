--- linux-org/arch/arm/mach-imx/generic.c	2006-10-20 00:13:49.000000000 +0200
+++ linux-imx/arch/arm/mach-imx/generic.c	2006-10-18 22:47:19.000000000 +0200
@@ -187,10 +187,13 @@ static struct resource imx_mmc_resources
 
 static u64 imxmmmc_dmamask = 0xffffffffUL;
 
+static struct imxmmc_platform_data imx_mmc_info;
+
 static struct platform_device imx_mmc_device = {
 	.name		= "imx-mmc",
 	.id		= 0,
 	.dev		= {
+		.platform_data	= &imx_mmc_info,
 		.dma_mask = &imxmmmc_dmamask,
 		.coherent_dma_mask = 0xffffffff,
 	},
@@ -200,7 +203,7 @@ static struct platform_device imx_mmc_de
 
 void __init imx_set_mmc_info(struct imxmmc_platform_data *info)
 {
-	imx_mmc_device.dev.platform_data = info;
+	memcpy(&imx_mmc_info,info,sizeof(struct imxmmc_platform_data));
 }
 EXPORT_SYMBOL(imx_set_mmc_info);
 
--- linux-org/drivers/mmc/host/imxmmc.c	2006-10-20 00:13:38.000000000 +0200
+++ linux-imx/drivers/mmc/host/imxmmc.c	2006-10-20 00:05:56.000000000 +0200
@@ -902,6 +902,25 @@ static int platform_device_irq(struct pl
 	return NO_IRQ;
 }
 
+static int imxmci_card_present(void)
+{
+	static int lsCurrentState = 1;
+	static int lsTrials = 3;
+	int lSampleState = (MMC_STATUS & STATUS_CARD_PRESENCE)?1:0;
+
+	if (!(MMC_STATUS & STATUS_CARD_BUS_CLK_RUN)
+	   && (lSampleState != lsCurrentState)) {
+		if (0 == --lsTrials) {
+			lsCurrentState = lSampleState;
+			lsTrials = 3;
+		}
+	} else {
+		lsTrials = 3;
+	}
+
+	return(lsCurrentState);
+}
+
 static void imxmci_check_status(unsigned long data)
 {
 	struct imxmci_host *host = (struct imxmci_host *)data;
@@ -1012,6 +1031,9 @@ static int imxmci_probe(struct platform_
 	ret = request_irq(host->irq, imxmci_irq, 0, DRIVER_NAME, host);
 	if (ret)
 		goto out;
+	
+	if (!host->pdata->card_present)
+		host->pdata->card_present = imxmci_card_present;
 
 	host->present = host->pdata->card_present();
 	init_timer(&host->timer);
--- linux-org/include/asm-arm/arch-imx/imx-regs.h	2006-10-20 00:13:49.000000000 +0200
+++ linux-imx/include/asm-arm/arch-imx/imx-regs.h	2006-10-18 22:47:19.000000000 +0200
@@ -166,7 +166,7 @@
 #define PB9_AF_MS_PI1        ( GPIO_PORTB | GPIO_AF | 9 )
 #define PB10_PF_SD_DAT2      ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 10 )
 #define PB10_AF_MS_SCLKI     ( GPIO_PORTB | GPIO_AF | 10 )
-#define PB11_PF_SD_DAT3      ( GPIO_PORTB | GPIO_PF | 11 )
+#define PB11_PF_SD_DAT3      ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 11 )
 #define PB11_AF_MS_SDIO      ( GPIO_PORTB | GPIO_AF | 11 )
 #define PB12_PF_SD_CLK       ( GPIO_PORTB | GPIO_PF | 12 )
 #define PB12_AF_MS_SCLK0     ( GPIO_PORTB | GPIO_AF | 12 )
--- linux-org/drivers/mmc/host/imxmmc.c	2008-01-28 17:36:24.000000000 +0100
+++ linux-imx/drivers/mmc/host/imxmmc.c	2008-01-28 17:36:47.000000000 +0100
@@ -220,7 +220,7 @@ static int imxmci_busy_wait_for_status(s
 
 	/* The busy-wait is expected there for clock <8MHz due to SDHC hardware flaws */
 	if(!(stat_mask & STATUS_END_CMD_RESP) || (host->mmc->ios.clock>=8000000))
-		dev_info(mmc_dev(host->mmc), "busy wait for %d usec in %s, STATUS = 0x%x (0x%x)\n",
+		dev_dbg(mmc_dev(host->mmc), "busy wait for %d usec in %s, STATUS = 0x%x (0x%x)\n",
 			loops, where, *pstat, stat_mask);
 	return loops;
 }
--- linux-org/drivers/mmc/host/imxmmc.c	2008-06-02 04:25:41.000000000 +0200
+++ linux-imx/drivers/mmc/host/imxmmc.c	2008-06-02 04:22:21.000000000 +0200
@@ -336,6 +336,12 @@ static void imxmci_start_cmd(struct imxm
 	/* Ensure, that clock are stopped else command programming and start fails */
 	imxmci_stop_clock(host);
 
+	/*force check of busy bit DO after CMD25 + CMD12 
+		to avoid hang up of the controler */
+	if( cmd->opcode == 13){
+		cmdat |= CMD_DAT_CONT_BUSY; 
+	}
+
 	if (cmd->flags & MMC_RSP_BUSY)
 		cmdat |= CMD_DAT_CONT_BUSY;
