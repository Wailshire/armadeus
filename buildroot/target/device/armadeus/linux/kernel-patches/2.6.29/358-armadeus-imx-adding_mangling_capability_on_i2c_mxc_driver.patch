Adding mangling capability on mxc IÂ²C driver.

Signed-off-by: Fabien Marteau <fabien.marteau@armadeus.com>

Index: linux-2.6.29.6/drivers/i2c/busses/i2c-mxc.c
===================================================================
--- linux-2.6.29.6.orig/drivers/i2c/busses/i2c-mxc.c	2010-06-25 18:19:38.000000000 +0200
+++ linux-2.6.29.6/drivers/i2c/busses/i2c-mxc.c	2010-06-25 18:23:43.000000000 +0200
@@ -45,6 +45,7 @@
 	struct clk *clk;
 	bool low_power;
 	struct imx_i2c_platform_data *pdata;
+	int trans_flag;
 } imx_i2c_device;
 
 /*
@@ -99,7 +100,9 @@
 	 */
 	for (;;) {
 		unsigned int sr = readw(dev->membase + MXC_I2SR);
-		if ((sr & MXC_I2SR_IBB) == 0) break;
+		if ((sr & MXC_I2SR_IBB) == 0) {
+			break;
+		}
 		if (retry-- <= 0) {
 #ifdef I2C_DEBUG
 			printk(KERN_DEBUG "Bus busy\n");
@@ -118,7 +121,13 @@
  */
 static int imx_i2c_wait_for_tc(imx_i2c_device * dev, int trans_flag)
 {
-	int retry = 4;
+	int retry;
+
+	if (trans_flag & I2C_M_IGNORE_NAK) {
+		retry = 1;
+	} else {
+		retry = 4;
+	}
 
 	while (retry-- && !transfer_done) {
 		wait_event_interruptible_timeout(dev->wq,
@@ -138,8 +147,12 @@
 #ifdef I2C_DEBUG
 		printk(KERN_DEBUG "Data not transmitted\n");
 #endif
-		return -1;
-	}
+		if (trans_flag & I2C_M_IGNORE_NAK) {
+			return 0;
+		} else {
+			return -1;
+		}
+ 	}
 
 	return 0;
 }
@@ -156,7 +169,9 @@
 	 * in the data register
 	 */
 	addr_trans = msg->addr << 1;
-	if (msg->flags & I2C_M_RD) {
+	if ((msg->flags & I2C_M_RD) && ((msg->flags & I2C_M_REV_DIR_ADDR)==0)) {
+		addr_trans |= 0x01;
+	} else if ((msg->flags & I2C_M_REV_DIR_ADDR) != 0) {
 		addr_trans |= 0x01;
 	}
 
@@ -196,7 +211,9 @@
 	 * in the data register
 	 */
 	addr_trans = msg->addr << 1;
-	if (msg->flags & I2C_M_RD) {
+	if ((msg->flags & I2C_M_RD) && ((msg->flags & I2C_M_REV_DIR_ADDR)==0)) {
+		addr_trans |= 0x01;
+	} else if ((msg->flags & I2C_M_REV_DIR_ADDR) != 0) {
 		addr_trans |= 0x01;
 	}
 	cr = readw(dev->membase + MXC_I2CR);
@@ -227,17 +244,19 @@
 	/*
 	 * Clear the TXAK bit to gen an ack when receiving only one byte.
 	 */
-	if (len == 1)
+	if (len == 1) {
 		cr |= MXC_I2CR_TXAK;
-	else
+	} else {
 		cr &= ~MXC_I2CR_TXAK;
+	}
 
 	writew(cr, dev->membase + MXC_I2CR);
 	/*
 	 * Dummy read only at the end of an address cycle
 	 */
-	if (addr_comp > 0)
+	if (addr_comp > 0) {
 		readw(dev->membase + MXC_I2DR);
+	}
 
 	for (i = 0; i < len; i++) {
 		/* Wait for data transmission to complete */
@@ -245,14 +264,21 @@
 			imx_i2c_stop(dev);
 			return -1;
 		}
-		/* Do not generate an ACK for the last byte */
+		/* Do not generate an ACK for the last byte
+		 * or if I2C_M_NO_RD_ACK flag is set
+		 */
 		if (i == (len - 2)) {
 			cr = readw(dev->membase + MXC_I2CR);
-			cr |= MXC_I2CR_TXAK;
+			if ((msg->flags & I2C_M_NO_RD_ACK) == 0) {
+				cr |= MXC_I2CR_TXAK;
+			} else {
+				cr &= ~MXC_I2CR_TXAK;
+			}
 			writew(cr, dev->membase + MXC_I2CR);
 		} else if (i == (len - 1)) {
-			if (last)
+			if (last) {
 				imx_i2c_stop(dev);
+			}
 		}
 		/* Read the data */
 		*buf++ = readw(dev->membase + MXC_I2DR);
@@ -333,8 +359,9 @@
 		return -EREMOTEIO;
 	}
 
-	if (num < 1)
+	if (num < 1) {
 		return 0;
+	}
 
 	imx_i2c_module_en(dev, msgs[0].flags);
 	sr = readw(dev->membase + MXC_I2SR);
@@ -352,6 +379,7 @@
 	tx_success = false;
 	for (i = 0; i < num && ret >= 0; i++) {
 		addr_comp = 0;
+		dev->trans_flag = msgs[i].flags;
 		/*
 		 * Send the slave address and transfer direction in the
 		 * address cycle
@@ -372,16 +400,18 @@
 			 * changed or the transfer direction changed
 			 */
 			if ((msgs[i].addr != msgs[i - 1].addr) ||
-			    ((msgs[i].flags & I2C_M_RD) !=
-			     (msgs[i - 1].flags & I2C_M_RD))) {
-				imx_i2c_repstart(dev, &msgs[i]);
-				/* Wait for the address cycle to complete */
-				if (imx_i2c_wait_for_tc(dev, msgs[i].flags)) {
-					imx_i2c_stop(dev);
-					imx_i2c_module_dis(dev);
-					return -EREMOTEIO;
-				}
-				addr_comp = 1;
+				((msgs[i].flags & I2C_M_RD) !=
+				 (msgs[i - 1].flags & I2C_M_RD))) {
+					if ((msgs[i].flags & I2C_M_NOSTART) == 0) {
+						imx_i2c_repstart(dev, &msgs[i]);
+						/* Wait for the address cycle to complete */
+						if (imx_i2c_wait_for_tc(dev, msgs[i].flags)) {
+							imx_i2c_stop(dev);
+							imx_i2c_module_dis(dev);
+							return -EREMOTEIO;
+						}
+					}
+					addr_comp = 1;
 			}
 		}
 
@@ -414,7 +444,7 @@
  */
 static u32 imx_i2c_func(struct i2c_adapter *adap)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING ;
 }
 
 /*
@@ -505,8 +535,9 @@
 {
 	imx_i2c_device *mxcdev = platform_get_drvdata(pdev);
 
-	if (mxcdev == NULL)
+	if (mxcdev == NULL) {
 		return -1;
+	}
 
 	mxcdev->low_power = false;
 	mxcdev->pdata->init(pdev);
