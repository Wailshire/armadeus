If we're using a direct signal for the data IRQ we still need to ack the
interrupt.

Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/input/touchscreen/wm831x-ts.c b/drivers/input/touchscreen/wm831x-ts.c
index 3617748..833979c 100644
--- a/drivers/input/touchscreen/wm831x-ts.c
+++ b/drivers/input/touchscreen/wm831x-ts.c
@@ -20,6 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/mfd/wm831x/core.h>
+#include <linux/mfd/wm831x/irq.h>
 #include <linux/mfd/wm831x/pdata.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
@@ -146,6 +147,13 @@ static irqreturn_t wm831x_ts_data_irq(int irq, void *irq_data)
 
 	input_sync(wm831x_ts->input_dev);
 
+	/* If we're using a direct signal for the data IRQ we still need
+	 * to ack the interrupt.
+	 */
+	if (wm831x_ts->data_irq)
+		wm831x_set_bits(wm831x, WM831X_INTERRUPT_STATUS_1,
+				WM831X_TCHDATA_EINT, WM831X_TCHDATA_EINT);
+
 	return IRQ_HANDLED;
 }
 
@@ -169,14 +177,15 @@ static int wm831x_ts_input_open(struct input_dev *idev)
 	struct wm831x *wm831x = wm831x_ts->wm831x;
 	u16 ena = 0;
 
+	wm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,
+			WM831X_TCH_ENA, WM831X_TCH_ENA);
+
 	if (wm831x_ts->pressure)
 		ena |= WM831X_TCH_Z_ENA;
 
 	wm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,
-			WM831X_TCH_ENA | WM831X_TCH_X_ENA | WM831X_TCH_Y_ENA |
-			WM831X_TCH_Z_ENA,
-			WM831X_TCH_ENA | WM831X_TCH_X_ENA | WM831X_TCH_Y_ENA |
-			ena);
+			WM831X_TCH_X_ENA | WM831X_TCH_Y_ENA | WM831X_TCH_Z_ENA,
+			WM831X_TCH_X_ENA | WM831X_TCH_Y_ENA | ena);
 
 	return 0;
 }
@@ -217,9 +226,6 @@ static int wm831x_ts_probe(struct platform_device *pdev)
 	 */
 	if (pdata)
 		wm831x_ts->data_irq = pdata->data_irq;
-	else
-		wm831x_ts->data_irq = platform_get_irq_byname(pdev,
-							      "TCHDATA");
 
 	if (pdata && pdata->pressure)
 		wm831x_ts->pressure = true;
@@ -257,18 +263,24 @@ static int wm831x_ts_probe(struct platform_device *pdev)
 		}
 	}
 
-	/* Convert only when pen down */
 	wm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_2,
-			WM831X_TCH_PDONLY, WM831X_TCH_PDONLY);
+			WM831X_TCH_PDONLY, 0);
 
-	/* Default to 192 samples/sec */
+	/* Default to 112 samples/sec */
 	wm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,
-			WM831X_TCH_RATE_MASK, 12);
+			WM831X_TCH_RATE_MASK, 6);
 
-	ret = request_threaded_irq(wm831x_ts->data_irq, NULL,
-				   wm831x_ts_data_irq,
-				   IRQF_ONESHOT, /* Trigger */
-				   "Touchscreen data", wm831x_ts);
+	if (wm831x_ts->data_irq)
+		ret = request_threaded_irq(wm831x_ts->data_irq, NULL,
+					   wm831x_ts_data_irq,
+					   IRQF_ONESHOT, /* Trigger */
+					   "Touchscreen data", wm831x_ts);
+	else
+		ret = request_threaded_irq(platform_get_irq_byname(pdev,
+								   "TCHDATA"),
+					   NULL, wm831x_ts_data_irq,
+					   IRQF_ONESHOT, /* Trigger */
+					   "Touchscreen data", wm831x_ts);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "Failed to request IRQ %d: %d\n",
 			wm831x_ts->data_irq, ret);
@@ -324,7 +336,10 @@ err_dev_alloc:
 err_pd_irq:
 	free_irq(platform_get_irq_byname(pdev, "TCHPD"), wm831x_ts);
 err_data_irq:
-	free_irq(wm831x_ts->data_irq, wm831x_ts);
+	if (wm831x_ts->data_irq)
+		free_irq(wm831x_ts->data_irq, wm831x_ts);
+	else
+		free_irq(platform_get_irq_byname(pdev, "TCHDATA"), wm831x_ts);
 err_alloc:
 	kfree(wm831x_ts);
 
@@ -336,7 +351,10 @@ static int wm831x_ts_remove(struct platform_device *pdev)
 	struct wm831x_ts *wm831x_ts = platform_get_drvdata(pdev);
 
 	free_irq(platform_get_irq_byname(pdev, "TCHPD"), wm831x_ts);
-	free_irq(wm831x_ts->data_irq, wm831x_ts);
+	if (wm831x_ts->data_irq)
+		free_irq(wm831x_ts->data_irq, wm831x_ts);
+	else
+		free_irq(platform_get_irq_byname(pdev, "TCHDATA"), wm831x_ts);
 	input_unregister_device(wm831x_ts->input_dev);
 	kfree(wm831x_ts);
 
