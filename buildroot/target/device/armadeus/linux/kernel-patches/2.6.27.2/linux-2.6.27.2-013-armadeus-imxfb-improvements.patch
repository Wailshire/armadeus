PATCH AUTOMATICALLY GENERATED
DON'T EDIT IT OR YOUR MODIFICATIONS WILL BE LOST
(Take a look at armadeus/target/linux/ directory to know how to generate it)
--- linux-2.6.27.2.original/drivers/video/imxfb.c	
+++ linux-2.6.27.2.mod/drivers/video/imxfb.c	
@@ -42,22 +42,48 @@
  */
 #define DEBUG_VAR 1
 
-#include "imxfb.h"
+struct imxfb_info {
+	struct device		*dev;
 
-static struct imxfb_rgb def_rgb_16 = {
-	.red	= { .offset = 8,  .length = 4, },
-	.green	= { .offset = 4,  .length = 4, },
-	.blue	= { .offset = 0,  .length = 4, },
-	.transp = { .offset = 0,  .length = 0, },
-};
+	u_int			max_bpp;
+	u_int			max_xres;
+	u_int			max_yres;
+
+	/*
+	 * These are the addresses we mapped
+	 * the framebuffer memory region to.
+	 */
+	dma_addr_t		map_dma;
+	u_char *		map_cpu;
+	u_int			map_size;
+
+	u_char *		screen_cpu;
+	dma_addr_t		screen_dma;
+	u_int			palette_size;
+
+	dma_addr_t		dbar1;
+	dma_addr_t		dbar2;
+
+	u_int			pcr;
+	u_int			pwmr;
+	u_int			lscr1;
+	u_int			dmacr;
+	u_int			cmap_inverse:1,
+				cmap_static:1,
+				unused:30;
 
-static struct imxfb_rgb def_rgb_8 = {
-	.red	= { .offset = 0,  .length = 8, },
-	.green	= { .offset = 0,  .length = 8, },
-	.blue	= { .offset = 0,  .length = 8, },
-	.transp = { .offset = 0,  .length = 0, },
+	void (*lcd_power)(int);
+	void (*backlight_power)(int);
 };
 
+#define IMX_NAME	"IMX"
+
+/*
+ * Minimum X and Y resolutions
+ */
+#define MIN_XRES	64
+#define MIN_YRES	64
+
 static int imxfb_activate_var(struct fb_var_screeninfo *var, struct fb_info *info);
 
 static inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)
@@ -152,7 +178,6 @@
 imxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	struct imxfb_info *fbi = info->par;
-	int rgbidx;
 
 	if (var->xres < MIN_XRES)
 		var->xres = MIN_XRES;
@@ -165,27 +190,39 @@
 	var->xres_virtual = max(var->xres_virtual, var->xres);
 	var->yres_virtual = max(var->yres_virtual, var->yres);
 
+	memset(&var->transp, 0, sizeof(var->transp));
+
 	pr_debug("var->bits_per_pixel=%d\n", var->bits_per_pixel);
 	switch (var->bits_per_pixel) {
-	case 16:
-		rgbidx = RGB_16;
-		break;
 	case 8:
-		rgbidx = RGB_8;
+		var->red.length		= var->bits_per_pixel;
+		var->red.offset		= 0;
+		var->green.length	= var->bits_per_pixel;
+		var->green.offset	= 0;
+		var->blue.length	= var->bits_per_pixel;
+		var->blue.offset	= 0;
+		break;
+	case 16:
+		if (fbi->pcr & PCR_TFT) {
+			var->red.length		= 5;
+			var->red.offset		= 11;
+			var->green.length	= 6;
+			var->green.offset	= 5;
+			var->blue.length	= 5;
+			var->blue.offset	= 0;
+		} else {
+			var->red.length		= 4;
+			var->red.offset		= 8;
+			var->green.length	= 4;
+			var->green.offset	= 4;
+			var->blue.length	= 4;
+			var->blue.offset	= 0;
+		}
 		break;
 	default:
-		rgbidx = RGB_16;
+		return -EINVAL;
 	}
 
-	/*
-	 * Copy the RGB parameters for this display
-	 * from the machine specific parameters.
-	 */
-	var->red    = fbi->rgb[rgbidx]->red;
-	var->green  = fbi->rgb[rgbidx]->green;
-	var->blue   = fbi->rgb[rgbidx]->blue;
-	var->transp = fbi->rgb[rgbidx]->transp;
-
 	pr_debug("RGBT length = %d:%d:%d:%d\n",
 		var->red.length, var->green.length, var->blue.length,
 		var->transp.length);
@@ -248,10 +285,11 @@
 
 	LCDC_RMCR = RMCR_LCDC_EN;
 
-	if(fbi->backlight_power)
-		fbi->backlight_power(1);
 	if(fbi->lcd_power)
 		fbi->lcd_power(1);
+    /* enable backlight after LCD */
+	if(fbi->backlight_power)
+		fbi->backlight_power(1);
 }
 
 static void imxfb_disable_controller(struct imxfb_info *fbi)
@@ -312,6 +350,7 @@
 	pr_debug("var: yres=%d vslen=%d um=%d bm=%d\n",
 		var->yres, var->vsync_len,
 		var->upper_margin, var->lower_margin);
+	pr_debug("var: bpp=%d\n", var->bits_per_pixel);
 
 #if DEBUG_VAR
 	if (var->xres < 16        || var->xres > 1024)
@@ -349,10 +388,17 @@
 			  VCR_V_WAIT_2(var->lower_margin);
 
 	LCDC_SIZE	= SIZE_XMAX(var->xres) | SIZE_YMAX(var->yres);
-	LCDC_PCR	= fbi->pcr;
-	LCDC_PWMR	= fbi->pwmr;
-	LCDC_LSCR1	= fbi->lscr1;
-	LCDC_DMACR	= fbi->dmacr;
+    // On TFT LCD i.MXL can support 16, 12, 8, 4bpp with the same hardware interface (12 to 16 bits)
+    // So if userspace app wants a 8bpp screen switch to 8bpp (can save ressources, with SDL for ex)
+    if( (var->bits_per_pixel == 8) && (fbi->pcr & PCR_TFT) )
+    {
+        pr_debug("Switching imxfb to 8bpp\n");
+        LCDC_PCR = (fbi->pcr & (~PCR_BPIX_MASK)) | PCR_BPIX_8 | PCR_END_BYTE_SWAP;
+    }
+    else
+        LCDC_PCR = fbi->pcr;
+   
+    LCDC_VPW    = VPW_VPW(var->xres * var->bits_per_pixel / 8 / 4);
 
 	return 0;
 }
@@ -391,7 +437,26 @@
 	case 1:
 		imx_gpio_mode(PD15_PF_LD0);
 	}
+#ifdef CONFIG_MACH_APF9328
+    /* initialize standard GPIOs */
+	imx_gpio_mode(PD6_PF_LSCLK);
+    imx_gpio_mode(PD14_PF_FLM_VSYNC);
+	imx_gpio_mode(PD13_PF_LP_HSYNC);
+//	imx_gpio_mode(PD12_PF_ACD_OE);	
 
+    /* if != 0 */
+    if( fbi->pwmr ) {
+        imx_gpio_mode(PD11_PF_CONTRAST);
+    }
+    
+    /* sharp display specific */
+	if( fbi->pcr & PCR_SHARP ) {
+   	    imx_gpio_mode(PD10_PF_SPL_SPR);
+	    imx_gpio_mode(PD7_PF_REV);
+	    imx_gpio_mode(PD8_PF_CLS);
+     	imx_gpio_mode(PD9_PF_PS);
+    }
+#else
 	/* initialize GPIOs */
 	imx_gpio_mode(PD6_PF_LSCLK);
 	imx_gpio_mode(PD11_PF_CONTRAST);
@@ -406,6 +471,7 @@
 		imx_gpio_mode(PD9_PF_PS);
 		imx_gpio_mode(PD10_PF_SPL_SPR);
 	}
+#endif //CONFIG_MACH_APF9328
 }
 
 #ifdef CONFIG_PM
@@ -469,9 +535,6 @@
 	info->fbops			= &imxfb_ops;
 	info->flags			= FBINFO_FLAG_DEFAULT;
 
-	fbi->rgb[RGB_16]		= &def_rgb_16;
-	fbi->rgb[RGB_8]			= &def_rgb_8;
-
 	fbi->max_xres			= inf->xres;
 	info->var.xres			= inf->xres;
 	info->var.xres_virtual		= inf->xres;
@@ -596,6 +659,12 @@
 	imxfb_setup_gpio(fbi);
 
 	imxfb_set_par(info);
+	/* JB: The following parameters are only needed once at startup and so 
+		removed from from imxfb_set_par()/imxfb_activate_var() */
+	LCDC_PWMR	= fbi->pwmr;
+	LCDC_LSCR1	= fbi->lscr1;
+	LCDC_DMACR	= fbi->dmacr;
+
 	ret = register_framebuffer(info);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to register framebuffer\n");
PATCH AUTOMATICALLY GENERATED
DON'T EDIT IT OR YOUR MODIFICATIONS WILL BE LOST
(Take a look at armadeus/target/linux/ directory to know how to generate it)
--- linux-2.6.27.2.original/drivers/video/imxfb.h	
+++ linux-2.6.27.2.mod/drivers/video/imxfb.h	
@@ -1,73 +0,0 @@
-/*
- * linux/drivers/video/imxfb.h
- *
- *  Freescale i.MX Frame Buffer device driver
- *
- *  Copyright (C) 2004 S.Hauer, Pengutronix
- *
- *  Copyright (C) 1999 Eric A. Thomas
- *   Based on acornfb.c Copyright (C) Russell King.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive
- * for more details.
- */
-
-/*
- * These are the bitfields for each
- * display depth that we support.
- */
-struct imxfb_rgb {
-	struct fb_bitfield	red;
-	struct fb_bitfield	green;
-	struct fb_bitfield	blue;
-	struct fb_bitfield	transp;
-};
-
-#define RGB_16	(0)
-#define RGB_8	(1)
-#define NR_RGB	2
-
-struct imxfb_info {
-	struct device		*dev;
-	struct imxfb_rgb	*rgb[NR_RGB];
-
-	u_int			max_bpp;
-	u_int			max_xres;
-	u_int			max_yres;
-
-	/*
-	 * These are the addresses we mapped
-	 * the framebuffer memory region to.
-	 */
-	dma_addr_t		map_dma;
-	u_char *		map_cpu;
-	u_int			map_size;
-
-	u_char *		screen_cpu;
-	dma_addr_t		screen_dma;
-	u_int			palette_size;
-
-	dma_addr_t		dbar1;
-	dma_addr_t		dbar2;
-
-	u_int			pcr;
-	u_int			pwmr;
-	u_int			lscr1;
-	u_int			dmacr;
-	u_int			cmap_inverse:1,
-				cmap_static:1,
-				unused:30;
-
-	void (*lcd_power)(int);
-	void (*backlight_power)(int);
-};
-
-#define IMX_NAME	"IMX"
-
-/*
- * Minimum X and Y resolutions
- */
-#define MIN_XRES	64
-#define MIN_YRES	64
-
