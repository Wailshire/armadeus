Makes imx_udc use clock infrastructure to get and activate USB clock.

--- linux-2.6.27.2.org/drivers/usb/gadget/imx_udc.c	2008-11-16 15:46:29.000000000 +0100
+++ linux-2.6.27.2/drivers/usb/gadget/imx_udc.c	2008-11-16 16:33:16.000000000 +0100
@@ -43,6 +43,7 @@
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 
 #include <asm/byteorder.h>
 #include <asm/dma.h>
@@ -75,6 +76,7 @@
 
 static struct imx_udc memory;
 static inline void ep0_idle (const char* label,struct imx_udc *dev);
+static struct clk *imx_udc_clk;
 
 /*
  * Hardware related function
@@ -1854,16 +1856,23 @@
 {
     struct imx_udc *dev = &memory;
     int retval = 0;
-    int i;
+    int i, usb_clk_val;
     
     /* TODO: probe for IMX cpu */
-    
-    if (!imx_get_usb_clk()) {
+	imx_udc_clk = clk_get(&_dev->dev, "usb_clk");
+	if (IS_ERR(imx_udc_clk)) {
+		WARN("Can't get USB clock\n");
+		return -EIO;
+	}
+	usb_clk_val = clk_get_rate(imx_udc_clk);
+	if (!usb_clk_val) {
         WARN("USB clock should be 48MHz, but is not\n");
         return -EIO;
-    } else
-        D2("USB clock %uHz detected\n",imx_get_usb_clk());
+	} else {
+		printk("USB clock %uHz detected\n",usb_clk_val);
+	}
     
+	clk_enable(imx_udc_clk);
     /* 
     * USB general purpose IRQ:  ep0, state changes, dma, etc
     * irq setup after old hardware state is cleaned up
