[linux-2.6.19.2-mx-can-mcp2515-driver.patch]
Index: linux-2.6.19.2/drivers/net/can/Kconfig
===================================================================
--- linux-2.6.19.2.orig/drivers/net/can/Kconfig
+++ linux-2.6.19.2/drivers/net/can/Kconfig
@@ -22,4 +22,12 @@
   a problem with CAN support and want to see more of what is going
   on.
 
+config CAN_MCP251X
+ tristate "Microchip 251x series SPI CAN Controller"
+ depends on CAN && SPI
+ default N
+ ---help---
+  Say Y here if you want support for the Microchip 251x series of
+  SPI based CAN controllers.
+
 endmenu
--- /dev/null
+++ linux-2.6.19.2/drivers/net/can/Makefile	2008-10-06 10:51:17.000000000 +0200
@@ -3,3 +3,8 @@
 #
 
 obj-$(CONFIG_CAN_VCAN)		+= vcan.o
+obj-$(CONFIG_CAN_MCP251X) += mcp251x.o
+
+ifdef CONFIG_CAN_DEBUG_DEVICES
+EXTRA_CFLAGS += -DDEBUG
+endif
Index: linux-2.6.19.2/drivers/net/can/mcp251x.c
===================================================================
--- /dev/null
+++ linux-2.6.19.2/drivers/net/can/mcp251x.c
@@ -0,0 +1,964 @@
+/*
+ * Copyright 2007 Raymarine UK, Ltd. All Rights Reserved.
+ * Written under contract by Katalix Systems, Ltd.
+ */
+
+/*
+ * Based on Microchip MCP251x CAN controller driver written by
+ * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
+ *
+ * Based on CAN bus driver for the CCAN controller written by
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ * Copyright 2007
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * CAN bus driver for Microchip 251x CAN Controller with SPI Interface
+ */
+
+/*
+ * Notes:
+ * This driver interacts with 2 subsystems.
+ * - To the SPI subsystem it is a 'protocol driver'
+ * - To the CAN subsystem it is a 'network driver'
+ *
+ * Because it is an SPI device, it's probing is handled via the SPI device
+ * mechanisms (which are very similar to platform devices).
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/can.h>
+#include <linux/spi/spi.h>
+#include <linux/can/dev.h>
+#include <linux/if_arp.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include "mcp251x.h"
+
+/* SPI interface instruction set */
+#define INSTRUCTION_WRITE 0x02
+#define INSTRUCTION_READ 0x03
+#define INSTRUCTION_BIT_MODIFY 0x05
+#define INSTRUCTION_LOAD_TXB(n) (0x40 + 2 * (n))
+#define INSTRUCTION_READ_RXB(n) (0x90 + 2 * (n))
+#define INSTRUCTION_RESET 0xC0
+
+/* MPC251x registers */
+#define CANSTAT       0x0e
+#define CANCTRL       0x0f
+#define CANCTRL_REQOP_MASK        0xe0
+#define CANCTRL_REQOP_CONF        0x80
+#define CANCTRL_REQOP_LISTEN_ONLY 0x60
+#define CANCTRL_REQOP_LOOPBACK    0x40
+#define CANCTRL_REQOP_SLEEP       0x20
+#define CANCTRL_REQOP_NORMAL      0x00
+#define CANCTRL_OSM               0x08
+#define TEC           0x1c
+#define REC           0x1d
+#define CNF1          0x2a
+#define CNF2          0x29
+#define CNF2_BTLMODE  0x80
+#define CNF3          0x28
+#define CNF3_SOF      0x08
+#define CNF3_WAKFIL   0x04
+#define CNF3_PHSEG2_MASK 0x07
+#define CANINTE       0x2b
+#define CANINTE_MERRE 0x80
+#define CANINTE_WAKIE 0x40
+#define CANINTE_ERRIE 0x20
+#define CANINTE_TX2IE 0x10
+#define CANINTE_TX1IE 0x08
+#define CANINTE_TX0IE 0x04
+#define CANINTE_RX1IE 0x02
+#define CANINTE_RX0IE 0x01
+#define CANINTF       0x2c
+#define CANINTF_MERRF 0x80
+#define CANINTF_WAKIF 0x40
+#define CANINTF_ERRIF 0x20
+#define CANINTF_TX2IF 0x10
+#define CANINTF_TX1IF 0x08
+#define CANINTF_TX0IF 0x04
+#define CANINTF_RX1IF 0x02
+#define CANINTF_RX0IF 0x01
+#define EFLG          0x2d
+#define EFLG_EWARN    0x01
+#define EFLG_RXWAR    0x02
+#define EFLG_TXWAR    0x04
+#define EFLG_RXEP     0x08
+#define EFLG_TXEP     0x10
+#define EFLG_TXBO     0x20
+#define EFLG_RX0OVR   0x40
+#define EFLG_RX1OVR   0x80
+#define TXBCTRL(n)  ((n * 0x10) + 0x30)
+#define TXBCTRL_TXREQ  0x08
+
+/* Buffer size required for the largest SPI transfer (i.e., reading a
+ * frame). */
+#define CAN_FRAME_MAX_DATA_LEN 8
+#define SPI_TRANSFER_BUF_LEN (2*(6 + CAN_FRAME_MAX_DATA_LEN))
+
+#define DEVICE_NAME "mcp251x"
+
+static int enable_dma; /* Enable SPI DMA. Default: 0 (Off) */
+module_param(enable_dma, int, S_IRUGO);
+MODULE_PARM_DESC(enable_dma, "Enable SPI DMA. Default: 0 (Off)");
+
+static int loopback; /* Loopback testing. Default: 0 (Off) */
+module_param(loopback, int, S_IRUGO);
+MODULE_PARM_DESC(loopback, "Loop back frames (for testing). Default: 0 (Off)");
+
+struct mcp251x_priv {
+    struct can_priv    can;
+    struct net_device *net;
+    struct spi_device *spi;
+
+    struct semaphore spi_lock; /* SPI buffer lock */
+    uint8_t *spi_tx_buf;
+    uint8_t *spi_rx_buf;
+    dma_addr_t spi_tx_dma;
+    dma_addr_t spi_rx_dma;
+
+    struct sk_buff *tx_skb;
+    struct work_struct tx_work;
+    struct work_struct irq_work;
+};
+
+
+static uint8_t mcp251x_read_reg(struct spi_device *spi, uint8_t reg)
+{
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct spi_transfer t = {
+        .tx_buf = priv->spi_tx_buf,
+        .rx_buf = priv->spi_rx_buf,
+        .len = 3,
+        .cs_change = 0,
+    };
+    struct spi_message m;
+    uint8_t val = 0;
+    int ret;
+
+    down(&priv->spi_lock);
+
+    priv->spi_tx_buf[0] = INSTRUCTION_READ;
+    priv->spi_tx_buf[1] = reg;
+
+    spi_message_init(&m);
+
+    if (enable_dma) {
+        t.tx_dma = priv->spi_tx_dma;
+        t.rx_dma = priv->spi_rx_dma;
+        m.is_dma_mapped = 1;
+    }
+
+    spi_message_add_tail(&t, &m);
+
+    ret = spi_sync(spi, &m);
+    if (ret < 0) {
+        dev_dbg(&spi->dev, "%s: failed: ret = %d\n", __FUNCTION__, ret);
+    } else
+        val = priv->spi_rx_buf[2];
+
+    up(&priv->spi_lock);
+
+    /*dev_dbg(&spi->dev, "%s: reg 0x%02X val 0x%02X\n", __FUNCTION__, reg, val);*/
+
+    return val;
+}
+
+
+static void mcp251x_write_reg(struct spi_device *spi, uint8_t reg, uint8_t val)
+{
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct spi_transfer t = {
+        .tx_buf = priv->spi_tx_buf,
+        .rx_buf = priv->spi_rx_buf,
+        .len = 3,
+        .cs_change = 0,
+    };
+    struct spi_message m;
+    int ret;
+
+    /*dev_dbg(&spi->dev, "%s: reg 0x%02X val 0x%02X\n", __FUNCTION__, reg, val);*/
+
+    down(&priv->spi_lock);
+
+    priv->spi_tx_buf[0] = INSTRUCTION_WRITE;
+    priv->spi_tx_buf[1] = reg;
+    priv->spi_tx_buf[2] = val;
+
+    spi_message_init(&m);
+
+    if (enable_dma) {
+        t.tx_dma = priv->spi_tx_dma;
+        t.rx_dma = priv->spi_rx_dma;
+        m.is_dma_mapped = 1;
+    }
+
+    spi_message_add_tail(&t, &m);
+
+    ret = spi_sync(spi, &m);
+
+    up(&priv->spi_lock);
+
+    if (ret < 0)
+        dev_dbg(&spi->dev, "%s: failed\n", __FUNCTION__);
+
+    return;
+}
+
+
+static void mcp251x_write_bits(struct spi_device *spi, uint8_t reg,
+                               uint8_t mask, uint8_t val)
+{
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct spi_transfer t = {
+        .tx_buf = priv->spi_tx_buf,
+        .rx_buf = priv->spi_rx_buf,
+        .len = 4,
+        .cs_change = 0,
+    };
+    struct spi_message m;
+    int ret;
+
+    down(&priv->spi_lock);
+
+    priv->spi_tx_buf[0] = INSTRUCTION_BIT_MODIFY;
+    priv->spi_tx_buf[1] = reg;
+    priv->spi_tx_buf[2] = mask;
+    priv->spi_tx_buf[3] = val;
+
+    spi_message_init(&m);
+
+    if (enable_dma) {
+        t.tx_dma = priv->spi_tx_dma;
+        t.rx_dma = priv->spi_rx_dma;
+        m.is_dma_mapped = 1;
+    }
+
+    spi_message_add_tail(&t, &m);
+
+    ret = spi_sync(spi, &m);
+    if (ret < 0)
+        dev_dbg(&spi->dev, "%s: failed\n", __FUNCTION__);
+
+    up(&priv->spi_lock);
+
+    return;
+}
+
+
+static void mcp251x_hw_tx(struct spi_device *spi, struct can_frame *frame,
+                            int tx_buf_idx)
+{
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct spi_transfer t = {
+        .tx_buf = priv->spi_tx_buf,
+        .rx_buf = priv->spi_rx_buf,
+        .cs_change = 0,
+        .len = 6 + CAN_FRAME_MAX_DATA_LEN,
+    };
+    uint8_t *tx_buf = priv->spi_tx_buf;
+    struct spi_message m;
+    int ret;
+    uint32_t sid, eid, exide, rtr;
+
+    dev_dbg(&spi->dev, "%s\n", __FUNCTION__);
+
+    sid = frame->can_id & CAN_SFF_MASK; /* Standard ID */
+    eid = frame->can_id & CAN_EFF_MASK; /* Extended ID */
+    exide = (frame->can_id & CAN_EFF_FLAG) ? 1 : 0; /* Extended ID Enable */
+    rtr = (frame->can_id & CAN_RTR_FLAG) ? 1 : 0; /* Remote transmission */
+
+    mcp251x_read_reg(spi, CANSTAT);
+
+    down(&priv->spi_lock);
+
+    tx_buf[0] = INSTRUCTION_LOAD_TXB(tx_buf_idx);
+    tx_buf[1] = sid >> 3;
+    tx_buf[2] = (sid << 5) | (exide << 3) | (eid >> 16);
+    tx_buf[3] = eid >> 8;
+    tx_buf[4] = eid;
+    tx_buf[5] = (rtr << 6) | frame->can_dlc;
+
+    memcpy(tx_buf + 6, frame->data, frame->can_dlc);
+
+    spi_message_init(&m);
+
+    if (enable_dma) {
+        t.tx_dma = priv->spi_tx_dma;
+        t.rx_dma = priv->spi_rx_dma;
+        m.is_dma_mapped = 1;
+    }
+
+    spi_message_add_tail(&t, &m);
+
+    ret = spi_sync(spi, &m);
+    if (ret < 0)
+        dev_dbg(&spi->dev, "%s: failed: ret = %d\n", __FUNCTION__, ret);
+
+    /* FIXME: Should we exit with an error here? */
+
+    up(&priv->spi_lock);
+
+    mcp251x_write_reg(spi, TXBCTRL(tx_buf_idx), TXBCTRL_TXREQ);
+
+    return;
+}
+
+
+static void mcp251x_hw_rx(struct spi_device *spi, int buf_idx)
+{
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct spi_transfer t = {
+        .tx_buf = priv->spi_tx_buf,
+        .rx_buf = priv->spi_rx_buf,
+        .cs_change = 0,
+        .len = 14,
+    };
+    uint8_t *tx_buf = priv->spi_tx_buf;
+    uint8_t *rx_buf = priv->spi_rx_buf;
+    struct spi_message m;
+    struct sk_buff *skb;
+    struct can_frame *frame;
+    int ret;
+
+    dev_dbg(&spi->dev, "%s\n", __FUNCTION__);
+
+    skb = dev_alloc_skb(sizeof(struct can_frame));
+    if (!skb) {
+        dev_dbg(&spi->dev, "%s: out of memory for Rx'd frame\n", __FUNCTION__);
+        priv->can.net_stats.rx_dropped++;
+        return;
+    }
+    skb->dev = priv->net;
+    frame = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+    down(&priv->spi_lock);
+
+    tx_buf[0] = INSTRUCTION_READ_RXB(buf_idx);
+
+    spi_message_init(&m);
+
+    if (enable_dma) {
+        t.tx_dma = priv->spi_tx_dma;
+        t.rx_dma = priv->spi_rx_dma;
+        m.is_dma_mapped = 1;
+    }
+
+    spi_message_add_tail(&t, &m);
+
+    ret = spi_sync(spi, &m);
+    if (ret < 0)
+        dev_dbg(&spi->dev, "%s: failed: ret = %d\n", __FUNCTION__, ret);
+    /* FIXME: Should we exit with an error here? */
+
+    if ((rx_buf[2] >> 3) & 0x1) {
+        /* Extended ID format */
+        frame->can_id = CAN_EFF_FLAG;
+        frame->can_id |= (rx_buf[2] << 16) | (rx_buf[3] << 8) | rx_buf[4];
+    } else {
+        /* Standard ID format */
+        frame->can_id = (rx_buf[1] << 3) | (rx_buf[2] >> 5);
+    }
+
+    if ((rx_buf[5] >> 6) & 0x1) {
+        /* Remote transmission request */
+        frame->can_id |= CAN_RTR_FLAG;
+    }
+
+    dev_dbg(&spi->dev, "%s: can_id rec'd 0x%08X\n", __FUNCTION__, frame->can_id);
+
+    /* Data length */
+    frame->can_dlc = rx_buf[5] & 0x0f;
+    memcpy(frame->data, rx_buf + 6, CAN_FRAME_MAX_DATA_LEN);
+
+    up(&priv->spi_lock);
+
+    priv->can.net_stats.rx_packets++;
+    priv->can.net_stats.rx_bytes += frame->can_dlc;
+
+    skb->protocol = __constant_htons(ETH_P_CAN);
+    skb->pkt_type = PACKET_BROADCAST;
+    skb->ip_summed = CHECKSUM_UNNECESSARY;
+    netif_rx(skb);
+
+    return;
+}
+
+
+static void mcp251x_hw_sleep(struct spi_device *spi)
+{
+    mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);
+}
+
+static void mcp251x_hw_wakeup(struct spi_device *spi)
+{
+    /* Can only wake up by generating a wake-up interrupt. */
+    mcp251x_write_bits(spi, CANINTE, CANINTE_WAKIE, CANINTE_WAKIE);
+    mcp251x_write_bits(spi, CANINTF, CANINTF_WAKIF, CANINTF_WAKIF);
+}
+
+/* FIXME: modes of operation CONFIG, NORMAL, SLEEP, LISTEN, LOOPBACK */
+static int mcp251x_set_mode(struct net_device *net, uint8_t mode)
+{
+    return 0;
+}
+
+static int mcp251x_hard_start_xmit(struct sk_buff *skb, struct net_device *net)
+{
+    struct mcp251x_priv *priv = netdev_priv(net);
+    struct spi_device *spi = priv->spi;
+    struct can_frame *frame;
+
+    dev_dbg(&spi->dev, "%s\n", __FUNCTION__);
+
+    if (skb->len != sizeof(struct can_frame)) {
+        dev_dbg(&spi->dev, "dropping packet - bad length\n");
+        dev_kfree_skb(skb);
+        priv->can.net_stats.tx_dropped++;
+        return 0;
+    }
+
+    netif_stop_queue(net);
+
+    frame = (struct can_frame *)skb->data;
+
+    priv->tx_skb = skb;
+    schedule_work(&priv->tx_work);
+
+    return 0;
+}
+
+
+static int mcp251x_do_set_mode(struct net_device *net, can_mode_t mode)
+{
+    struct mcp251x_priv *priv = netdev_priv(net);
+    struct spi_device *spi = priv->spi;
+
+    dev_dbg(&spi->dev, "%s (unimplemented)\n", __FUNCTION__);
+
+    switch (mode) {
+        default:
+                return -EOPNOTSUPP;
+    }
+
+    return 0;
+}
+
+
+static int mcp251x_open(struct net_device *net)
+{
+    struct mcp251x_priv *priv = netdev_priv(net);
+    struct spi_device *spi = priv->spi;
+    struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+
+    dev_dbg(&spi->dev, "%s\n", __FUNCTION__);
+
+    if (pdata->transceiver_enable)
+        pdata->transceiver_enable(1);
+
+    mcp251x_hw_wakeup(spi);
+
+    /* Enable interrupts */
+    mcp251x_write_reg(spi, CANINTE,
+                        CANINTE_ERRIE | CANINTE_TX2IE | CANINTE_TX1IE |
+                        CANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE );
+
+    if (loopback) {
+        /* Put device into loopback mode */
+        mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LOOPBACK);
+    } else {
+        /* Put device into normal mode */
+        mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_NORMAL);
+
+        /* Wait for the device to enter normal mode */
+        while (mcp251x_read_reg(spi, CANSTAT) & 0xE0)
+            udelay(10);
+    }
+
+    return 0;
+}
+
+static int mcp251x_stop(struct net_device *net)
+{
+    struct mcp251x_priv *priv = netdev_priv(net);
+    struct spi_device *spi = priv->spi;
+    struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+
+    dev_dbg(&spi->dev, "%s\n", __FUNCTION__);
+
+    /* Disable and clear pending interrupts */
+    mcp251x_write_reg(spi, CANINTE, 0x00);
+    mcp251x_write_reg(spi, CANINTF, 0x00);
+
+    mcp251x_hw_sleep(spi);
+
+    if (pdata->transceiver_enable)
+        pdata->transceiver_enable(0);
+
+    return 0;
+}
+
+static int mcp251x_do_set_bit_time(struct net_device *net, struct can_bittime *bt)
+{
+    struct mcp251x_priv *priv = netdev_priv(net);
+    struct spi_device *spi = priv->spi;
+    uint8_t state;
+
+    dev_dbg(&spi->dev, "%s: BRP = %d, PropSeg = %d, PS1 = %d,"
+                     " PS2 = %d, SJW = %d\n", __FUNCTION__, bt->std.brp,
+    bt->std.prop_seg, bt->std.phase_seg1, bt->std.phase_seg2,
+    bt->std.sjw);
+
+    /* Store original mode and set mode to config */
+    state = mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK;
+    mcp251x_write_bits(spi, CANCTRL, CANCTRL_REQOP_MASK, CANCTRL_REQOP_CONF);
+
+    mcp251x_write_reg(spi, CNF1, ((bt->std.sjw - 1) << 6) | bt->std.brp);
+    mcp251x_write_reg(spi, CNF2, CNF2_BTLMODE | ((bt->std.phase_seg1 - 1) << 3) | 
+                                                (bt->std.prop_seg - 1));
+    mcp251x_write_bits(spi, CNF3, CNF3_PHSEG2_MASK, (bt->std.phase_seg2 - 1));
+
+    /* Restore original state */
+    mcp251x_write_bits(spi, CANCTRL, CANCTRL_REQOP_MASK, state);
+
+    return 0;
+}
+
+
+static int mcp251x_do_get_state(struct net_device *net, can_state_t *state)
+{
+    struct mcp251x_priv *priv = netdev_priv(net);
+    struct spi_device *spi = priv->spi;
+    uint8_t eflag;
+
+    eflag = mcp251x_read_reg(spi, EFLG);
+
+    if (eflag & EFLG_TXBO) {
+        *state = CAN_STATE_BUS_OFF;
+    } else if (eflag & (EFLG_RXEP | EFLG_TXEP)) {
+        *state = CAN_STATE_BUS_PASSIVE;
+    } else if (eflag & EFLG_EWARN) {
+        *state = CAN_STATE_BUS_WARNING;
+    } else {
+        *state = CAN_STATE_ACTIVE;
+    }
+
+    return 0;
+}
+
+
+static void mcp251x_tx_work_handler(struct work_struct *work)
+{
+    struct mcp251x_priv *priv = container_of(work, struct mcp251x_priv, tx_work);
+    struct spi_device *spi = priv->spi;
+    struct can_frame *frame = (struct can_frame *)priv->tx_skb->data;
+
+    dev_dbg(&spi->dev, "%s\n", __FUNCTION__);
+
+    if (frame->can_dlc > CAN_FRAME_MAX_DATA_LEN)
+        frame->can_dlc = CAN_FRAME_MAX_DATA_LEN;
+
+    /* FIXME: use all 3 Tx buffers */
+    mcp251x_hw_tx(spi, frame, 0);
+
+    return;
+}
+
+
+static void mcp251x_irq_work_handler(struct work_struct *work)
+{
+    struct mcp251x_priv *priv = container_of(work, struct mcp251x_priv, irq_work);
+    struct spi_device *spi = priv->spi;
+    struct net_device *net = priv->net;
+    uint8_t intf;
+
+    for (;;) {
+        intf = mcp251x_read_reg(spi, CANINTF);
+        if (intf == 0x00)
+            break;
+
+        dev_dbg(&spi->dev, "interrupt:%s%s%s%s%s%s%s%s\n",
+        (intf & CANINTF_MERRF) ? " MERR":"",
+        (intf & CANINTF_WAKIF) ? " WAK":"",
+        (intf & CANINTF_ERRIF) ? " ERR":"",
+        (intf & CANINTF_TX2IF) ? " TX2":"",
+        (intf & CANINTF_TX1IF) ? " TX1":"",
+        (intf & CANINTF_TX0IF) ? " TX0":"",
+        (intf & CANINTF_RX1IF) ? " RX1":"",
+        (intf & CANINTF_RX0IF) ? " RX0":"");
+
+        if (intf & CANINTF_MERRF) {
+            uint8_t txbnctrl;
+            /* if there are no pending Tx buffers, restart queue */
+            txbnctrl = mcp251x_read_reg(spi, TXBCTRL(0));
+            if (!(txbnctrl & TXBCTRL_TXREQ))
+                netif_wake_queue(net);
+        }
+
+        if (intf & CANINTF_ERRIF) {
+            uint8_t eflg = mcp251x_read_reg(spi, EFLG);
+
+            dev_dbg(&spi->dev, "EFLG = 0x%02x\n", eflg);
+
+            if (eflg & (EFLG_RX0OVR | EFLG_RX1OVR)) {
+                if (eflg & EFLG_RX0OVR)
+                    priv->can.net_stats.rx_over_errors++;
+                if (eflg & EFLG_RX1OVR)
+                    priv->can.net_stats.rx_over_errors++;
+                mcp251x_write_reg(spi, EFLG, 0x00);
+            }
+        }
+
+        if (intf & (CANINTF_TX2IF | CANINTF_TX1IF | CANINTF_TX0IF)) {
+            priv->can.net_stats.tx_packets++;
+            priv->can.net_stats.tx_bytes += ((struct can_frame *)(priv->tx_skb->data))->can_dlc;
+            dev_kfree_skb(priv->tx_skb);
+            netif_wake_queue(net);
+        }
+
+        if (intf & CANINTF_RX0IF)
+            mcp251x_hw_rx(spi, 0);
+
+        if (intf & CANINTF_RX1IF)
+            mcp251x_hw_rx(spi, 1);
+
+        mcp251x_write_bits(spi, CANINTF, intf, 0x00);
+    }
+
+    mcp251x_read_reg(spi, CANSTAT);
+
+    dev_dbg(&spi->dev, "interrupt ended\n");
+
+    return;
+}
+
+
+static irqreturn_t mcp251x_can_isr(int irq, void *dev_id)
+{
+    struct net_device *net = (struct net_device *)dev_id;
+    struct mcp251x_priv *priv = netdev_priv(net);
+    struct spi_device *spi = priv->spi;
+
+    dev_dbg(&spi->dev, "%s\n", __FUNCTION__);
+
+    /* Schedule bottom half */
+    schedule_work(&priv->irq_work);
+
+    return IRQ_HANDLED;
+}
+
+static void mcp251x_hw_reset(struct spi_device *spi)
+{
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    int ret;
+
+    down(&priv->spi_lock);
+
+    priv->spi_tx_buf[0] = INSTRUCTION_RESET;
+
+    ret = spi_write(spi, priv->spi_tx_buf, 1);
+    if (ret < 0)
+        dev_dbg(&spi->dev, "%s: failed: ret = %d\n", __FUNCTION__, ret);
+
+    up(&priv->spi_lock);
+
+    return;
+}
+
+static struct net_device *alloc_mcp251x_netdev(int sizeof_priv)
+{
+    struct net_device *net;
+    struct mcp251x_priv *priv;
+
+    net = alloc_candev(sizeof_priv);
+    if (!net) {
+        return NULL;
+    }
+
+    priv = netdev_priv(net);
+
+    net->open = mcp251x_open;
+    net->stop = mcp251x_stop;
+    net->hard_start_xmit = mcp251x_hard_start_xmit;
+
+    /* Set loopback if module parameter was specified */
+    if (loopback)
+        net->flags |= IFF_LOOPBACK;
+
+    priv->can.baudrate  = 250000;
+    priv->can.do_set_bit_time = mcp251x_do_set_bit_time;
+    priv->can.do_get_state    = mcp251x_do_get_state;
+    priv->can.do_set_mode     = mcp251x_do_set_mode;
+
+    priv->net = net;
+
+    return net;
+}
+
+/* Platform file will specify something like:
+ *
+ *   static struct mcp251x_platform_data mcp251x_info = {
+ * .board_specific_setup = myboard_mcp251x_initfunc,
+ * };
+ *
+ * static struct spi_board_info spi_board_info[] __initdata = {
+ * {
+ * .modalias = "mcp251x",
+ * .platform_data = &mcp251x_info,
+ * .irq = 10,
+ * .max_speed_hz = 8000000,
+ * .bus_num = 1,
+ * .chip_select = 0
+ * },
+ * };
+ *
+ * (See Documentation/spi/spi-summary for more info)
+ */
+
+static int __devinit mcp251x_can_probe(struct spi_device *spi)
+{
+    struct net_device *net;
+    struct mcp251x_priv *priv;
+    struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+    struct can_bittime bit_time;
+    int ret = -ENODEV;
+    printk("mcp251x probe\n");
+    if (!pdata) {
+        /* Platform data is required for osc freq */
+        goto error_out;
+    }
+
+    /* Allocate can/net device */
+    net = alloc_mcp251x_netdev(sizeof(struct mcp251x_priv));
+    if (!net) {
+        ret = -ENOMEM;
+        goto error_alloc;
+    }
+
+    priv = netdev_priv(net);
+    dev_set_drvdata(&spi->dev, priv);
+
+    priv->spi = spi;
+    init_MUTEX(&priv->spi_lock);
+
+    /* Not sure why / 4... mcp251x pre-divides by 2 */
+    priv->can.can_sys_clock = pdata->oscillator_frequency / 4;
+
+    /* If requested, allocate DMA buffers */
+    if (enable_dma) {
+        spi->dev.coherent_dma_mask = DMA_32BIT_MASK;
+
+        /* Minimum coherent DMA allocation is PAGE_SIZE, so allocate
+                   that much and share it between Tx and Rx DMA buffers. */
+        priv->spi_tx_buf = dma_alloc_coherent(&spi->dev,
+        PAGE_SIZE, &priv->spi_tx_dma, GFP_DMA);
+
+        if (priv->spi_tx_buf) {
+            priv->spi_rx_buf = (uint8_t *)(priv->spi_tx_buf +
+                                (PAGE_SIZE / 2));
+            priv->spi_rx_dma = (dma_addr_t)(priv->spi_tx_dma +
+                                (PAGE_SIZE / 2));
+        } else {
+            /* Fall back to non-DMA */
+            enable_dma = 0;
+        }
+    }
+
+    /* Allocate non-DMA buffers */
+    if (!enable_dma) {
+        priv->spi_tx_buf = kmalloc(SPI_TRANSFER_BUF_LEN, GFP_KERNEL);
+        if (!priv->spi_tx_buf) {
+            ret = -ENOMEM;
+            goto error_tx_buf;
+        }
+        priv->spi_rx_buf = kmalloc(SPI_TRANSFER_BUF_LEN, GFP_KERNEL);
+        if (!priv->spi_tx_buf) {
+            ret = -ENOMEM;
+            goto error_rx_buf;
+        }
+    }
+
+    /* Call out to platform specific setup */
+    if (pdata->board_specific_setup)
+        pdata->board_specific_setup(spi);
+
+    /* Call out to platform specific hardware reset */
+    if (pdata->device_reset)
+        pdata->device_reset(spi);
+
+    /* Register IRQ */
+    if (spi->irq >= 0) {
+        if (request_irq(spi->irq, mcp251x_can_isr, IRQF_TRIGGER_FALLING, DEVICE_NAME, net) < 0) {
+            dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
+            goto error_irq;
+        }
+    }
+
+    SET_NETDEV_DEV(net, &spi->dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+    SET_MODULE_OWNER(THIS_MODULE);
+#endif
+
+    INIT_WORK(&priv->tx_work, mcp251x_tx_work_handler);
+    INIT_WORK(&priv->irq_work, mcp251x_irq_work_handler);
+
+    /* Configure the SPI bus */
+    spi->mode = SPI_MODE_2;
+    spi->bits_per_word = 8;
+    spi_setup(spi);
+
+    mcp251x_hw_reset(spi);
+
+    /* Set initial baudrate */
+    ret = can_calc_bit_time(&priv->can, priv->can.baudrate, &bit_time.std);
+    if (ret != 0)
+        dev_err(&spi->dev, "unable to calculate initial baudrate!\n");
+    else {
+        bit_time.type = CAN_BITTIME_STD;
+        ret = priv->can.do_set_bit_time(net, &bit_time);
+        if (ret)
+            dev_err(&spi->dev, "unable to set initial baudrate!\n");
+    }
+
+    mcp251x_hw_sleep(spi);
+
+    ret = register_netdev(net);
+    if (ret >= 0) {
+        dev_info(&spi->dev, "probed%s\n", (loopback) ? " (loopback)" : "");
+        return ret;
+    }
+
+    free_irq(spi->irq, net);
+error_irq:
+    if (!enable_dma)
+        kfree(priv->spi_rx_buf);
+error_rx_buf:
+    if (!enable_dma)
+        kfree(priv->spi_tx_buf);
+error_tx_buf:
+    free_candev(net);
+    if (enable_dma) {
+        dma_free_coherent(&spi->dev, PAGE_SIZE,
+        priv->spi_tx_buf, priv->spi_tx_dma);
+    }
+error_alloc:
+    dev_err(&spi->dev, "probe failed\n");
+error_out:
+    return ret;
+}
+
+static int __devexit mcp251x_can_remove(struct spi_device *spi)
+{
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct net_device *net = priv->net;
+
+    work_clear_pending(&priv->tx_work);
+
+    free_irq(spi->irq, net);
+    work_clear_pending(&priv->irq_work);
+
+    flush_scheduled_work();
+
+    if (enable_dma) {
+        dma_free_coherent(&spi->dev, PAGE_SIZE,
+        priv->spi_tx_buf, priv->spi_tx_dma);
+    } else {
+        kfree(priv->spi_tx_buf);
+        kfree(priv->spi_rx_buf);
+    }
+
+    unregister_netdev(net);
+    free_candev(net);
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int mcp251x_can_suspend(struct spi_device *spi, pm_message_t state)
+{
+    struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct net_device *net = priv->net;
+
+    if (!netif_running(net))
+        return 0;
+
+    netif_device_detach(net);
+
+    mcp251x_hw_sleep(spi);
+    if (pdata->transceiver_enable)
+        pdata->transceiver_enable(0);
+
+    return 0;
+}
+
+static int mcp251x_can_resume(struct spi_device *spi)
+{
+    struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+    struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+    struct net_device *net = priv->net;
+
+    if (!netif_running(net))
+        return 0;
+
+    if (pdata->transceiver_enable)
+        pdata->transceiver_enable(1);
+    mcp251x_hw_wakeup(spi);
+
+    netif_device_attach(net);
+
+    return 0;
+}
+#endif
+
+static struct spi_driver mcp251x_can_driver = {
+    .driver = {
+        .name = DEVICE_NAME,
+        .bus = &spi_bus_type,
+        .owner = THIS_MODULE,
+    },
+
+    .probe = mcp251x_can_probe,
+    .remove = __devexit_p(mcp251x_can_remove),
+#ifdef CONFIG_PM
+    .suspend = mcp251x_can_suspend,
+    .resume = mcp251x_can_resume,
+#endif
+};
+
+static int __init mcp251x_can_init(void)
+{
+    printk("mcp251x init\n");
+    return spi_register_driver(&mcp251x_can_driver);
+}
+
+static void __exit mcp251x_can_exit(void)
+{
+    spi_unregister_driver(&mcp251x_can_driver);
+}
+
+module_init(mcp251x_can_init);
+module_exit(mcp251x_can_exit);
+
+MODULE_AUTHOR("Chris Elston <celston@...>");
+MODULE_DESCRIPTION("Microchip 251x CAN driver");
+MODULE_LICENSE("GPL v2");
Index: linux-2.6.19.2/drivers/net/can/mcp251x.h
===================================================================
--- /dev/null
+++ linux-2.6.19.2/drivers/net/can/mcp251x.h
@@ -0,0 +1,11 @@
+#ifndef __MCP251X_H__
+#define __MCP251X_H__
+
+struct mcp251x_platform_data {
+ unsigned long oscillator_frequency;
+ int (*board_specific_setup)(struct spi_device *spi);
+ int (*device_reset)(struct spi_device *spi);
+ int (*transceiver_enable)(int enable);
+};
+
+#endif /* __MCP251X_H__ */

