diff -urN linux-2.6.12/arch/arm/configs/mx1fs2_defconfig linux-2.6.12-work/arch/arm/configs/mx1fs2_defconfig
--- linux-2.6.12/arch/arm/configs/mx1fs2_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/arch/arm/configs/mx1fs2_defconfig	2005-06-29 09:22:32.000000000 +0200
@@ -0,0 +1,728 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.10-imx-svn
+# Mon Jan  3 19:27:36 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_IMX=y
+# CONFIG_ARCH_H720X is not set
+
+#
+# IMX Implementations
+#
+CONFIG_MACH_MX1FS2=y
+# CONFIG_MACH_SCB9328 is not set
+# CONFIG_ARCH_MX1ADS is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_XIP_KERNEL is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+CONFIG_FPE_FASTFPE=y
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE=""
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+CONFIG_PARPORT=y
+# CONFIG_PARPORT_PC is not set
+# CONFIG_PARPORT_ARC is not set
+# CONFIG_PARPORT_MX1FS2 is not set
+# CONFIG_PARPORT_OTHER is not set
+CONFIG_PARPORT_1284=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_SCB9328 is not set
+CONFIG_MTD_MX1FS2=y
+# CONFIG_MTD_MX1ADS is not set
+# CONFIG_MTD_EDB7312 is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_PARIDE is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=m
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=0
+CONFIG_SERIAL_8250_EXTENDED=y
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_RSA is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_PRINTER=y
+# CONFIG_LP_CONSOLE is not set
+# CONFIG_PPDEV is not set
+# CONFIG_TIPAR is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_RTC=m
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_IMX=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_WBSD is not set
+CONFIG_MMC_IMX=y
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_INFO is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -urN linux-2.6.12/arch/arm/configs/scb9328_defconfig linux-2.6.12-work/arch/arm/configs/scb9328_defconfig
--- linux-2.6.12/arch/arm/configs/scb9328_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/arch/arm/configs/scb9328_defconfig	2005-06-29 09:22:32.000000000 +0200
@@ -0,0 +1,705 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.10-imx-svn
+# Tue Jan  4 11:26:35 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_IMX=y
+# CONFIG_ARCH_H720X is not set
+
+#
+# IMX Implementations
+#
+# CONFIG_MACH_MX1FS2 is not set
+CONFIG_MACH_SCB9328=y
+# CONFIG_ARCH_MX1ADS is not set
+# CONFIG_IMX_SCB9328_EVK9328 is not set
+CONFIG_IMX_SCB9328_EVK9328L=y
+CONFIG_IMX_SCB9328_FLASH_16MB=y
+# CONFIG_IMX_SCB9328_FLASH_32MB is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_XIP_KERNEL is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+CONFIG_FPE_FASTFPE=y
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE=""
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+CONFIG_MTD_SCB9328=y
+# CONFIG_MTD_MX1FS2 is not set
+# CONFIG_MTD_MX1ADS is not set
+# CONFIG_MTD_EDB7312 is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=m
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=0
+CONFIG_SERIAL_8250_EXTENDED=y
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_RSA is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_RTC=m
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+CONFIG_I2C_DEBUG_CORE=y
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_INFO is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -urN linux-2.6.12/arch/arm/kernel/time.c linux-2.6.12-work/arch/arm/kernel/time.c
--- linux-2.6.12/arch/arm/kernel/time.c	2005-06-29 09:26:45.000000000 +0200
+++ linux-2.6.12-work/arch/arm/kernel/time.c	2005-06-29 09:22:32.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/profile.h>
 #include <linux/sysdev.h>
 #include <linux/timer.h>
+#include <linux/pm.h>
 
 #include <asm/hardware.h>
 #include <asm/io.h>
diff -urN linux-2.6.12/arch/arm/kernel/vmlinux.lds.S linux-2.6.12-work/arch/arm/kernel/vmlinux.lds.S
--- linux-2.6.12/arch/arm/kernel/vmlinux.lds.S	2005-06-29 09:26:45.000000000 +0200
+++ linux-2.6.12-work/arch/arm/kernel/vmlinux.lds.S	2005-06-29 09:22:32.000000000 +0200
@@ -161,7 +161,3 @@
 	.stab.indexstr 0 : { *(.stab.indexstr) }
 	.comment 0 : { *(.comment) }
 }
-
-/* those must never be empty */
-ASSERT((__proc_info_end - __proc_info_begin), "missing CPU support")
-ASSERT((__arch_info_end - __arch_info_begin), "no machine record defined")
diff -urN linux-2.6.12/arch/arm/mach-imx/Kconfig linux-2.6.12-work/arch/arm/mach-imx/Kconfig
--- linux-2.6.12/arch/arm/mach-imx/Kconfig	2005-06-29 09:26:45.000000000 +0200
+++ linux-2.6.12-work/arch/arm/mach-imx/Kconfig	2005-06-29 09:22:32.000000000 +0200
@@ -8,4 +8,35 @@
 	help
 	  Say Y here if you are using the Motorola MX1ADS board
 
+config MACH_MX1FS2
+	bool "mx1fs2"
+	depends on ARCH_IMX
+	help
+	  Say Y here if you are using the viasys mx1fs2 board
+
+config MACH_SCB9328
+	bool "scb9328"
+	depends on ARCH_IMX
+	help
+	  Say Y here if you are using the Synertronixx scb9328 board
+
+choice
+       prompt "SCB9328 eval board"
+       depends on MACH_SCB9328
+       default IMX_SCB9328_EVK9328
+
+config IMX_SCB9328_EVK9328
+       bool "use evk9328 eval board"
+       depends on MACH_SCB9328
+       help
+	 Say Y here if you are using the Synertronixx EVK9328 eval board
+
+config IMX_SCB9328_EVK9328L
+       bool "use evk9328l eval board"
+       depends on MACH_SCB9328
+       help
+	 Say Y here if you are using the Synertronixx EVK9328 light eval board
+
+endchoice
+
 endmenu
diff -urN linux-2.6.12/arch/arm/mach-imx/Kconfig.orig linux-2.6.12-work/arch/arm/mach-imx/Kconfig.orig
--- linux-2.6.12/arch/arm/mach-imx/Kconfig.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/Kconfig.orig	2005-06-29 09:22:07.000000000 +0200
@@ -0,0 +1,11 @@
+menu "IMX Implementations"
+	depends on ARCH_IMX
+
+config ARCH_MX1ADS
+	bool "mx1ads"
+	depends on ARCH_IMX
+	select ISA
+	help
+	  Say Y here if you are using the Motorola MX1ADS board
+
+endmenu
diff -urN linux-2.6.12/arch/arm/mach-imx/Makefile linux-2.6.12-work/arch/arm/mach-imx/Makefile
--- linux-2.6.12/arch/arm/mach-imx/Makefile	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/Makefile	2005-06-29 09:22:32.000000000 +0200
@@ -11,9 +11,12 @@
 
 # Specific board support
 obj-$(CONFIG_ARCH_MX1ADS) += mx1ads.o
+obj-$(CONFIG_MACH_MX1FS2) += mx1fs2.o
+obj-$(CONFIG_MACH_SCB9328) += scb9328.o
 
 # Support for blinky lights
 led-y := leds.o
 
 obj-$(CONFIG_LEDS)	+=  $(led-y)
 led-$(CONFIG_ARCH_MX1ADS) += leds-mx1ads.o
+led-$(CONFIG_MACH_SCB9328) += leds-scb9328.o
diff -urN linux-2.6.12/arch/arm/mach-imx/Makefile.boot linux-2.6.12-work/arch/arm/mach-imx/Makefile.boot
--- linux-2.6.12/arch/arm/mach-imx/Makefile.boot	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/Makefile.boot	2005-06-29 09:22:32.000000000 +0200
@@ -1,2 +1,3 @@
     zreladdr-$(CONFIG_ARCH_MX1ADS)	:= 0x08008000
-
+    zreladdr-$(CONFIG_MACH_MX1FS2)	:= 0x08008000
+    zreladdr-$(CONFIG_MACH_SCB9328)	:= 0x08008000
diff -urN linux-2.6.12/arch/arm/mach-imx/leds-scb9328.c linux-2.6.12-work/arch/arm/mach-imx/leds-scb9328.c
--- linux-2.6.12/arch/arm/mach-imx/leds-scb9328.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/leds-scb9328.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+ * linux/arch/arm/mach-imx/leds-scb9328.c
+ *
+ * Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * Original (leds-footbridge.c) by Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include "leds.h"
+
+static int timer_led = 0;
+
+void
+scb9328_leds_event(led_event_t ledevt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch (ledevt) {
+	case led_idle_start:
+		scb9328_ledoff(1);
+		break;
+
+	case led_idle_end:
+		scb9328_ledon(1);
+		break;
+
+	case led_timer:
+		timer_led = !timer_led;
+		if (timer_led)
+			scb9328_ledon(2);
+		else
+			scb9328_ledoff(2);
+		break;
+	default:
+		break;
+	}
+	local_irq_restore(flags);
+}
diff -urN linux-2.6.12/arch/arm/mach-imx/leds.c linux-2.6.12-work/arch/arm/mach-imx/leds.c
--- linux-2.6.12/arch/arm/mach-imx/leds.c	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/leds.c	2005-06-29 09:22:45.000000000 +0200
@@ -21,9 +21,10 @@
 static int __init
 leds_init(void)
 {
-	if (machine_is_mx1ads()) {
+	if (machine_is_mx1ads())
 		leds_event = mx1ads_leds_event;
-	}
+	if (machine_is_scb9328())
+		leds_event = scb9328_leds_event;
 
 	return 0;
 }
diff -urN linux-2.6.12/arch/arm/mach-imx/leds.h linux-2.6.12-work/arch/arm/mach-imx/leds.h
--- linux-2.6.12/arch/arm/mach-imx/leds.h	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/leds.h	2005-06-29 09:22:45.000000000 +0200
@@ -7,3 +7,4 @@
  *
  */
 extern void mx1ads_leds_event(led_event_t evt);
+extern void scb9328_leds_event(led_event_t evt);
diff -urN linux-2.6.12/arch/arm/mach-imx/mx1fs2.c linux-2.6.12-work/arch/arm/mach-imx/mx1fs2.c
--- linux-2.6.12/arch/arm/mach-imx/mx1fs2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/mx1fs2.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,173 @@
+/*
+ * linux/arch/arm/mach-imx/mx1fs2.c
+ *
+ * Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/serial.h>
+#include <asm/arch/imxfb.h>
+//#include <asm/arch/mmc.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include "generic.h"
+
+static struct map_desc mx1fs2_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+	{IMX_CS0_VIRT, IMX_CS0_PHYS, IMX_CS0_SIZE, MT_DEVICE},
+	{IMX_CS1_VIRT, IMX_CS1_PHYS, IMX_CS1_SIZE, MT_DEVICE},
+	{IMX_CS2_VIRT, IMX_CS2_PHYS, IMX_CS2_SIZE, MT_DEVICE},
+	{IMX_CS3_VIRT, IMX_CS3_PHYS, IMX_CS3_SIZE, MT_DEVICE},
+	{IMX_CS4_VIRT, IMX_CS4_PHYS, IMX_CS4_SIZE, MT_DEVICE},
+	{IMX_CS5_VIRT, IMX_CS5_PHYS, IMX_CS5_SIZE, MT_DEVICE},
+	{IMX_FB_VIRT,  IMX_FB_PHYS,  IMX_FB_SIZE,  MT_DEVICE},
+};
+
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+                .membase        = (char *)(MX1FS2_UART1_VIRT),
+                .mapbase        = (unsigned long)(MX1FS2_UART1_PHYS),
+                .irq            = MX1FS2_UART1_IRQ,
+                .flags          = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+                .iotype         = UPIO_MEM,
+                .regshift       = 2,
+                .uartclk        = 3686400 / 16,
+	},
+	{
+                .membase        = (char *)(MX1FS2_UART2_VIRT),
+                .mapbase        = (unsigned long)(MX1FS2_UART2_PHYS),
+                .irq            = MX1FS2_UART2_IRQ,
+                .flags          = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+                .iotype         = UPIO_MEM32,
+                .regshift       = 2,
+                .uartclk        = 3686400 / 16,
+	},
+};
+
+static struct platform_device serial_device = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= serial_platform_data,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&serial_device,
+};
+
+void __init
+mx1fs2_map_io(void)
+{
+	imx_map_io();
+	iotable_init(mx1fs2_io_desc, ARRAY_SIZE(mx1fs2_io_desc));
+}
+
+static void mx1fs2_lcd_power(int on)
+{
+	if(on)
+		DR(3)	|= 0x00001000;
+	else
+		DR(3)	&= ~0x00001000;
+}
+//#define EXPERIMENTAL
+#ifdef EXPERIMENTAL
+static struct imxfb_mach_info mx1fs2_fb_info __initdata = {
+	.pixclock	= 62500, 	.bpp		= 8,
+	.xres		= 320,		.yres		= 240,
+
+	.hsync_len	= 2,		.vsync_len	= 2,
+	.left_margin	= 2,		.upper_margin	= 2,
+	.right_margin	= 2,		.lower_margin	= 2,
+
+	.pcr	= PCR_COLOR | PCR_PBSIZ_8 | PCR_BPIX_8 | PCR_PCD(3) | PCR_END_BYTE_SWAP,
+	.pwmr	= PWMR_SCR0 | PWMR_CC_EN | PWMR_PW(0x70),
+	.lscr1	= 0x04000373, /* reset default */
+
+	.lcd_power = mx1fs2_lcd_power,
+};
+#else
+static struct imxfb_mach_info mx1fs2_fb_info __initdata = {
+	.pixclock	= 62500, 	.bpp		= 16,
+	.xres		= 320,		.yres		= 240,
+
+	.hsync_len	= 2,		.vsync_len	= 2,
+	.left_margin	= 0,		.upper_margin	= 0,
+	.right_margin	= 0,		.lower_margin	= 0,
+
+	.pcr	= PCR_COLOR | PCR_PBSIZ_8 | PCR_BPIX_16 | PCR_PCD(3),
+	.pwmr	= PWMR_SCR0 | PWMR_CC_EN | PWMR_PW(0x70),
+	.lscr1	= 0x04000373, /* reset default */
+
+	.lcd_power = mx1fs2_lcd_power,
+};
+#endif
+
+#if 0
+static int mx1fs2_mmc_card_present(void)
+{
+	return (SSR(3) & (1<<7) ? 0 : 1);
+}
+
+static struct imxmmc_platform_data mx1fs2_mmc_info = {
+	.card_present = mx1fs2_mmc_card_present,
+};
+#endif
+
+static void __init mx1fs2_init(void)
+{
+	printk("%s\n",__FUNCTION__);
+	
+	UFCR(IMX_UART1_BASE) = 0xa81;
+	UFCR(IMX_UART2_BASE) = 0xa81;
+	imx_gpio_mode( 9 | GPIO_IN | GPIO_PORTC );
+	imx_gpio_mode( 10 | GPIO_IN | GPIO_PORTC );
+
+	/* mmc card detect and write protect */
+	imx_gpio_mode( 7 | GPIO_IN | GPIO_PORTD | GPIO_PUEN | GPIO_GPIO );
+	imx_gpio_mode( 10 | GPIO_IN | GPIO_PORTD | GPIO_PUEN | GPIO_GPIO );
+	/* set SD_DAT_3 to 1, otherwise MMC cards go to SPI mode */
+	imx_gpio_mode ( GPIO_PORTB | GPIO_GPIO | GPIO_OUT | 11 );
+	DR(1) |= (1<<11);
+//	imx_set_mmc_info(&mx1fs2_mmc_info);
+
+	set_irq_type( MX1FS2_UART1_IRQ, __IRQT_HIGHLVL);
+	set_irq_type( MX1FS2_UART2_IRQ, __IRQT_HIGHLVL);
+
+	set_imx_fb_info(&mx1fs2_fb_info);
+
+	/* output enable for the LCD display */
+	mx1fs2_lcd_power(0);
+	imx_gpio_mode(GPIO_PORTD | GPIO_OUT | GPIO_GPIO | 12);
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+MACHINE_START(MX1FS2, "viasys mx1fs2")
+	MAINTAINER("Sascha Hauer")
+	BOOT_MEM(0x08000000, 0x00200000, 0xe0200000)
+	BOOT_PARAMS(0x08000100)
+	MAPIO(mx1fs2_map_io)
+	INITIRQ(imx_init_irq)
+	.timer =	&imx_timer,
+	INIT_MACHINE(mx1fs2_init)
+MACHINE_END
diff -urN linux-2.6.12/arch/arm/mach-imx/scb9328.c linux-2.6.12-work/arch/arm/mach-imx/scb9328.c
--- linux-2.6.12/arch/arm/mach-imx/scb9328.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/arch/arm/mach-imx/scb9328.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,318 @@
+/*
+ * linux/arch/arm/mach-imx/scb9328.c
+ *
+ * Copyright (c) 2004 Sascha Hauer <saschahauer@web.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <linux/interrupt.h>
+#include "generic.h"
+#include <linux/serial_8250.h>
+#include <asm/serial.h>
+
+#ifdef CONFIG_DM9000
+#include <linux/dm9000.h>
+#endif
+
+#ifdef CONFIG_USB_ISP116X_HCD
+#include <linux/usb_isp116x.h>
+#endif
+
+#define TYPE_NONE	0
+#define TYPE_EVK9328	1
+#define TYPE_EVK9328L	2
+#define TYPE_EVK9328R2	3
+
+static int board_type = TYPE_NONE;
+
+int scb9328_board(void)
+{
+	return board_type;
+}
+
+static u8 imx_led_shadow = 0;
+
+/* On the evk9328l eval board we have 4 leds and 4 buttons connected
+ * PB21 - PB24 -> led0 - led4
+ * PB25 - PB27 -> Ta0 - Ta3
+ * PA15        -> TA4
+ */
+
+void scb9328_ledon(int x)
+{
+	switch(scb9328_board()) {
+		case TYPE_EVK9328:
+			imx_led_shadow |= (x);
+			*((volatile u8 *)(IMX_CS3_VIRT)) = imx_led_shadow;
+			break;
+		case TYPE_EVK9328L:
+			DR(1) |= (x<<21);
+			break;
+		case TYPE_EVK9328R2:
+			DR(1) &= ~(x<<22);
+			break;
+		default:
+			break;
+	}
+}
+
+void scb9328_ledoff(int x)
+{
+	switch(scb9328_board()) {
+		case TYPE_EVK9328:
+			imx_led_shadow &= ~(x);
+			*((volatile u8 *)(IMX_CS3_VIRT)) = imx_led_shadow;
+			break;
+		case TYPE_EVK9328L:
+			DR(1) &= ~(x<<21);
+			break;
+		case TYPE_EVK9328R2:
+			DR(1) |= (x<<22);
+			break;
+		default:
+			break;
+	}
+}
+
+int scb9328_get_buttons(void)
+{
+	u8 buttons = 0;
+
+	switch(scb9328_board()) {
+		case TYPE_EVK9328:
+			buttons =  *((volatile u8 *)(IMX_CS3_VIRT));
+			printk("%d evk9328", buttons);
+			break;
+		case TYPE_EVK9328L:
+			buttons  = (SSR(1) >> 25) & 0x7;      /* bits 0-2 */
+			buttons |= ((SSR(0) >> 15) & 1) << 3; /* bit 3 */
+			buttons  = ~buttons & 0xf;            /* buttons are inverted */
+			printk("%d evk9328l", buttons);
+			break;
+		case TYPE_EVK9328R2:
+			break;
+		default:
+			break;
+	}
+	return buttons;
+}
+
+void evk9328_init_leds(void)
+{
+	if( scb9328_board() == TYPE_EVK9328L ) {
+		GIUS(1) |= (0xf << 21);
+		DDIR(1) |= (0xf << 21);
+		OCR2(1) |= (0xff) << ((21 - 16)*2);
+		scb9328_ledoff(0xf);
+
+		GIUS(1) |= (0x7 << 25);
+		DDIR(1) &= ~(0x7 << 25);
+		ICONFA2(1) &= ~(0x3f << 18);
+
+		GIUS(0) |= (1<<15);
+		DDIR(0) &= ~(1<<15);
+		ICONFA2(0) &= ~(0x3);
+	}
+	if( scb9328_board() == TYPE_EVK9328R2 ) {
+		/*	GIUS(1) |= (0xf << 21);
+			DDIR(1) |= (0xf << 21);
+			OCR2(1) |= (0xff) << ((21 - 16)*2);
+			*/
+		imx_gpio_mode( 21 | GPIO_OUT );
+		scb9328_ledoff(0xf);
+
+		GIUS(1) |= (0x7 << 25);
+		DDIR(1) &= ~(0x7 << 25);
+		ICONFA2(1) &= ~(0x3f << 18);
+
+		GIUS(0) |= (1<<15);
+		DDIR(0) &= ~(1<<15);
+		ICONFA2(0) &= ~(0x3);
+	}
+}
+
+EXPORT_SYMBOL(scb9328_ledon);
+EXPORT_SYMBOL(scb9328_ledoff);
+EXPORT_SYMBOL(scb9328_get_buttons);
+
+#ifdef CONFIG_USB_ISP116X_HCD
+static struct resource isp116x_resources[] = {
+	{
+		.start= IMX_CS1_PHYS + 0,
+		.end= IMX_CS1_PHYS + 1,
+		.flags= IORESOURCE_MEM,
+	},
+	{
+		.start= IMX_CS1_PHYS + 2,
+		.end= IMX_CS1_PHYS + 3,
+		.flags= IORESOURCE_MEM,
+	},
+	{
+		.start= IRQ_GPIOA(1),
+		.end= IRQ_GPIOA(1),
+		.flags= IORESOURCE_IRQ,
+	},
+};
+
+static struct isp116x_platform_data isp116x_setup = {
+	.sel15Kres = 1,
+	.clknotstop = 1,
+	.no_power_switching = 1,
+};
+
+static struct platform_device isp116x_device = {
+	.name          = "isp116x-hcd",
+	.id            = 0,
+	.num_resources = ARRAY_SIZE(isp116x_resources),
+	.resource      = isp116x_resources,
+	.dev           = {
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data     = &isp116x_setup,
+	}
+
+};
+#endif
+
+#ifdef CONFIG_DM9000
+static struct resource dm9000_resources[] = {
+	[0] = {
+		.start  = SCB9328_ETH_VIRT,
+		.end    = (SCB9328_ETH_VIRT + 4),
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = (SCB9328_ETH_IRQ),
+		.end    = (SCB9328_ETH_IRQ),
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct dm9000_plat_data dm9000_setup = {
+	.flags          = DM9000_PLATF_16BITONLY
+};
+
+static struct platform_device dm9000_device = {
+	.name           = "dm9000",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(dm9000_resources),
+	.resource       = dm9000_resources,
+	.dev            = {
+		.platform_data = &dm9000_setup,
+	}
+};
+#endif
+
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+		.membase        = (char *)(SCB9328_UART1_VIRT),
+		.mapbase        = (unsigned long)(SCB9328_UART1_PHYS),
+		.irq            = SCB9328_UART1_IRQ,
+		.flags          = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype         = UPIO_MEM,
+		.regshift       = 0,
+		.uartclk        = 4*1843200,
+	}, {
+		.membase        = (char *)(SCB9328_UART2_VIRT),
+		.mapbase        = (unsigned long)(SCB9328_UART2_PHYS),
+		.irq            = SCB9328_UART2_IRQ,
+		.flags          = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype         = UPIO_MEM,
+		.regshift       = 0,
+		.uartclk        = 4*1843200,
+	},
+};
+
+static struct platform_device serial_device = {
+	.name                   = "serial8250",
+	.id                     = 0,
+	.dev                    = {
+		.platform_data          = serial_platform_data,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&serial_device,
+#ifdef CONFIG_DM9000
+	&dm9000_device,
+#endif
+#ifdef CONFIG_USB_ISP116X_HCD
+	&isp116x_device,
+#endif
+};
+
+static int __init scb9328_init(void)
+{
+	evk9328_init_leds();
+	UFCR(IMX_UART1_BASE) = 0xa81;
+	UFCR(IMX_UART2_BASE) = 0xa81;
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(scb9328_init);
+
+static int __init scb9328_set_board_type(char *str)
+{
+	if(strncmp( str+1, "evk9328", 8 ) == 0) {
+		printk("evk9328 board found\n");
+		board_type = TYPE_EVK9328;
+	}
+	if(strncmp( str+1, "evk9328light", 8 ) == 0) {
+		printk("evk9328 light board found\n");
+		board_type = TYPE_EVK9328L;
+	}
+	if(strncmp( str+1, "scb9328r2", 8 ) == 0) {
+		printk("scb9328 rev2 implementation\n");
+		board_type = TYPE_EVK9328R2;
+	}
+	return 0;
+}
+__setup("board",scb9328_set_board_type);
+
+static struct map_desc scb9328_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+	{IMX_CS0_VIRT, IMX_CS0_PHYS, IMX_CS0_SIZE, MT_DEVICE},
+	{IMX_CS1_VIRT, IMX_CS1_PHYS, IMX_CS1_SIZE, MT_DEVICE},
+	{IMX_CS2_VIRT, IMX_CS2_PHYS, IMX_CS2_SIZE, MT_DEVICE},
+	{IMX_CS3_VIRT, IMX_CS3_PHYS, IMX_CS3_SIZE, MT_DEVICE},
+	{IMX_CS5_VIRT, IMX_CS5_PHYS, IMX_CS5_SIZE, MT_DEVICE},
+};
+
+static void __init scb9328_init_irq(void)
+{
+	imx_init_irq();
+	set_irq_type(SCB9328_UART1_IRQ, IRQT_LOW);
+#ifdef CONFIG_DM9000
+	set_irq_type(SCB9328_ETH_IRQ, IRQT_LOW);
+#endif
+}
+
+void __init scb9328_map_io(void)
+{
+	imx_map_io();
+	iotable_init(scb9328_io_desc, ARRAY_SIZE(scb9328_io_desc));
+}
+
+MACHINE_START(SCB9328, "Synertronixx scb9328")
+	MAINTAINER("Sascha Hauer and Konstantin Kletschke")
+	BOOT_MEM(0x08000000, 0x00200000, 0xe0200000)
+	BOOT_PARAMS(0x08000100)
+	MAPIO(scb9328_map_io)
+INITIRQ(scb9328_init_irq)
+	.timer	= &imx_timer,
+	MACHINE_END
diff -urN linux-2.6.12/drivers/i2c/busses/Kconfig linux-2.6.12-work/drivers/i2c/busses/Kconfig
--- linux-2.6.12/drivers/i2c/busses/Kconfig	2005-06-29 09:26:46.000000000 +0200
+++ linux-2.6.12-work/drivers/i2c/busses/Kconfig	2005-06-29 09:22:45.000000000 +0200
@@ -486,6 +486,11 @@
 	  
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-pca-isa.
+config I2C_IMX
+        tristate "i2c bus on i.MX"
+        depends on I2C 
+        help
+          i2c implenentation on i.MX motorola prozessors
 
 config I2C_MV64XXX
 	tristate "Marvell mv64xxx I2C Controller"
diff -urN linux-2.6.12/drivers/i2c/busses/Makefile linux-2.6.12-work/drivers/i2c/busses/Makefile
--- linux-2.6.12/drivers/i2c/busses/Makefile	2005-06-29 09:26:46.000000000 +0200
+++ linux-2.6.12-work/drivers/i2c/busses/Makefile	2005-06-29 09:22:45.000000000 +0200
@@ -39,6 +39,7 @@
 obj-$(CONFIG_I2C_VIA)		+= i2c-via.o
 obj-$(CONFIG_I2C_VIAPRO)	+= i2c-viapro.o
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
+obj-$(CONFIG_I2C_IMX)		+= i2c-imx.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
 
diff -urN linux-2.6.12/drivers/i2c/busses/i2c-imx.c linux-2.6.12-work/drivers/i2c/busses/i2c-imx.c
--- linux-2.6.12/drivers/i2c/busses/i2c-imx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/drivers/i2c/busses/i2c-imx.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,698 @@
+/******************************************************************************
+ *	Copyright (C) 2002 Motorola GSG-China
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version 2
+ *	of the License, or (at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+ *      USA.
+ *
+ *  File Name   : i2c-scb9328.c
+ *  Description : Implementation of i2c Adapter/Algorithm Driver
+ *  Author      : Motorola GSG-China
+ *  History     : 2002/2/7 use msgs[]
+ *                2004/3/3 port to linux kernel v2.6.x for IMX
+ *                         adding  cpu- and bus-usage optimization
+ *                         (by T.Koschorrek, http://www.synertronixx.de/)
+ *
+ *  Additional Description (T. Koschorrek) :
+ *  - to enable debug messages just #define DEBUG
+ *  - this module supports cpu- and bus-usage-optimization for ad-converter
+ *    'ads1110' and for serial access timekeeper 'm41t00'
+ *  - support for other chips is NOT yet implemented (you can implement other
+ *    chips by adding two lines in the init-function (i2c_imx_init)
+ *  - this module can be accessed via the i2c-dev interface from user-space
+ *  - access from kernel-space is not supported (add this if you want)
+ *
+ *  - TODO: support for chips (ads1110, m41t00) works fine here but should be
+ *          handled in seperate modules
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ * global stuff
+ ******************************************************************************/
+/*-----------------------------------------------------------------------------
+ * included header files
+ *----------------------------------------------------------------------------*/
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+
+#include <asm/arch/irqs.h>
+#include <asm/arch/hardware.h>
+
+#include <asm/leds.h>
+
+/* #define DEBUG */
+
+/*-----------------------------------------------------------------------------
+ * defines
+ *----------------------------------------------------------------------------*/
+#define DEFAULT_FREQ 	   0x16
+#define I2C_IO_CHANGE_FREQ 0xaa
+#define I2C_IO_GET_STATUS  0xab
+//#define I2C_IMX_TIMEOUT    5000000 
+#define I2C_IMX_TIMEOUT    5000000 // blaschke
+
+/*-----------------------------------------------------------------------------
+ * function declarations
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[ ],
+			int num);
+static int i2c_imx_smbus(struct i2c_adapter * adapter, u16 addr,
+			 unsigned short flags, char read_write, u8 command,
+			 int size, union i2c_smbus_data * data);
+static int i2c_imx_ioctl(struct i2c_adapter * adapter, unsigned int cmd,
+			 unsigned long arg);
+
+/*-----------------------------------------------------------------------------
+ * structs for i2c
+ *----------------------------------------------------------------------------*/
+/* algorithm structure for handling with i2c-bus */
+static struct i2c_algorithm i2c_imx_algorithm = {
+	/* name: */		"IMX I2C algorithm",
+	/* id: */		I2C_ALGO_BIT,
+	/* master_xfer: */	i2c_imx_xfer,
+	/* smbus_xfer: */	i2c_imx_smbus,
+	/* slave_send: */	NULL,
+	/* slave_recv: */	NULL,
+	/* algo_control: */	i2c_imx_ioctl,
+	/* functionality: */	NULL
+};
+
+/* adapter structure to the i2c-bus */
+static struct i2c_adapter i2c_imx_adapter = {
+	/* name: */           .name = "IMX I2C adapter",
+	/* i2c_algorithm: */  .algo = &i2c_imx_algorithm,
+	/* class: */          .class = I2C_CLASS_HWMON,
+	/* ID: */             .id = I2C_ALGO_BIT | I2C_HW_B_SER,
+};
+
+/* imx-registers for i2c */
+struct i2c_imx_i2creg {
+  	volatile u32 iadr;
+	volatile u32 ifdr;
+	volatile u32 i2cr;
+	volatile u32 i2sr;
+	volatile u32 i2dr;
+};
+
+struct i2c_imx_i2cslp {
+	unsigned long jif;
+	unsigned int slp_time;
+};
+
+/*-----------------------------------------------------------------------------
+ * variables
+ *----------------------------------------------------------------------------*/
+static struct i2c_imx_i2creg *i2c_imx_reg = (struct i2c_imx_i2creg *)IMX_I2C_BASE;
+static spinlock_t i2c_imx_irqlock = SPIN_LOCK_UNLOCKED;
+static int i2c_imx_irq_ok;
+static int i2c_imx_i2sr;
+static struct i2c_imx_i2cslp i2c_imx_slp[128];
+
+#ifdef DEBUG
+static int i2c_imx_errs_rxack = 0;
+static int i2c_imx_errs_txcomplete = 0;
+static int i2c_imx_errs_busbusy = 0;
+static int i2c_imx_errs_busgrab = 0;
+#endif
+
+/******************************************************************************
+ * functions (i2c-driver for IMX)
+ ******************************************************************************/
+/*-----------------------------------------------------------------------------
+ * bus grab
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_bus_grab(void)
+{
+	long int i = 0;
+  #define MAX_GRAB_TIMEOUT 2000
+	
+	/* wait for bus grab */
+	/*while(  !((i2c_imx_reg->i2sr & (u32)0x30)));
+	if (i == I2C_IMX_TIMEOUT) 
+	  return 4;
+	return 0;
+	*/
+	//blaschke
+	while(  (!((i2c_imx_reg->i2sr & (u32)0x30))) && (i<MAX_GRAB_TIMEOUT) )
+	{i++;};
+	
+	if (i == MAX_GRAB_TIMEOUT)	
+		return 4;
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * bus busy
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_bus_busy(void)
+{
+	int i = 0;
+
+	
+	/* wait for bus not busy */
+	while((i2c_imx_reg->i2sr & (u32)0x20) && (i < I2C_IMX_TIMEOUT)) i++;
+
+	if (i == I2C_IMX_TIMEOUT) return 3;
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * received ack
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_received_acknowledge(void)
+{
+	if(i2c_imx_i2sr & 0x01)
+	{ 
+	  return 1;
+	}
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * transfer complete
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_transfer_complete(void)
+{
+	int i = 0;
+	unsigned long flags;
+
+	i2c_imx_i2sr = 0x00;
+
+	/* wait for transfer complete interrupt */
+	while ((!(i2c_imx_irq_ok)) && (i < I2C_IMX_TIMEOUT)){
+		spin_lock_irqsave(&i2c_imx_irqlock, flags);
+		i++;
+		spin_unlock_irqrestore(&i2c_imx_irqlock, flags);
+	}
+
+	i2c_imx_irq_ok = 0;
+
+	if (i == I2C_IMX_TIMEOUT) return 3;
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * bus release
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_bus_release(void)
+{	
+	int i=0, dummy;
+	
+	/* if bus busy reset the module process suggested in reference manual
+	   (tahiti) */
+	if (i2c_imx_bus_busy() && (i < I2C_IMX_TIMEOUT)) {
+		i2c_imx_reg->i2cr  =   (u32)0x00;
+		i2c_imx_reg->i2cr |=   (u32)0x0a;
+		dummy = (u8)i2c_imx_reg->i2dr;
+		i2c_imx_reg->i2sr  =   (u32)0x00;
+		i2c_imx_reg->i2cr  =   (u32)0x00;
+		i2c_imx_reg->i2cr &= ~((u32)0x80);
+		i++;
+	}
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * start
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_start(void)
+{
+	int i = 0;
+
+	/* Set Master Mode */
+	i2c_imx_reg->i2cr |= 0x20;
+
+	/* wait while bus grab */
+	//while((i2c_imx_bus_grab()) && (i < I2C_IMX_TIMEOUT)) {// blaschke
+	while((i2c_imx_bus_grab()) && (i < 5)) {	
+		i2c_imx_reg->i2cr &= ~((u32)0x20);	  /* bus stop */
+		i2c_imx_bus_release();
+		if (i2c_imx_bus_busy()) 
+		  return 3;
+		i2c_imx_reg->i2cr |=   (u32)0x80; /* [I2CR:IEN] (I2C Enable) */
+		i2c_imx_reg->i2cr |=   (u32)0x08; /* [I2CR:TXAK] dable txack */
+		i2c_imx_reg->i2cr |=   (u32)0x20;         /* Set Master Mode */
+		i++;
+	}
+
+	if (i == I2C_IMX_TIMEOUT) return 4;
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * write
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_write(int i, int *count, struct i2c_msg *msgs)
+{
+	int err, j;
+
+	/* select slave */
+	i2c_imx_reg->i2dr = msgs->addr << 1;
+	if ((err = i2c_imx_transfer_complete())) return err;
+	if ((err = i2c_imx_received_acknowledge())) return err;
+
+	/* write data */
+	for ( j = 0; j < msgs->len; j ++ )
+	{
+		i2c_imx_reg->i2dr = msgs->buf[j];
+		if ((err = i2c_imx_transfer_complete())) return err;
+	}
+
+	count += msgs->len;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * read
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_read(int i, int *count, struct i2c_msg *msgs)
+{
+	int err, j, dummy;
+
+	/* select slave */
+	i2c_imx_reg->i2dr = ((u32)msgs->addr << 1) | (u32)0x01;
+	if ((err = i2c_imx_transfer_complete())) return err;
+	if ((err = i2c_imx_received_acknowledge())) return err;
+
+	/* setup bus to read data */
+	i2c_imx_reg->i2cr &= ~(u32)0x10;
+	if(msgs->len-1) i2c_imx_reg->i2cr &= ~(u32)0x08;
+	dummy = (u8)i2c_imx_reg->i2dr; /* trigger rec. of next byte */
+	if ((err = i2c_imx_transfer_complete())) return err;
+
+	/* read data */
+	for ( j = 0; j < msgs->len; j ++ )
+	{
+		if(j== (msgs->len - 1)) i2c_imx_reg->i2cr |= 0x08; //blaschke: letztes Byte ohne Ack
+		
+		msgs->buf[j] = (u8)i2c_imx_reg->i2dr;	              
+		if ((err = i2c_imx_transfer_complete())) return err;
+	}
+
+	
+	/*	torsten   for ( j = 0; j < msgs->len; j ++ ){
+		f(j== (msgs->len - 2)) i2c_imx_reg->i2cr |= 0x08;
+		msgs->buf[j] = (u8)i2c_imx_reg->i2dr;	              
+		if ((err = i2c_imx_transfer_complete())) return err;
+	}
+  */
+	
+	count += msgs->len;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * chip_sleep functions: gets timeout-values for supported chips
+ * you have to add own functions to get optimal timeouts for your own chips 
+ * supported chips: m41t00 at 0x68, ads1110 at 0x48
+ *----------------------------------------------------------------------------*/
+/* support for ads1110 at address 0x48 */
+void chip_slp_48(struct i2c_msg *msgs) {
+	switch(msgs->buf[0] & 0x0c) {
+	case 0x00:
+		i2c_imx_slp[0x48-1].slp_time = 1;
+		break;
+	case 0x04:
+		i2c_imx_slp[0x48-1].slp_time = 20;
+		break;
+	case 0x08:
+		i2c_imx_slp[0x48-1].slp_time = 40;
+		break;
+	case 0x0c:
+		i2c_imx_slp[0x48-1].slp_time = 70;
+		break;
+	}
+	return;
+}
+
+/* chip_slp */
+void chip_slp(struct i2c_msg *msgs) {
+	switch(msgs->addr) {
+	case 0x48:
+		chip_slp_48(msgs);
+		return;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * void i2c_imx_isr (s16 irq, void * dev_id, struct pt_regs * reg)
+ * This function deals with the interrupt for the I2C module.
+ *
+ * Parameters:	irq		the interrupt number
+ *              dev_id		device id
+ * 	        reg		processor register	
+ * Return: 	IRQ_HANDLED	the own irq was handled
+ *----------------------------------------------------------------------------*/
+static irqreturn_t i2c_imx_isr (s16 irq, void *dev_id, struct pt_regs * reg)
+{
+	/* safe status register */
+	i2c_imx_i2sr = i2c_imx_reg->i2sr;
+
+	/* if data transfer is complete set ok */
+	if (i2c_imx_i2sr & (u32)0x80)  /* [I2SR:ICF] TX complete */
+		i2c_imx_irq_ok = 1;
+
+	/* clear irq */
+	i2c_imx_reg->i2sr &= ~(u32)0x02; /* clear [I2SR:IIF] Interrupt */
+
+	return IRQ_HANDLED;
+}
+
+/*-----------------------------------------------------------------------------
+ * int i2c_imx_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[ ],
+ * SINT16 num)
+ * This function is responsible for the transfer of the data through the
+ * I2C bus
+ * 
+ * Parameter:   i2c_adap	associated with the related hardware
+ *              msgs[ ] 	the body of the message to be send out
+ *              num		number of message
+ * Return:      Success		Number of message has been transferred
+ *	        Failure		-err (error code)
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[],
+			int num)
+{
+	int i, count=0, err=0;
+
+	//  20041202 Torsten
+	/*unsigned long jif = i2c_imx_slp[msgs[0].addr-1].jif;
+	int slp_time = i2c_imx_slp[msgs[0].addr-1].slp_time;
+	int slp = slp_time * HZ / 1000 - (jiffies - jif);
+	DECLARE_WAIT_QUEUE_HEAD(wait);
+
+
+	// scheduler: sleep while chip not ready
+	// 20041202 Torsten
+	if ((slp > 1) && (msgs[0].flags & I2C_M_RD)) {
+		up(&i2c_adap->bus_lock);
+		sleep_on_timeout(&wait, slp);
+		down(&i2c_adap->bus_lock);
+	}
+*/
+	
+	/* enable the i2c-bus, disable the I2C transmit ACK */
+	if(i2c_imx_bus_busy()) goto ERROR;
+	i2c_imx_reg->i2cr |= (u32)0x80;
+	i2c_imx_reg->i2cr |= (u32)0x08;
+
+	for ( i = 0; i < num; i ++)
+	{
+		/* repeat start else start the bus-transfer */
+		
+		if(i)
+			i2c_imx_reg->i2cr |= (u32)0x04;
+		else
+			if ((err = i2c_imx_start())) 
+			  goto ERROR;
+
+		/* enable interrupt, enable master transmit */
+		i2c_imx_reg->i2cr |= (u32)0x40;
+		i2c_imx_reg->i2cr |= (u32)0x10;
+
+		/* write/read data */
+		if (!(msgs[i].flags & I2C_M_RD )) 
+		{
+			if ((err = i2c_imx_write(i, &count, &msgs[i]))) goto ERROR;
+		} else {
+			if ((err = i2c_imx_read(i, &count, &msgs[i]))) goto ERROR;
+		}
+	}
+
+	
+	/*exit function and error handler */
+	i2c_imx_reg->i2cr &= ~((u32)0x20); /* bus stop */
+	i2c_imx_bus_release();
+	i2c_imx_reg->i2cr &= ~((u32)0x80); /* disable I2C */
+
+	if (!(msgs[0].flags & I2C_M_RD )) 
+	  chip_slp(&msgs[0]);
+	  	
+	i2c_imx_slp[msgs[0].addr-1].jif = jiffies;
+
+	return count;
+ 
+ERROR:
+#ifdef DEBUG
+	printk("ERROR%d\n", err);
+	if(err == 1) i2c_imx_errs_rxack++;
+	if(err == 2) i2c_imx_errs_txcomplete++;
+	if(err == 3) i2c_imx_errs_busbusy++;
+	if(err == 4) i2c_imx_errs_busgrab++;
+
+	printk("Last Update: 2004.12.07: 11:25\n");
+	printk("RX ACK      ERRORs: %d\n", i2c_imx_errs_rxack);
+	printk("TX COMPLETE ERRORs: %d\n", i2c_imx_errs_txcomplete);
+	printk("BUS BUSY    ERRORs: %d\n", i2c_imx_errs_busbusy);
+	printk("BUS GRAB    ERRORs: %d\n", i2c_imx_errs_busgrab);
+
+#endif
+	// blaschke
+	i2c_imx_reg->i2cr &= ~((u32)0x20); /* bus stop */
+	i2c_imx_bus_release();
+	i2c_imx_reg->i2cr &= ~((u32)0x80); /* disable I2C */
+
+	if (!(msgs[0].flags & I2C_M_RD )) 
+	  chip_slp(&msgs[0]);
+	  	
+	i2c_imx_slp[msgs[0].addr-1].jif = jiffies;
+  // blaschke ende
+	
+	/* reset the i2c-bus (hopefully not needed */
+/*	i2c_imx_reg->i2cr = (u32)0x00;
+	GIUS(0) |=  0x00018000;
+	udelay(100);
+  	imx_gpio_mode(PA15_PF_I2C_SDA);
+	mdelay(1);
+
+	i2c_imx_slp[msgs[0].addr-1].jif = jiffies;
+*/
+	return -err;
+}
+
+/*-----------------------------------------------------------------------------
+ * int i2c_smbus_imx_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[ ],
+ * SINT16 num)
+ * This function is responsible for the transfer of the data through the
+ * I2C-bus
+ * 
+ * Parameter : i2c_adap	the structure associated with the related hardware
+ *             msgs[ ]	the body of the message to be send out
+ *             num	number of message
+ * Return :    Success  Number of message has been transferred
+ *	       Failure  -1	
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_smbus(struct i2c_adapter * adapter, u16 addr,
+			 unsigned short flags, char read_write, u8 command,
+			 int size,  union i2c_smbus_data * data)
+{
+	char msgbuf0[34];
+	char msgbuf1[34];
+	int num = read_write == I2C_SMBUS_READ?2:1;
+	struct i2c_msg msg[2] = {
+		{ addr, flags, 1, msgbuf0 }, 
+		{ addr, flags | I2C_M_RD, 10, msgbuf1 }
+	};
+	int i;
+	msgbuf0[0] = command;
+
+	/* select the smbus-command and create the message */
+	switch(size) {
+	case I2C_SMBUS_QUICK:
+		msg[0].len = 0;
+		msg[0].flags=flags|(read_write==I2C_SMBUS_READ)?I2C_M_RD:0;
+		num = 1;
+		break;
+	case I2C_SMBUS_BYTE:
+		if (read_write == I2C_SMBUS_READ) {
+			msg[0].flags = I2C_M_RD | flags;
+			num = 1;
+		}
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		if (read_write == I2C_SMBUS_READ)
+			msg[1].len = 1;
+		else {
+			msg[0].len = 2;
+			msgbuf0[1] = data->byte;
+		}
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		if (read_write == I2C_SMBUS_READ)
+			msg[1].len = 2;
+		else {
+			msg[0].len=3;
+			msgbuf0[1] = data->word & 0xff;
+			msgbuf0[2] = (data->word >> 8) & 0xff;
+		}
+		break;
+	case I2C_SMBUS_PROC_CALL:
+		num = 2;
+		msg[0].len = 3;
+		msg[1].len = 2;
+		msgbuf0[1] = data->word & 0xff;
+		msgbuf0[2] = (data->word >> 8) & 0xff;
+		break;
+	case I2C_SMBUS_BLOCK_DATA:
+		if (read_write == I2C_SMBUS_READ) {
+			return -1;
+		} else {
+			msg[0].len = data->block[0] + 2;
+			if (msg[0].len > 34) {
+				return -1;
+			}
+			for (i = 1; i <= msg[0].len; i++)
+				msgbuf0[i] = data->block[i-1];
+		}
+		break;
+	default:
+		return -1;
+	}
+
+	/* call the bus access routine */
+	if (i2c_imx_xfer(adapter, msg, num) < 0) return -1;
+
+	/* copy the readed bytes to the data-field */
+	if (read_write == I2C_SMBUS_READ)
+		switch(size) {
+		case I2C_SMBUS_BYTE:
+			data->byte = msgbuf0[0];
+			break;
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = msgbuf1[0];
+			break;
+		case I2C_SMBUS_WORD_DATA: 
+		case I2C_SMBUS_PROC_CALL:
+			data->word = msgbuf1[0] | (msgbuf1[1] << 8);
+			break;
+		}
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * int i2c_imx_ioctl(struct i2c_adapter * adapter, unsigned int cmd,
+ * unsigned long arg)
+ * This function control the I2C module itself
+ *
+ * Parameters:	Adapter		the adapter associated to the I2C module
+ * 	        Cmd		IO control command
+ * 	        Arg		argument associated with the command
+ * Return : 	Success		0
+ *----------------------------------------------------------------------------*/
+static int i2c_imx_ioctl(struct i2c_adapter * adapter, unsigned int cmd,
+			 unsigned long arg)
+{
+	switch( cmd ) {
+	case I2C_IO_CHANGE_FREQ:
+		i2c_imx_reg->ifdr = (u32)(arg & 0x003f);
+		break;
+	case I2C_IO_GET_STATUS:
+		arg = i2c_imx_reg->i2sr;
+ 		break;
+	}
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * int __init i2c_imx_init(void)
+ * initializes the I2C module in the DBIMX, and registers itself to the 
+ * Linux I2C system
+ *
+ * Parameters: None
+ * Return:      0: indicates SUCCESS
+ *             -1: indicates FAILURE
+ *----------------------------------------------------------------------------*/
+static int __init i2c_imx_init(void)
+{
+	/* Pin Configuration for I2C:
+	 * 2 Pins are available for the I2C-Module. These Pins are multiplexed
+	 * with other functions on the device and must be configured for SPI-
+	 * Operation.
+	 * The Data Direction Bits in the GPIO Data Direction Register Port A
+	 * must be set for Output.
+	 * The Function Bits in the GPIO In Use Register Port A must be set
+	 * for Multiplexed.
+	 * Data Direction (DDIR): Output
+	 * GPIO-Function (GIUS):  SPI-Operation
+	 * GPR, PUEN:             for Interrupt operations */
+  	imx_gpio_mode(PA15_PF_I2C_SDA);
+  	imx_gpio_mode(PA16_PF_I2C_SCL);
+
+	/* install the I2C_IMX ISR to the Linux Kernel */
+	if(request_irq(I2C_INT, (void *)i2c_imx_isr, SA_INTERRUPT,
+		       "I2C_IMX", "i2c_bus")<0) return -1;
+  
+	/* Set clock Freq. */
+	i2c_imx_reg->ifdr = (u32)DEFAULT_FREQ;
+  
+	/* add the I2C adapter/algorithm driver to the linux kernel */
+	if (i2c_add_adapter(&i2c_imx_adapter)) return -1;
+#ifdef DEBUG
+	printk("I2C-Adapter %d installed. use device with Minor %d\n",
+	       i2c_imx_adapter.nr, i2c_imx_adapter.nr);
+#endif
+
+	/* define ms to sleep after read from chip*/
+	i2c_imx_slp[0x48-1].jif = jiffies;
+	i2c_imx_slp[0x48-1].slp_time = 1;
+	i2c_imx_slp[0x68-1].jif = jiffies;
+	i2c_imx_slp[0x68-1].slp_time = 200;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * void __exit i2c_imx_cleanup(void)
+ * This routine is called when the driver is unloaded
+ *
+ * Parameters: None
+ * Return:     None
+ *----------------------------------------------------------------------------*/
+static void __exit i2c_imx_cleanup(void)
+{
+#ifdef DEBUG
+	printk("RX ACK      ERRORs: %d\n", i2c_imx_errs_rxack);
+	printk("TX COMPLETE ERRORs: %d\n", i2c_imx_errs_txcomplete);
+	printk("BUS BUSY    ERRORs: %d\n", i2c_imx_errs_busbusy);
+	printk("BUS GRAB    ERRORs: %d\n", i2c_imx_errs_busgrab);
+#endif
+
+	/* unset IEN[I2CR:7] (I2C Disable) */
+	i2c_imx_reg->i2cr = (u32)0x00;
+  
+	/* Free IRQ */
+	free_irq (I2C_INT, "i2c_bus");
+  
+	/* Delete Adapter from Kernel */  
+	i2c_del_adapter(&i2c_imx_adapter);	
+}
+
+/******************************************************************************
+ * Module Init/Exit
+ ******************************************************************************/
+MODULE_AUTHOR("GSG China");
+MODULE_DESCRIPTION("I2C Adapter/Algorithm driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_imx_init);
+module_exit(i2c_imx_cleanup);
diff -urN linux-2.6.12/drivers/mmc/Kconfig linux-2.6.12-work/drivers/mmc/Kconfig
--- linux-2.6.12/drivers/mmc/Kconfig	2005-06-29 09:26:46.000000000 +0200
+++ linux-2.6.12-work/drivers/mmc/Kconfig	2005-06-29 09:22:45.000000000 +0200
@@ -60,4 +60,14 @@
 
 	  If unsure, say N.
 
+config MMC_IMX
+	tristate "Motorola i.MX Multimedia Card Interface support"
+	depends on ARCH_IMX && MMC
+	help
+	  This selects the Motorola i.MX Multimedia card Interface.
+	  If you have a i.MX platform with a Multimedia Card slot,
+	  say Y or M here.
+
+	  If unsure, say N.
+
 endmenu
diff -urN linux-2.6.12/drivers/mmc/Makefile linux-2.6.12-work/drivers/mmc/Makefile
--- linux-2.6.12/drivers/mmc/Makefile	2005-03-02 08:38:12.000000000 +0100
+++ linux-2.6.12-work/drivers/mmc/Makefile	2005-06-29 09:22:45.000000000 +0200
@@ -17,6 +17,7 @@
 #
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
+obj-$(CONFIG_MMC_IMX)		+= imxmmc.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 
 mmc_core-y := mmc.o mmc_queue.o mmc_sysfs.o
diff -urN linux-2.6.12/drivers/mmc/imxmmc.c linux-2.6.12-work/drivers/mmc/imxmmc.c
--- linux-2.6.12/drivers/mmc/imxmmc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/drivers/mmc/imxmmc.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,590 @@
+/*
+ *  linux/drivers/mmc/imxmmc.c - Motorola i.MX MMCI driver
+ *
+ *  Copyright (C) 2004 Sascha Hauer, Pengutronix <sascha@saschahauer.de>
+ *
+ *  derived from pxamci.c by Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/protocol.h>
+
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/sizes.h>
+#include <asm/arch/mmc.h>
+
+#include "imxmmc.h"
+
+#define DRIVER_NAME "IMXMMC"
+
+#ifdef CONFIG_MMC_DEBUG
+#define DBG(x...)	printk(x)
+#else
+#define DBG(x...)	do { } while (0)
+#endif
+
+struct imxmci_host {
+	struct mmc_host		*mmc;
+	spinlock_t		lock;
+	struct resource		*res;
+	int			irq;
+	int			dma;
+	unsigned int		clkrt;
+	unsigned int		cmdat;
+	unsigned int		imask;
+	unsigned int		power_mode;
+	unsigned int		present;
+	struct imxmmc_platform_data *pdata;
+
+	struct mmc_request	*req;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+
+	struct timer_list	timer;
+
+	dma_addr_t		dma_buf;
+	unsigned int		dma_size;
+	unsigned int		dma_dir;
+};
+
+static void imxmci_stop_clock(struct imxmci_host *host)
+{
+	int i;
+	while(1) {
+	        MMC_STR_STP_CLK |= STR_STP_CLK_STOP_CLK;
+		i = 0;
+		while( (MMC_STATUS & STATUS_CARD_BUS_CLK_RUN) && (i++ < 100));
+
+		if ( !(MMC_STATUS & STATUS_CARD_BUS_CLK_RUN) )
+			break;
+	}
+}
+
+static void imxmci_start_clock(struct imxmci_host *host)
+{
+	int i;
+	while(1) {
+	        MMC_STR_STP_CLK |= STR_STP_CLK_START_CLK;
+		i = 0;
+		while( !(MMC_STATUS & STATUS_CARD_BUS_CLK_RUN) && (i++ < 100));
+
+		if ( MMC_STATUS & STATUS_CARD_BUS_CLK_RUN )
+			break;
+	}
+}
+
+static void imxmci_softreset(void)
+{
+	/* reset sequence */
+	MMC_STR_STP_CLK = 0x8;
+	MMC_STR_STP_CLK = 0xD;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+
+	MMC_RES_TO = 0xff;
+	MMC_BLK_LEN = 512;
+	MMC_NOB = 1;
+}
+
+static void imxmci_setup_data(struct imxmci_host *host, struct mmc_data *data)
+{
+	unsigned int nob = data->blocks;
+	unsigned int ccr = CCR_REN;
+
+	if (data->flags & MMC_DATA_STREAM)
+		nob = 0xffff;
+
+	host->data = data;
+
+	MMC_NOB = nob;
+	MMC_BLK_LEN = 1 << data->blksz_bits;
+
+	if (data->flags & MMC_DATA_READ) {
+		host->dma_dir = DMA_FROM_DEVICE;
+		ccr |= CCR_SMOD_FIFO | CCR_SSIZ_16 | CCR_DSIZ_32;
+	} else {
+		host->dma_dir = DMA_TO_DEVICE;
+		ccr |= CCR_DMOD_FIFO | CCR_SSIZ_32 | CCR_DSIZ_16;
+	}
+
+	host->dma_size = data->blocks << data->blksz_bits;
+	host->dma_buf = dma_map_single(mmc_dev(host->mmc), data->req->buffer,
+				       host->dma_size, host->dma_dir);
+
+	if (data->flags & MMC_DATA_READ) {
+		SAR(host->dma) = host->res->start + MMC_BUFFER_ACCESS_OFS;
+		DAR(host->dma) = host->dma_buf;
+	} else {
+		SAR(host->dma) = host->dma_buf;
+		DAR(host->dma) = host->res->start + MMC_BUFFER_ACCESS_OFS;
+	}
+
+	BLR(host->dma) = 0x08;
+
+	CNTR(host->dma) = host->dma_size;
+	CCR(host->dma) = ccr;
+	RSSR(host->dma) = DMA_REQ_SDHC;
+
+	/* finally start DMA engine */
+	CCR(host->dma) |= CCR_CEN;
+}
+
+static void imxmci_start_cmd(struct imxmci_host *host, struct mmc_command *cmd, unsigned int cmdat)
+{
+	WARN_ON(host->cmd != NULL);
+	host->cmd = cmd;
+
+	if (cmd->flags & MMC_RSP_BUSY)
+		cmdat |= CMD_DAT_CONT_BUSY;
+
+	switch (cmd->flags & (MMC_RSP_MASK | MMC_RSP_CRC)) {
+	case MMC_RSP_SHORT | MMC_RSP_CRC:
+		cmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R1;
+		break;
+	case MMC_RSP_SHORT:
+		cmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R3;
+		break;
+	case MMC_RSP_LONG | MMC_RSP_CRC:
+		cmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R2;
+		break;
+	default:
+		break;
+	}
+
+	if ( cmd->opcode == MMC_GO_IDLE_STATE )
+		cmdat |= CMD_DAT_CONT_INIT; /* This command needs init */
+
+	MMC_CMD = cmd->opcode;
+	MMC_ARGH = cmd->arg >> 16;
+	MMC_ARGL = cmd->arg & 0xffff;
+	MMC_CMD_DAT_CONT = cmdat;
+
+	imxmci_start_clock(host);
+}
+
+static void imxmci_finish_request(struct imxmci_host *host, struct mmc_request *req)
+{
+	host->req = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+	mmc_request_done(host->mmc, req);
+}
+
+static int imxmci_cmd_done(struct imxmci_host *host, unsigned int stat)
+{
+	struct mmc_command *cmd = host->cmd;
+	int i;
+	u32 a,b,c;
+
+	if (!cmd)
+		return 0;
+
+	host->cmd = NULL;
+
+	if (stat & STATUS_TIME_OUT_RESP) {
+		DBG("%s: CMD TIMEOUT\n",DRIVER_NAME);
+		cmd->error = MMC_ERR_TIMEOUT;
+	} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {
+		DBG("%s: cmd crc error\n",DRIVER_NAME);
+		cmd->error = MMC_ERR_BADCRC;
+	}
+
+	switch (cmd->flags & (MMC_RSP_MASK | MMC_RSP_CRC)) {
+	case MMC_RSP_SHORT | MMC_RSP_CRC:
+		a = MMC_RES_FIFO & 0xffff;
+		b = MMC_RES_FIFO & 0xffff;
+		c = MMC_RES_FIFO & 0xffff;
+		cmd->resp[0] = a<<24 | b<<8 | c>>8;
+		break;
+	case MMC_RSP_SHORT:
+		a = MMC_RES_FIFO & 0xffff;
+		b = MMC_RES_FIFO & 0xffff;
+		c = MMC_RES_FIFO & 0xffff;
+		cmd->resp[0] = a<<24 | b<<8 | c>>8;
+		break;
+	case MMC_RSP_LONG | MMC_RSP_CRC:
+		for (i = 0; i < 4; i++) {
+			u32 a = MMC_RES_FIFO & 0xffff;
+			u32 b = MMC_RES_FIFO & 0xffff;
+			cmd->resp[i] = a<<16 | b;
+		}
+		break;
+	default:
+		break;
+	}
+
+	DBG("%s: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",DRIVER_NAME,cmd->resp[0],
+	        cmd->resp[1],cmd->resp[2],cmd->resp[3]);
+
+
+	if (host->data && cmd->error == MMC_ERR_NONE) {
+		/* nothing */
+	} else {
+		imxmci_stop_clock(host);
+		imxmci_finish_request(host, host->req);
+	}
+
+	return 1;
+}
+
+static int imxmci_data_done(struct imxmci_host *host, unsigned int stat)
+{
+	struct mmc_data *data = host->data;
+
+	CCR(host->dma) &= ~CCR_CEN;
+
+	if (!data)
+		return 0;
+
+	dma_unmap_single(mmc_dev(host->mmc), host->dma_buf, host->dma_size,
+			 host->dma_dir);
+
+	if ( MMC_STATUS & STATUS_ERR_MASK ) {
+		DBG("%s: request failed. status: 0x%08x\n",DRIVER_NAME,MMC_STATUS);
+	}
+
+	host->data = NULL;
+	data->bytes_xfered = host->dma_size;
+
+	if (host->req->stop && data->error == MMC_ERR_NONE) {
+		imxmci_stop_clock(host);
+		imxmci_start_cmd(host, host->req->stop, 0);
+	} else {
+		imxmci_finish_request(host, host->req);
+	}
+
+	return 1;
+}
+
+static irqreturn_t imxmci_irq(int irq, void *devid, struct pt_regs *regs)
+{
+	struct imxmci_host *host = devid;
+	unsigned int status = 0;
+	int handled = 0,timeout = 10000;
+
+	spin_lock(host->lock);
+
+	status = MMC_STATUS;
+
+	while( !handled && --timeout ) {
+		if(status & STATUS_END_CMD_RESP) {
+			imxmci_cmd_done(host, status);
+			handled = 1;
+		}
+		status = MMC_STATUS;
+	}
+
+	if(!timeout) {
+		printk("%s: fake interrupt\n",DRIVER_NAME);
+		handled = 1;
+	}
+
+	MMC_INT_MASK = host->imask;
+
+	spin_unlock(host->lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+static void imxmci_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct imxmci_host *host = mmc_priv(mmc);
+	unsigned int cmdat;
+
+	WARN_ON(host->req != NULL);
+
+	host->req = req;
+
+	cmdat = 0;
+
+	if (req->data) {
+		imxmci_setup_data(host, req->data);
+
+		cmdat |= CMD_DAT_CONT_DATA_ENABLE;
+
+		if (req->data->flags & MMC_DATA_WRITE)
+			cmdat |= CMD_DAT_CONT_WRITE;
+
+		if (req->data->flags & MMC_DATA_STREAM) {
+			cmdat |= CMD_DAT_CONT_STREAM_BLOCK;
+		}
+	}
+
+	imxmci_start_cmd(host, req->cmd, cmdat);
+}
+
+#define CLK_RATE 19200000
+
+static void imxmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct imxmci_host *host = mmc_priv(mmc);
+	int prescaler;
+
+	DBG("%s: clock %u power %u vdd %u.%02u\n", DRIVER_NAME,
+	    ios->clock, ios->power_mode, ios->vdd / 100,
+	    ios->vdd % 100);
+
+	if ( ios->clock ) {
+		prescaler = 5; /* 96MHz / 5 = 19.2 MHz */
+		unsigned int clk;
+
+		for(clk=0; clk<8; clk++) {
+			int x;
+			x = CLK_RATE / (1<<clk);
+			if( x <= ios->clock)
+				break;
+		}
+
+		MMC_STR_STP_CLK |= STR_STP_CLK_ENABLE; /* enable controller */
+
+		imxmci_stop_clock(host);
+		MMC_CLK_RATE = (prescaler<<3) | clk;
+		imxmci_start_clock(host);
+
+		DBG("%s:MMC_CLK_RATE: 0x%08x\n",DRIVER_NAME,MMC_CLK_RATE);
+	} else {
+		imxmci_stop_clock(host);
+	}
+}
+
+static struct mmc_host_ops imxmci_ops = {
+	.request	= imxmci_request,
+	.set_ios	= imxmci_set_ios,
+};
+
+static struct resource *platform_device_resource(struct platform_device *dev, unsigned int mask, int nr)
+{
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++)
+		if (dev->resource[i].flags == mask && nr-- == 0)
+			return &dev->resource[i];
+	return NULL;
+}
+
+static int platform_device_irq(struct platform_device *dev, int nr)
+{
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++)
+		if (dev->resource[i].flags == IORESOURCE_IRQ && nr-- == 0)
+			return dev->resource[i].start;
+	return NO_IRQ;
+}
+
+static void imxmci_dma_irq(int dma, void *devid, struct pt_regs *regs)
+{
+	struct imxmci_host *host = devid;
+	u32 status;
+
+	do {
+		status = MMC_STATUS;
+	} while( !(status & STATUS_DATA_TRANS_DONE));
+
+	imxmci_data_done(host, status);
+	MMC_INT_MASK = host->imask;
+}
+
+static void imxmci_check_status(unsigned long data)
+{
+	struct imxmci_host *host = (struct imxmci_host *)data;
+
+	if( host->pdata->card_present() != host->present ) {
+		host->present ^= 1;
+		printk(KERN_INFO "%s: card %s\n",DRIVER_NAME,
+		      host->present ? "inserted" : "removed");
+		mmc_detect_change(host->mmc);
+	}
+	mod_timer(&host->timer, jiffies + (HZ>>1));
+}
+
+static int imxmci_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mmc_host *mmc;
+	struct imxmci_host *host = NULL;
+	struct resource *r;
+	int ret = 0, irq;
+
+	printk("i.MX mmc driver\n");
+
+	r = platform_device_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_device_irq(pdev, 0);
+	if (!r || irq == NO_IRQ)
+		return -ENXIO;
+
+	r = request_mem_region(r->start, 0x100, "IMXMCI");
+	if (!r)
+		return -EBUSY;
+
+	mmc = mmc_alloc_host(sizeof(struct imxmci_host), dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mmc->ops = &imxmci_ops;
+	mmc->f_min = 150000;
+	mmc->f_max = CLK_RATE;
+	mmc->ocr_avail = MMC_VDD_32_33;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->dma = -1;
+	host->pdata = pdev->dev.platform_data;
+
+	spin_lock_init(&host->lock);
+	host->res = r;
+	host->irq = irq;
+
+	imx_gpio_mode(PB8_PF_SD_DAT0);
+	imx_gpio_mode(PB9_PF_SD_DAT1);
+	imx_gpio_mode(PB10_PF_SD_DAT2);
+	imx_gpio_mode(PB12_PF_SD_CLK);
+	imx_gpio_mode(PB13_PF_SD_CMD);
+
+	imxmci_softreset();
+
+	if ( MMC_REV_NO != 0x390 ) {
+		printk("%s: wrong rev.no. 0x%08x. aborting.\n",
+		                                    DRIVER_NAME,MMC_REV_NO);
+		goto out;
+	}
+
+	MMC_READ_TO = 0x2db4; /* recommended in data sheet */
+
+	host->imask = INT_MASK_BUF_READY | INT_MASK_DATA_TRAN |
+	              INT_MASK_WRITE_OP_DONE | INT_MASK_SDIO |
+		      INT_MASK_AUTO_CARD_DETECT;
+	MMC_INT_MASK = host->imask;
+
+
+	host->dma = imx_request_dma(DRIVER_NAME, DMA_PRIO_LOW, imxmci_dma_irq, NULL, host);
+	if (host->dma < 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = request_irq(host->irq, imxmci_irq, 0, DRIVER_NAME, host);
+	if (ret)
+		goto out;
+
+	host->present = host->pdata->card_present();
+	init_timer(&host->timer);
+	host->timer.data = (unsigned long)host;
+	host->timer.function = imxmci_check_status;
+	add_timer(&host->timer);
+	mod_timer(&host->timer, jiffies + (HZ>>1));
+
+	dev_set_drvdata(dev, mmc);
+
+	mmc_add_host(mmc);
+
+	return 0;
+
+out:
+	if (host) {
+		if (host->dma >= 0)
+			imx_free_dma(host->dma);
+	}
+	if (mmc)
+		mmc_free_host(mmc);
+	release_resource(r);
+	return ret;
+}
+
+static int imxmci_remove(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	if (mmc) {
+		struct imxmci_host *host = mmc_priv(mmc);
+
+		del_timer_sync(&host->timer);
+		mmc_remove_host(mmc);
+
+		free_irq(host->irq, host);
+		imx_free_dma(host->dma);
+
+		release_resource(host->res);
+
+		mmc_free_host(mmc);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int imxmci_suspend(struct device *dev, u32 state, u32 level)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (mmc && level == SUSPEND_DISABLE)
+		ret = mmc_suspend_host(mmc, state);
+
+	return ret;
+}
+
+static int imxmci_resume(struct device *dev, u32 level)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (mmc && level == RESUME_ENABLE)
+		ret = mmc_resume_host(mmc);
+
+	return ret;
+}
+#else
+#define imxmci_suspend  NULL
+#define imxmci_resume   NULL
+#endif /* CONFIG_PM */
+
+static struct device_driver imxmci_driver = {
+	.name		= "imx-mmc",
+	.bus		= &platform_bus_type,
+	.probe		= imxmci_probe,
+	.remove		= imxmci_remove,
+	.suspend	= imxmci_suspend,
+	.resume		= imxmci_resume,
+};
+
+static int __init imxmci_init(void)
+{
+	return driver_register(&imxmci_driver);
+}
+
+static void __exit imxmci_exit(void)
+{
+	driver_unregister(&imxmci_driver);
+}
+
+module_init(imxmci_init);
+module_exit(imxmci_exit);
+
+MODULE_DESCRIPTION("i.MX Multimedia Card Interface Driver");
+MODULE_AUTHOR("Sascha Hauer, Pengutronix");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.12/drivers/mmc/imxmmc.h linux-2.6.12-work/drivers/mmc/imxmmc.h
--- linux-2.6.12/drivers/mmc/imxmmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/drivers/mmc/imxmmc.h	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,67 @@
+
+# define __REG16(x)	(*((volatile u16 *)IO_ADDRESS(x)))
+
+#define MMC_STR_STP_CLK  __REG16(IMX_MMC_BASE + 0x00)
+#define MMC_STATUS       __REG16(IMX_MMC_BASE + 0x04)
+#define MMC_CLK_RATE     __REG16(IMX_MMC_BASE + 0x08)
+#define MMC_CMD_DAT_CONT __REG16(IMX_MMC_BASE + 0x0C)
+#define MMC_RES_TO       __REG16(IMX_MMC_BASE + 0x10)
+#define MMC_READ_TO      __REG16(IMX_MMC_BASE + 0x14)
+#define MMC_BLK_LEN      __REG16(IMX_MMC_BASE + 0x18)
+#define MMC_NOB          __REG16(IMX_MMC_BASE + 0x1C)
+#define MMC_REV_NO       __REG16(IMX_MMC_BASE + 0x20)
+#define MMC_INT_MASK     __REG16(IMX_MMC_BASE + 0x24)
+#define MMC_CMD          __REG16(IMX_MMC_BASE + 0x28)
+#define MMC_ARGH         __REG16(IMX_MMC_BASE + 0x2C)
+#define MMC_ARGL         __REG16(IMX_MMC_BASE + 0x30)
+#define MMC_RES_FIFO     __REG16(IMX_MMC_BASE + 0x34)
+#define MMC_BUFFER_ACCESS __REG16(IMX_MMC_BASE + 0x38)
+#define MMC_BUFFER_ACCESS_OFS 0x38
+
+
+#define STR_STP_CLK_ENDIAN              (1<<5)
+#define STR_STP_CLK_RESET               (1<<3)
+#define STR_STP_CLK_ENABLE              (1<<2)
+#define STR_STP_CLK_START_CLK           (1<<1)
+#define STR_STP_CLK_STOP_CLK            (1<<0)
+#define STATUS_CARD_PRESENCE            (1<<15)
+#define STATUS_SDIO_INT_ACTIVE          (1<<14)
+#define STATUS_END_CMD_RESP             (1<<13)
+#define STATUS_WRITE_OP_DONE            (1<<12)
+#define STATUS_DATA_TRANS_DONE          (1<<11)
+#define STATUS_WR_CRC_ERROR_CODE_MASK   (3<<10)
+#define STATUS_CARD_BUS_CLK_RUN         (1<<8)
+#define STATUS_APPL_BUFF_FF             (1<<7)
+#define STATUS_APPL_BUFF_FE             (1<<6)
+#define STATUS_RESP_CRC_ERR             (1<<5)
+#define STATUS_CRC_READ_ERR             (1<<3)
+#define STATUS_CRC_WRITE_ERR            (1<<2)
+#define STATUS_TIME_OUT_RESP            (1<<1)
+#define STATUS_TIME_OUT_READ            (1<<0)
+#define STATUS_ERR_MASK                 0x3f
+#define CLK_RATE_PRESCALER(x)           ((x) & 0x7)
+#define CLK_RATE_CLK_RATE(x)            (((x) & 0x7) << 3)
+#define CMD_DAT_CONT_CMD_RESP_LONG_OFF  (1<<12)
+#define CMD_DAT_CONT_STOP_READWAIT      (1<<11)
+#define CMD_DAT_CONT_START_READWAIT     (1<<10)
+#define CMD_DAT_CONT_BUS_WIDTH_1        (0<<8)
+#define CMD_DAT_CONT_BUS_WIDTH_4        (2<<8)
+#define CMD_DAT_CONT_INIT               (1<<7)
+#define CMD_DAT_CONT_BUSY               (1<<6)
+#define CMD_DAT_CONT_STREAM_BLOCK       (1<<5)
+#define CMD_DAT_CONT_WRITE              (1<<4)
+#define CMD_DAT_CONT_DATA_ENABLE        (1<<3)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R1 (1)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R2 (2)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R3 (3)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R4 (4)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R5 (5)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R6 (6)
+#define INT_MASK_AUTO_CARD_DETECT       (1<<6)
+#define INT_MASK_DAT0_EN                (1<<5)
+#define INT_MASK_SDIO                   (1<<4)
+#define INT_MASK_BUF_READY              (1<<3)
+#define INT_MASK_END_CMD_RES            (1<<2)
+#define INT_MASK_WRITE_OP_DONE          (1<<1)
+#define INT_MASK_DATA_TRAN              (1<<0)
+#define INT_ALL                         (0x7f)
diff -urN linux-2.6.12/drivers/mtd/maps/Kconfig linux-2.6.12-work/drivers/mtd/maps/Kconfig
--- linux-2.6.12/drivers/mtd/maps/Kconfig	2005-06-29 09:26:46.000000000 +0200
+++ linux-2.6.12-work/drivers/mtd/maps/Kconfig	2005-06-29 09:22:45.000000000 +0200
@@ -468,6 +468,10 @@
 	tristate "CFI Flash device mapped on ARM Integrator/P720T"
 	depends on ARM && MTD_CFI
 
+config MTD_SCB9328
+	tristate "CFI Flash device mapped on scb9328 board"
+	depends on ARM && MTD_CFI
+
 config MTD_CDB89712
 	tristate "Cirrus CDB89712 evaluation board mappings"
 	depends on ARM && MTD_CFI && ARCH_CDB89712
@@ -545,6 +549,10 @@
 	  This enables access to the NV-RAM on autronix autcpu12 board.
 	  If you have such a board, say 'Y'.
 
+config MTD_MX1FS2
+	tristate "CFI Flash device mapped on mx1fs2 board"
+	depends on ARM && MTD_CFI
+
 config MTD_EDB7312
 	tristate "CFI Flash device mapped on EDB7312"
 	depends on ARM && MTD_CFI
diff -urN linux-2.6.12/drivers/mtd/maps/Makefile linux-2.6.12-work/drivers/mtd/maps/Makefile
--- linux-2.6.12/drivers/mtd/maps/Makefile	2005-06-29 09:26:46.000000000 +0200
+++ linux-2.6.12-work/drivers/mtd/maps/Makefile	2005-06-29 09:22:45.000000000 +0200
@@ -71,3 +71,5 @@
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
+obj-$(CONFIG_MTD_MX1FS2)	+= mx1fs2.o
+obj-$(CONFIG_MTD_SCB9328)	+= scb9328.o
diff -urN linux-2.6.12/drivers/mtd/maps/mx1fs2.c linux-2.6.12-work/drivers/mtd/maps/mx1fs2.c
--- linux-2.6.12/drivers/mtd/maps/mx1fs2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/drivers/mtd/maps/mx1fs2.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,129 @@
+/*
+ * linux/drivers/mtd/maps/mx1fs2.c
+ *
+ * Mapping driver for the Viasys Flowscreen 2 platform, 
+ * derived from the innokom.c driver. 
+ * 
+ * Authors:	Robert Schwebel, Kai-Uwe Bloem, Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *              (C) 2003, 2004 Pengutronix 
+ *		(C) 2003 Auerswald GmbH & Co. KG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/arch/mx1fs2.h>
+
+static struct map_info mx1fs2_map = {
+	.name = 	"Flowscreen 2 Flash",
+	.bankwidth =	4,
+	.size =		MX1FS2_FLASH_SIZE,
+	.phys =		MX1FS2_FLASH_PHYS,
+};
+
+static struct mtd_partition mx1fs2_partitions[] = {
+	{
+		.name =		"U-Boot",
+		.size =		128*1024,
+		.offset =	0x00000000,
+		/* mask_flags:	MTD_WRITEABLE	   force read-only          */
+	},{
+		.name =		"U-Boot-Environment",
+		.size =		128*1024,
+		.offset =	0x00020000,
+	},{
+		.name =		"Start-Logo",
+		.size =		256*1024,
+		.offset =	0x00040000,
+	},{
+		.name =		"Kernel",
+		.size =		1536*1024,
+		.offset =	0x00080000,
+	},{
+		.name =		"Root-FS",
+		.size =		5*1024*1024,
+		.offset =	0x00200000,
+	},{
+		.name =		"User-FS",
+		.size =		9*1024*1024,
+		.offset =	0x00700000,
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+static struct mtd_partition *parsed_parts;
+
+static int __init init_mx1fs2(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type = "static";
+
+	printk("mx1fs2: probing flash at 0x%08x\n", MX1FS2_FLASH_PHYS);
+	mx1fs2_map.virt = ioremap(MX1FS2_FLASH_PHYS, MX1FS2_FLASH_SIZE);
+
+	if (!mx1fs2_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	simple_map_init(&mx1fs2_map);
+	
+	mymtd = do_map_probe("cfi_probe", &mx1fs2_map);
+	if (!mymtd) {
+		iounmap((void *)mx1fs2_map.map_priv_1);
+		return -ENXIO;
+	}
+
+	/* set partition table */
+	parts = mx1fs2_partitions; 
+	part_type = "static";
+	nb_parts = NB_OF(mx1fs2_partitions);
+
+	printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+	add_mtd_partitions(mymtd, parts, nb_parts);
+
+	return 0;
+}
+
+static void __exit cleanup_mx1fs2(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (mx1fs2_map.map_priv_1)
+		iounmap((void *)mx1fs2_map.map_priv_1);
+	return;
+}
+
+module_init(init_mx1fs2);
+module_exit(cleanup_mx1fs2);
+
diff -urN linux-2.6.12/drivers/mtd/maps/scb9328.c linux-2.6.12-work/drivers/mtd/maps/scb9328.c
--- linux-2.6.12/drivers/mtd/maps/scb9328.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/drivers/mtd/maps/scb9328.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,137 @@
+/*
+ * $Id: scb9328.c,v 1.2 2004/01/29 17:37:19 sascha Exp $
+ *
+ * Map driver for the Lubbock developer platform.
+ *
+ * Author:	Sascha Hauer
+ * Copyright:	(C) 2004 Sascha Hauer, Synertronix GmbH
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <linux/dma-mapping.h>
+
+static void scb9328_map_inval_cache(struct map_info *map, unsigned long from, ssize_t len)
+{
+	consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
+}
+
+static u32 flash_virt = SCB9328_FLASH_BASE;
+
+static struct map_info scb9328_map = {
+	.size =     SCB9328_FLASH_SIZE,
+	.virt =     &flash_virt,
+	.phys =     SCB9328_FLASH_PHYS,
+	.name =     "scb9328_flash",
+	.inval_cache = scb9328_map_inval_cache,
+	.bankwidth = 2
+};
+
+static struct mtd_partition scb9328_partitions[] = {
+	{
+		.name =		"Bootloader",
+		.size =		0x00020000,
+		.offset =	0,
+		.mask_flags =	MTD_WRITEABLE  /* force read-only */
+	},{
+		.name =		"Bootloader env",
+		.size =		0x00020000,
+		.offset =	0x00020000,
+	},{
+		.name =		"Kernel",
+		.size =		0x00200000,
+		.offset =	0x00040000,
+	},{
+		.name =		"Rootfs",
+		.size =		0x00400000,
+		.offset =	0x00240000,
+	},{
+		.name =		"Filesystem",
+		.size =		MTDPART_SIZ_FULL,
+		.offset =	0x00740000
+	}
+};
+
+static struct mtd_info *mymtds;
+static struct mtd_partition *parsed_parts;
+static int nr_parsed_parts;
+
+static const char *probes[] = { "cmdlinepart", NULL };
+
+static int __init init_scb9328(void)
+{
+	int ret = 0;
+
+	scb9328_map.virt = ioremap_nocache(scb9328_map.phys, SCB9328_FLASH_SIZE);
+	if (!scb9328_map.virt) {
+		printk(KERN_WARNING "Failed to ioremap %s\n", scb9328_map.name);
+	}
+
+	scb9328_map.cached = ioremap_cached(scb9328_map.phys,SCB9328_FLASH_SIZE);
+	if (!scb9328_map.cached) {
+		printk(KERN_WARNING "Failed to ioremap cached %s\n", scb9328_map.name);
+	}
+
+	simple_map_init(&scb9328_map);
+
+	printk(KERN_NOTICE "Probing %s at physical address 0x%08lx (%d-bit buswidth)\n",
+			scb9328_map.name, scb9328_map.phys, 
+			scb9328_map.bankwidth * 8);
+
+	mymtds = do_map_probe("cfi_probe", &scb9328_map);
+
+	if (!mymtds) {
+		iounmap((void *)scb9328_map.virt);
+		if (scb9328_map.cached)
+			iounmap(scb9328_map.cached);
+		if (!ret)
+			return -EIO;
+	}
+	mymtds->owner = THIS_MODULE;
+
+	nr_parsed_parts = parse_mtd_partitions(mymtds, probes,
+			&parsed_parts, 0);
+
+	if (nr_parsed_parts > 0) {
+		add_mtd_partitions(mymtds, parsed_parts, nr_parsed_parts);
+	} else {
+		printk("Using static partitions on %s\n", scb9328_map.name);
+		add_mtd_partitions(mymtds, scb9328_partitions, ARRAY_SIZE(scb9328_partitions));
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_scb9328(void)
+{
+	if (nr_parsed_parts)
+		del_mtd_partitions(mymtds);
+	else
+		del_mtd_device(mymtds);			
+
+	map_destroy(mymtds);
+	iounmap((void *)scb9328_map.virt);
+	if (scb9328_map.cached)
+		iounmap(scb9328_map.cached);
+	if (parsed_parts)
+		kfree(parsed_parts);
+}
+
+module_init(init_scb9328);
+module_exit(cleanup_scb9328);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sascha Hauer <saschahauer@web.de>");
+MODULE_DESCRIPTION("MTD map driver for scb9328");
diff -urN linux-2.6.12/drivers/net/Kconfig linux-2.6.12-work/drivers/net/Kconfig
--- linux-2.6.12/drivers/net/Kconfig	2005-06-29 09:26:46.000000000 +0200
+++ linux-2.6.12-work/drivers/net/Kconfig	2005-06-29 09:22:45.000000000 +0200
@@ -824,6 +824,18 @@
 	  <file:Documentation/networking/net-modules.txt>. The module
 	  will be called smc9194.
 
+config DM9000
+	tristate "DM9000 support"
+	depends on ARM && NET_ETHERNET
+	select CRC32
+	select MII
+	---help---
+	  Support for DM9000 chipset.
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/networking/net-modules.txt>.  The module will be
+	  called dm9000.
+
 config NET_VENDOR_RACAL
 	bool "Racal-Interlan (Micom) NI cards"
 	depends on NET_ETHERNET && ISA
diff -urN linux-2.6.12/drivers/net/Makefile linux-2.6.12-work/drivers/net/Makefile
--- linux-2.6.12/drivers/net/Makefile	2005-06-29 09:26:46.000000000 +0200
+++ linux-2.6.12-work/drivers/net/Makefile	2005-06-29 09:22:45.000000000 +0200
@@ -180,6 +180,7 @@
 obj-$(CONFIG_IBMVETH) += ibmveth.o
 obj-$(CONFIG_S2IO) += s2io.o
 obj-$(CONFIG_SMC91X) += smc91x.o
+obj-$(CONFIG_DM9000) += dm9000.o
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
 
 obj-$(CONFIG_ARM) += arm/
diff -urN linux-2.6.12/drivers/net/dm9000.c linux-2.6.12-work/drivers/net/dm9000.c
--- linux-2.6.12/drivers/net/dm9000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/drivers/net/dm9000.c	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,1219 @@
+/*
+ *   dm9000.c: Version 1.2 03/18/2003
+ *
+ *         A Davicom DM9000 ISA NIC fast Ethernet driver for Linux.
+ * 	Copyright (C) 1997  Sten Wang
+ *
+ * 	This program is free software; you can redistribute it and/or
+ * 	modify it under the terms of the GNU General Public License
+ * 	as published by the Free Software Foundation; either version 2
+ * 	of the License, or (at your option) any later version.
+ *
+ * 	This program is distributed in the hope that it will be useful,
+ * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * 	GNU General Public License for more details.
+ *
+ *   (C)Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.
+ *
+ * V0.11	06/20/2001	REG_0A bit3=1, default enable BP with DA match
+ * 	06/22/2001 	Support DM9801 progrmming
+ * 	 	 	E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
+ * 		 	E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
+ * 		     		R17 = (R17 & 0xfff0) | NF + 3
+ * 		 	E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
+ * 		     		R17 = (R17 & 0xfff0) | NF
+ *
+ * v1.00               	modify by simon 2001.9.5
+ *                         change for kernel 2.4.x
+ *
+ * v1.1   11/09/2001      	fix force mode bug
+ *
+ * v1.2   03/18/2003       Weilun Huang <weilun_huang@davicom.com.tw>:
+ * 			Fixed phy reset.
+ * 			Added tx/rx 32 bit mode.
+ * 			Cleaned up for kernel merge.
+ *
+ *        03/03/2004    Sascha Hauer <s.hauer@pengutronix.de>
+ *                      Port to 2.6 kernel
+ *
+ *	  24-Sep-2004   Ben Dooks <ben@simtec.co.uk>
+ *			Cleanup of code to remove ifdefs
+ *			Allowed platform device data to influence access width
+ *			Reformatting areas of code
+ *
+ *        17-Mar-2005   Sascha Hauer <s.hauer@pengutronix.de>
+ *                      * removed 2.4 style module parameters
+ *                      * removed removed unused stat counter and fixed
+ *                        net_device_stats
+ *                      * introduced tx_timeout function
+ *                      * reworked locking
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/dm9000.h>
+#include <linux/delay.h>
+
+#include <asm/delay.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include "dm9000.h"
+
+/* Board/System/Debug information/definition ---------------- */
+
+#define DM9000_PHY		0x40	/* PHY address 0x01 */
+
+#define TRUE			1
+#define FALSE			0
+
+#define CARDNAME "dm9000"
+#define PFX CARDNAME ": "
+
+#define DM9000_TIMER_WUT  jiffies+(HZ*2)	/* timer wakeup time : 2 second */
+
+#define DM9000_DEBUG 0
+
+#if DM9000_DEBUG > 2
+#define PRINTK3(args...)  printk(CARDNAME ": " args)
+#else
+#define PRINTK3(args...)  do { } while(0)
+#endif
+
+#if DM9000_DEBUG > 1
+#define PRINTK2(args...)  printk(CARDNAME ": " args)
+#else
+#define PRINTK2(args...)  do { } while(0)
+#endif
+
+#if DM9000_DEBUG > 0
+#define PRINTK1(args...)  printk(CARDNAME ": " args)
+#define PRINTK(args...)   printk(CARDNAME ": " args)
+#else
+#define PRINTK1(args...)  do { } while(0)
+#define PRINTK(args...)   printk(KERN_DEBUG args)
+#endif
+
+/*
+ * Transmit timeout, default 5 seconds.
+ */
+static int watchdog = 5000;
+module_param(watchdog, int, 0400);
+MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
+
+/* Structure/enum declaration ------------------------------- */
+typedef struct board_info {
+
+	void __iomem *io_addr;	/* Register I/O base address */
+	void __iomem *io_data;	/* Data I/O address */
+	u16 irq;		/* IRQ */
+
+	u16 tx_pkt_cnt;
+	u16 queue_pkt_len;
+	u16 queue_start_addr;
+	u16 dbug_cnt;
+	u8 io_mode;		/* 0:word, 2:byte */
+	u8 phy_addr;
+
+	void (*inblk)(void __iomem *port, void *data, int length);
+	void (*outblk)(void __iomem *port, void *data, int length);
+	void (*dumpblk)(void __iomem *port, int length);
+
+	struct resource	*addr_res;   /* resources found */
+	struct resource *data_res;
+	struct resource	*addr_req;   /* resources requested */
+	struct resource *data_req;
+	struct resource *irq_res;
+
+	struct timer_list timer;
+	struct net_device_stats stats;
+	unsigned char srom[128];
+	spinlock_t lock;
+
+	struct mii_if_info mii;
+	u32 msg_enable;
+} board_info_t;
+
+/* function declaration ------------------------------------- */
+static int dm9000_probe(struct device *);
+static int dm9000_open(struct net_device *);
+static int dm9000_start_xmit(struct sk_buff *, struct net_device *);
+static int dm9000_stop(struct net_device *);
+static int dm9000_do_ioctl(struct net_device *, struct ifreq *, int);
+
+
+static void dm9000_timer(unsigned long);
+static void dm9000_init_dm9000(struct net_device *);
+
+static struct net_device_stats *dm9000_get_stats(struct net_device *);
+
+static irqreturn_t dm9000_interrupt(int, void *, struct pt_regs *);
+
+static int dm9000_phy_read(struct net_device *dev, int phyaddr_unsused, int reg);
+static void dm9000_phy_write(struct net_device *dev, int phyaddr_unused, int reg,
+			   int value);
+static u16 read_srom_word(board_info_t *, int);
+static void dm9000_rx(struct net_device *);
+static void dm9000_hash_table(struct net_device *);
+
+//#define DM9000_PROGRAM_EEPROM
+#ifdef DM9000_PROGRAM_EEPROM
+static void program_eeprom(board_info_t * db);
+#endif
+/* DM9000 network board routine ---------------------------- */
+
+static void
+dm9000_reset(board_info_t * db)
+{
+	PRINTK1("dm9000x: resetting\n");
+	/* RESET device */
+	writeb(DM9000_NCR, db->io_addr);
+	udelay(200);
+	writeb(NCR_RST, db->io_data);
+	udelay(200);
+}
+
+/*
+ *   Read a byte from I/O port
+ */
+static u8
+ior(board_info_t * db, int reg)
+{
+	writeb(reg, db->io_addr);
+	return readb(db->io_data);
+}
+
+/*
+ *   Write a byte to I/O port
+ */
+
+static void
+iow(board_info_t * db, int reg, int value)
+{
+	writeb(reg, db->io_addr);
+	writeb(value, db->io_data);
+}
+
+/* routines for sending block to chip */
+
+static void dm9000_outblk_8bit(void __iomem *reg, void *data, int count)
+{
+	writesb(reg, data, count);
+}
+
+static void dm9000_outblk_16bit(void __iomem *reg, void *data, int count)
+{
+	writesw(reg, data, (count+1) >> 1);
+}
+
+static void dm9000_outblk_32bit(void __iomem *reg, void *data, int count)
+{
+	writesl(reg, data, (count+3) >> 2);
+}
+
+/* input block from chip to memory */
+
+static void dm9000_inblk_8bit(void __iomem *reg, void *data, int count)
+{
+	readsb(reg, data, count+1);
+}
+
+
+static void dm9000_inblk_16bit(void __iomem *reg, void *data, int count)
+{
+	readsw(reg, data, (count+1) >> 1);
+}
+
+static void dm9000_inblk_32bit(void __iomem *reg, void *data, int count)
+{
+	readsl(reg, data, (count+3) >> 2);
+}
+
+/* dump block from chip to null */
+
+static void dm9000_dumpblk_8bit(void __iomem *reg, int count)
+{
+	int i;
+	int tmp;
+
+	for (i = 0; i < count; i++)
+		tmp = readb(reg);
+}
+
+static void dm9000_dumpblk_16bit(void __iomem *reg, int count)
+{
+	int i;
+	int tmp;
+
+	count = (count + 1) >> 1;
+
+	for (i = 0; i < count; i++)
+		tmp = readw(reg);
+}
+
+static void dm9000_dumpblk_32bit(void __iomem *reg, int count)
+{
+	int i;
+	int tmp;
+
+	count = (count + 3) >> 2;
+
+	for (i = 0; i < count; i++)
+		tmp = readl(reg);
+}
+
+/* dm9000_set_io
+ *
+ * select the specified set of io routines to use with the
+ * device
+ */
+
+static void dm9000_set_io(struct board_info *db, int byte_width)
+{
+	/* use the size of the data resource to work out what IO
+	 * routines we want to use
+	 */
+
+	switch (byte_width) {
+	case 1:
+		db->dumpblk = dm9000_dumpblk_8bit;
+		db->outblk  = dm9000_outblk_8bit;
+		db->inblk   = dm9000_inblk_8bit;
+		break;
+
+	case 2:
+		db->dumpblk = dm9000_dumpblk_16bit;
+		db->outblk  = dm9000_outblk_16bit;
+		db->inblk   = dm9000_inblk_16bit;
+		break;
+
+	case 3:
+		printk(KERN_ERR PFX ": 3 byte IO, falling back to 16bit\n");
+		db->dumpblk = dm9000_dumpblk_16bit;
+		db->outblk  = dm9000_outblk_16bit;
+		db->inblk   = dm9000_inblk_16bit;
+		break;
+
+	case 4:
+	default:
+		db->dumpblk = dm9000_dumpblk_32bit;
+		db->outblk  = dm9000_outblk_32bit;
+		db->inblk   = dm9000_inblk_32bit;
+		break;
+	}
+}
+
+
+/* Our watchdog timed out. Called by the networking layer */
+static void dm9000_timeout(struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+	u8 reg_save;
+	unsigned long flags;
+
+	/* Save previous register address */
+	reg_save = readb(db->io_addr);
+	spin_lock_irqsave(db->lock,flags);
+
+	netif_stop_queue(dev);
+	dm9000_reset(db);
+	dm9000_init_dm9000(dev);
+	/* We can accept TX packets again */
+	dev->trans_start = jiffies;
+	netif_wake_queue(dev);
+
+	/* Restore previous register address */
+	writeb(reg_save, db->io_addr);
+	spin_unlock_irqrestore(db->lock,flags);
+}
+
+
+/* dm9000_release_board
+ *
+ * release a board, and any mapped resources
+ */
+
+static void
+dm9000_release_board(struct platform_device *pdev, struct board_info *db)
+{
+	if (db->data_res == NULL) {
+		if (db->addr_res != NULL)
+			release_mem_region((unsigned long)db->io_addr, 4);
+		return;
+	}
+
+	/* unmap our resources */
+
+	iounmap(db->io_addr);
+	iounmap(db->io_data);
+
+	/* release the resources */
+
+	if (db->data_req != NULL) {
+		release_resource(db->data_req);
+		kfree(db->data_req);
+	}
+
+	if (db->addr_res != NULL) {
+		release_resource(db->data_req);
+		kfree(db->addr_req);
+	}
+}
+
+#define res_size(_r) (((_r)->end - (_r)->start) + 1)
+
+/*
+ * Search DM9000 board, allocate space and register it
+ */
+static int
+dm9000_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dm9000_plat_data *pdata = pdev->dev.platform_data;
+	struct board_info *db;	/* Point a board information structure */
+	struct net_device *ndev;
+	unsigned long base;
+	int ret = 0;
+	int iosize;
+	int i;
+	u32 id_val;
+
+	printk(KERN_INFO "%s Ethernet Driver\n", CARDNAME);
+
+	/* Init network device */
+	ndev = alloc_etherdev(sizeof (struct board_info));
+	if (!ndev) {
+		printk("%s: could not allocate device.\n", CARDNAME);
+		return -ENOMEM;
+	}
+
+	SET_MODULE_OWNER(ndev);
+	SET_NETDEV_DEV(ndev, dev);
+
+	PRINTK2("dm9000_probe()");
+
+	/* setup board info structure */
+	db = (struct board_info *) ndev->priv;
+	memset(db, 0, sizeof (*db));
+
+	if (pdev->num_resources < 2) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	switch (pdev->num_resources) {
+	case 2:
+		base = pdev->resource[0].start;
+
+		if (!request_mem_region(base, 4, ndev->name)) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		ndev->base_addr = base;
+		ndev->irq = pdev->resource[1].start;
+		db->io_addr = (void *)base;
+		db->io_data = (void *)(base + 4);
+
+		break;
+
+	case 3:
+		db->addr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		db->data_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		db->irq_res  = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+		if (db->addr_res == NULL || db->data_res == NULL) {
+			printk(KERN_ERR PFX "insufficient resources\n");
+			ret = -ENOENT;
+			goto out;
+		}
+
+		i = res_size(db->addr_res);
+		db->addr_req = request_mem_region(db->addr_res->start, i,
+						  pdev->name);
+
+		if (db->addr_req == NULL) {
+			printk(KERN_ERR PFX "cannot claim address reg area\n");
+			ret = -EIO;
+			goto out;
+		}
+
+		db->io_addr = ioremap(db->addr_res->start, i);
+
+		if (db->io_addr == NULL) {
+			printk(KERN_ERR "failed to ioremap address reg\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		iosize = res_size(db->data_res);
+		db->data_req = request_mem_region(db->data_res->start, iosize,
+						  pdev->name);
+
+		if (db->data_req == NULL) {
+			printk(KERN_ERR PFX "cannot claim data reg area\n");
+			ret = -EIO;
+			goto out;
+		}
+
+		db->io_data = ioremap(db->data_res->start, iosize);
+
+		if (db->io_data == NULL) {
+			printk(KERN_ERR "failed to ioremap data reg\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* fill in parameters for net-dev structure */
+
+		ndev->base_addr = (unsigned long)db->io_addr;
+		ndev->irq	= db->irq_res->start;
+
+		/* ensure at least we have a default set of IO routines */
+		dm9000_set_io(db, iosize);
+
+	}
+
+	/* check to see if anything is being over-ridden */
+	if (pdata != NULL) {
+		/* check to see if the driver wants to over-ride the
+		 * default IO width */
+
+		if (pdata->flags & DM9000_PLATF_8BITONLY)
+			dm9000_set_io(db, 1);
+
+		if (pdata->flags & DM9000_PLATF_16BITONLY)
+			dm9000_set_io(db, 2);
+
+		if (pdata->flags & DM9000_PLATF_32BITONLY)
+			dm9000_set_io(db, 4);
+
+		/* check to see if there are any IO routine
+		 * over-rides */
+
+		if (pdata->inblk != NULL)
+			db->inblk = pdata->inblk;
+
+		if (pdata->outblk != NULL)
+			db->outblk = pdata->outblk;
+
+		if (pdata->dumpblk != NULL)
+			db->dumpblk = pdata->dumpblk;
+	}
+
+	dm9000_reset(db);
+
+	/* try two times, DM9000 sometimes gets the first read wrong */
+	for (i = 0; i < 2; i++) {
+		id_val  = ior(db, DM9000_VIDL);
+		id_val |= (u32)ior(db, DM9000_VIDH) << 8;
+		id_val |= (u32)ior(db, DM9000_PIDL) << 16;
+		id_val |= (u32)ior(db, DM9000_PIDH) << 24;
+
+		if (id_val == DM9000_ID)
+			break;
+		printk("%s: read wrong id 0x%08x\n", CARDNAME, id_val);
+	}
+
+	if (id_val != DM9000_ID) {
+		printk("%s: wrong id: 0x%08x\n", CARDNAME, id_val);
+		goto release;
+	}
+
+	/* from this point we assume that we have found a DM9000 */
+
+	/* driver system function */
+	ether_setup(ndev);
+
+	ndev->open		 = &dm9000_open;
+	ndev->hard_start_xmit    = &dm9000_start_xmit;
+	ndev->tx_timeout         = &dm9000_timeout;
+	ndev->watchdog_timeo = msecs_to_jiffies(watchdog);
+	ndev->stop		 = &dm9000_stop;
+	ndev->get_stats		 = &dm9000_get_stats;
+	ndev->set_multicast_list = &dm9000_hash_table;
+	ndev->do_ioctl		 = &dm9000_do_ioctl;
+
+#ifdef DM9000_PROGRAM_EEPROM
+	program_eeprom(db);
+#endif
+	db->msg_enable       = NETIF_MSG_LINK;
+	db->mii.phy_id_mask  = 0x1f;
+	db->mii.reg_num_mask = 0x1f;
+	db->mii.force_media  = 0;
+	db->mii.full_duplex  = 0;
+	db->mii.dev	     = ndev;
+	db->mii.mdio_read    = dm9000_phy_read;
+	db->mii.mdio_write   = dm9000_phy_write;
+
+	/* Read SROM content */
+	for (i = 0; i < 64; i++)
+		((u16 *) db->srom)[i] = read_srom_word(db, i);
+
+	/* Set Node Address */
+	for (i = 0; i < 6; i++)
+		ndev->dev_addr[i] = db->srom[i];
+
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		printk("%s: Invalid ethernet MAC address.  Please "
+		       "set using ifconfig\n", ndev->name);
+
+	dev_set_drvdata(dev, ndev);
+	ret = register_netdev(ndev);
+
+	if (ret == 0) {
+		printk("%s: dm9000 at %p,%p IRQ %d MAC: ",
+		       ndev->name,  db->io_addr, db->io_data, ndev->irq);
+		for (i = 0; i < 5; i++)
+			printk("%02x:", ndev->dev_addr[i]);
+		printk("%02x\n", ndev->dev_addr[5]);
+	}
+	return 0;
+
+ release:
+ out:
+	printk("%s: not found (%d).\n", CARDNAME, ret);
+
+	dm9000_release_board(pdev, db);
+	kfree(ndev);
+
+	return ret;
+}
+
+/*
+ *  Open the interface.
+ *  The interface is opened whenever "ifconfig" actives it.
+ */
+static int
+dm9000_open(struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+
+	PRINTK2("entering dm9000_open\n");
+
+	if (request_irq(dev->irq, &dm9000_interrupt, SA_SHIRQ, dev->name, dev))
+		return -EAGAIN;
+
+	/* Initialize DM9000 board */
+	dm9000_reset(db);
+	dm9000_init_dm9000(dev);
+
+	/* Init driver variable */
+	db->dbug_cnt = 0;
+
+	/* set and active a timer process */
+	init_timer(&db->timer);
+	db->timer.expires  = DM9000_TIMER_WUT * 2;
+	db->timer.data     = (unsigned long) dev;
+	db->timer.function = &dm9000_timer;
+	add_timer(&db->timer);
+
+	mii_check_media(&db->mii, netif_msg_link(db), 1);
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/*
+ * Initilize dm9000 board
+ */
+static void
+dm9000_init_dm9000(struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+
+	PRINTK1("entering %s\n",__FUNCTION__);
+
+	/* I/O mode */
+	db->io_mode = ior(db, DM9000_ISR) >> 6;	/* ISR bit7:6 keeps I/O mode */
+
+	/* GPIO0 on pre-activate PHY */
+	iow(db, DM9000_GPR, 0);	/* REG_1F bit0 activate phyxcer */
+	iow(db, DM9000_GPCR, GPCR_GEP_CNTL);	/* Let GPIO0 output */
+	iow(db, DM9000_GPR, 0);	/* Enable PHY */
+
+	/* Program operating register */
+	iow(db, DM9000_TCR, 0);	        /* TX Polling clear */
+	iow(db, DM9000_BPTR, 0x3f);	/* Less 3Kb, 200us */
+	iow(db, DM9000_FCR, 0xff);	/* Flow Control */
+	iow(db, DM9000_SMCR, 0);        /* Special Mode */
+	/* clear TX status */
+	iow(db, DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);
+	iow(db, DM9000_ISR, ISR_CLR_STATUS); /* Clear interrupt status */
+
+	/* Set address filter table */
+	dm9000_hash_table(dev);
+
+	/* Activate DM9000 */
+	iow(db, DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);
+	/* Enable TX/RX interrupt mask */
+	iow(db, DM9000_IMR, IMR_PAR | IMR_PTM | IMR_PRM);
+
+	/* Init Driver variable */
+	db->tx_pkt_cnt = 0;
+	db->queue_pkt_len = 0;
+	dev->trans_start = 0;
+	spin_lock_init(&db->lock);
+}
+
+/*
+ *  Hardware start transmission.
+ *  Send a packet to media from the upper layer.
+ */
+static int
+dm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+
+	PRINTK3("dm9000_start_xmit\n");
+
+	if (db->tx_pkt_cnt > 1)
+		return 1;
+
+	netif_stop_queue(dev);
+
+	/* Disable all interrupts */
+	iow(db, DM9000_IMR, IMR_PAR);
+
+	/* Move data to DM9000 TX RAM */
+	writeb(DM9000_MWCMD, db->io_addr);
+
+	(db->outblk)(db->io_data, skb->data, skb->len);
+	db->stats.tx_bytes += skb->len;
+
+	/* TX control: First packet immediately send, second packet queue */
+	if (db->tx_pkt_cnt == 0) {
+
+		/* First Packet */
+		db->tx_pkt_cnt++;
+
+		/* Set TX length to DM9000 */
+		iow(db, DM9000_TXPLL, skb->len & 0xff);
+		iow(db, DM9000_TXPLH, (skb->len >> 8) & 0xff);
+
+		/* Issue TX polling command */
+		iow(db, DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */
+
+		dev->trans_start = jiffies;	/* save the time stamp */
+
+	} else {
+		/* Second packet */
+		db->tx_pkt_cnt++;
+		db->queue_pkt_len = skb->len;
+	}
+
+	/* free this SKB */
+	dev_kfree_skb(skb);
+
+	/* Re-enable resource check */
+	if (db->tx_pkt_cnt == 1)
+		netif_wake_queue(dev);
+
+	/* Re-enable interrupt */
+	iow(db, DM9000_IMR, IMR_PAR | IMR_PTM | IMR_PRM);
+
+	return 0;
+}
+
+static void
+dm9000_shutdown(struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+
+	/* RESET device */
+	dm9000_phy_write(dev, 0, MII_BMCR, BMCR_RESET);	/* PHY RESET */
+	iow(db, DM9000_GPR, 0x01);	/* Power-Down PHY */
+	iow(db, DM9000_IMR, IMR_PAR);	/* Disable all interrupt */
+	iow(db, DM9000_RCR, 0x00);	/* Disable RX */
+}
+
+/*
+ * Stop the interface.
+ * The interface is stopped when it is brought.
+ */
+static int
+dm9000_stop(struct net_device *ndev)
+{
+	board_info_t *db = (board_info_t *) ndev->priv;
+
+	PRINTK1("entering %s\n",__FUNCTION__);
+
+	/* deleted timer */
+	del_timer(&db->timer);
+
+	netif_stop_queue(ndev);
+	netif_carrier_off(ndev);
+
+	/* free interrupt */
+	free_irq(ndev->irq, ndev);
+
+	dm9000_shutdown(ndev);
+
+	return 0;
+}
+
+/*
+ * DM9000 interrupt handler
+ * receive the packet to upper layer, free the transmitted packet
+ */
+
+void
+dm9000_tx_done(struct net_device *dev, board_info_t * db)
+{
+	int tx_status = ior(db, DM9000_NSR);	/* Got TX status */
+
+	if (tx_status & (NSR_TX2END | NSR_TX1END)) {
+		/* One packet sent complete */
+		db->tx_pkt_cnt--;
+		db->stats.tx_packets++;
+
+		/* Queue packet check & send */
+		if (db->tx_pkt_cnt > 0) {
+			iow(db, DM9000_TXPLL, db->queue_pkt_len & 0xff);
+			iow(db, DM9000_TXPLH, (db->queue_pkt_len >> 8) & 0xff);
+			iow(db, DM9000_TCR, TCR_TXREQ);
+			dev->trans_start = jiffies;
+		}
+		netif_wake_queue(dev);
+	}
+}
+
+static irqreturn_t
+dm9000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	board_info_t *db;
+	int int_status;
+	u8 reg_save;
+
+	PRINTK3("entering %s\n",__FUNCTION__);
+
+	if (!dev) {
+		PRINTK1("dm9000_interrupt() without DEVICE arg\n");
+		return IRQ_HANDLED;
+	}
+
+	/* A real interrupt coming */
+	db = (board_info_t *) dev->priv;
+	spin_lock(&db->lock);
+
+	/* Save previous register address */
+	reg_save = readb(db->io_addr);
+
+	/* Disable all interrupts */
+	iow(db, DM9000_IMR, IMR_PAR);
+
+	/* Got DM9000 interrupt status */
+	int_status = ior(db, DM9000_ISR);	/* Got ISR */
+	iow(db, DM9000_ISR, int_status);	/* Clear ISR status */
+
+	/* Received the coming packet */
+	if (int_status & ISR_PRS)
+		dm9000_rx(dev);
+
+	/* Trnasmit Interrupt check */
+	if (int_status & ISR_PTS)
+		dm9000_tx_done(dev, db);
+
+	/* Re-enable interrupt mask */
+	iow(db, DM9000_IMR, IMR_PAR | IMR_PTM | IMR_PRM);
+
+	/* Restore previous register address */
+	writeb(reg_save, db->io_addr);
+
+	spin_unlock(&db->lock);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *  Get statistics from driver.
+ */
+static struct net_device_stats *
+dm9000_get_stats(struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+	return &db->stats;
+}
+
+/*
+ *  Process the upper socket ioctl command
+ */
+static int
+dm9000_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	PRINTK1("entering %s\n",__FUNCTION__);
+	return 0;
+}
+
+/*
+ *  A periodic timer routine
+ *  Dynamic media sense, allocated Rx buffer...
+ */
+static void
+dm9000_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	board_info_t *db = (board_info_t *) dev->priv;
+	u8 reg_save;
+	unsigned long flags;
+
+	PRINTK3("dm9000_timer()\n");
+
+	spin_lock_irqsave(db->lock,flags);
+	/* Save previous register address */
+	reg_save = readb(db->io_addr);
+
+	mii_check_media(&db->mii, netif_msg_link(db), 0);
+
+	/* Restore previous register address */
+	writeb(reg_save, db->io_addr);
+	spin_unlock_irqrestore(db->lock,flags);
+
+	/* Set timer again */
+	db->timer.expires = DM9000_TIMER_WUT;
+	add_timer(&db->timer);
+}
+
+struct dm9000_rxhdr {
+	u16	RxStatus;
+	u16	RxLen;
+} __attribute__((__packed__));
+
+/*
+ *  Received a packet and pass to upper layer
+ */
+static void
+dm9000_rx(struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+	struct dm9000_rxhdr rxhdr;
+	struct sk_buff *skb;
+	u8 rxbyte, *rdptr;
+	int GoodPacket;
+	int RxLen;
+
+	/* Check packet ready or not */
+	do {
+		ior(db, DM9000_MRCMDX);	/* Dummy read */
+
+		/* Get most updated data */
+		rxbyte = readb(db->io_data);
+
+		/* Status check: this byte must be 0 or 1 */
+		if (rxbyte > DM9000_PKT_RDY) {
+			printk("status check failed: %d\n", rxbyte);
+			iow(db, DM9000_RCR, 0x00);	/* Stop Device */
+			iow(db, DM9000_ISR, IMR_PAR);	/* Stop INT request */
+			return;
+		}
+
+		if (rxbyte != DM9000_PKT_RDY)
+			return;
+
+		/* A packet ready now  & Get status/length */
+		GoodPacket = TRUE;
+		writeb(DM9000_MRCMD, db->io_addr);
+
+		(db->inblk)(db->io_data, &rxhdr, sizeof(rxhdr));
+
+		RxLen = rxhdr.RxLen;
+
+		/* Packet Status check */
+		if (RxLen < 0x40) {
+			GoodPacket = FALSE;
+			PRINTK1("Bad Packet received (runt)\n");
+		}
+
+		if (RxLen > DM9000_PKT_MAX) {
+			PRINTK1("RST: RX Len:%x\n", RxLen);
+		}
+
+		if (rxhdr.RxStatus & 0xbf00) {
+			GoodPacket = FALSE;
+			if (rxhdr.RxStatus & 0x100) {
+				PRINTK1("fifo error\n");
+				db->stats.rx_fifo_errors++;
+			}
+			if (rxhdr.RxStatus & 0x200) {
+				PRINTK1("crc error\n");
+				db->stats.rx_crc_errors++;
+			}
+			if (rxhdr.RxStatus & 0x8000) {
+				PRINTK1("length error\n");
+				db->stats.rx_length_errors++;
+			}
+		}
+
+		/* Move data from DM9000 */
+		if (GoodPacket
+		    && ((skb = dev_alloc_skb(RxLen + 4)) != NULL)) {
+			skb->dev = dev;
+			skb_reserve(skb, 2);
+			rdptr = (u8 *) skb_put(skb, RxLen - 4);
+
+			/* Read received packet from RX SRAM */
+
+			(db->inblk)(db->io_data, rdptr, RxLen);
+			db->stats.rx_bytes += RxLen;
+
+			/* Pass to upper layer */
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_rx(skb);
+			db->stats.rx_packets++;
+
+		} else {
+			/* need to dump the packet's data */
+
+			(db->dumpblk)(db->io_data, RxLen);
+		}
+	} while (rxbyte == DM9000_PKT_RDY);
+}
+
+/*
+ *  Read a word data from SROM
+ */
+static u16
+read_srom_word(board_info_t * db, int offset)
+{
+	iow(db, DM9000_EPAR, offset);
+	iow(db, DM9000_EPCR, EPCR_ERPRR);
+	mdelay(8);		/* according to the datasheet 200us should be enough,
+				   but it doesn't work */
+	iow(db, DM9000_EPCR, 0x0);
+	return (ior(db, DM9000_EPDRL) + (ior(db, DM9000_EPDRH) << 8));
+}
+
+#ifdef DM9000_PROGRAM_EEPROM
+/*
+ * Write a word data to SROM
+ */
+static void
+write_srom_word(board_info_t * db, int offset, u16 val)
+{
+	iow(db, DM9000_EPAR, offset);
+	iow(db, DM9000_EPDRH, ((val >> 8) & 0xff));
+	iow(db, DM9000_EPDRL, (val & 0xff));
+	iow(db, DM9000_EPCR, EPCR_WEP | EPCR_ERPRW);
+	mdelay(8);		/* same shit */
+	iow(db, DM9000_EPCR, 0);
+}
+
+/*
+ * Only for development:
+ * Here we write static data to the eeprom in case
+ * we don't have valid content on a new board
+ */
+static void
+program_eeprom(board_info_t * db)
+{
+	u16 eeprom[] = { 0x0c00, 0x007f, 0x1300,	/* MAC Address */
+		0x0000,		/* Autoload: accept nothing */
+		0x0a46, 0x9000,	/* Vendor / Product ID */
+		0x0000,		/* pin control */
+		0x0000,
+	};			/* Wake-up mode control */
+	int i;
+	for (i = 0; i < 8; i++)
+		write_srom_word(db, i, eeprom[i]);
+}
+#endif
+
+
+/*
+ *  Calculate the CRC valude of the Rx packet
+ *  flag = 1 : return the reverse CRC (for the received packet CRC)
+ *         0 : return the normal CRC (for Hash Table index)
+ */
+
+static unsigned long
+cal_CRC(unsigned char *Data, unsigned int Len, u8 flag)
+{
+
+       u32 crc = ether_crc_le(Len, Data);
+
+       if (flag)
+               return ~crc;
+
+       return crc;
+}
+
+/*
+ *  Set DM9000 multicast address
+ */
+static void
+dm9000_hash_table(struct net_device *dev)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+	struct dev_mc_list *mcptr = dev->mc_list;
+	int mc_cnt = dev->mc_count;
+	u32 hash_val;
+	u16 i, oft, hash_table[4];
+	unsigned long flags;
+
+	PRINTK2("dm9000_hash_table()\n");
+
+	spin_lock_irqsave(&db->lock,flags);
+
+	for (i = 0, oft = 0x10; i < 6; i++, oft++)
+		iow(db, oft, dev->dev_addr[i]);
+
+	/* Clear Hash Table */
+	for (i = 0; i < 4; i++)
+		hash_table[i] = 0x0;
+
+	/* broadcast address */
+	hash_table[3] = 0x8000;
+
+	/* the multicast address in Hash Table : 64 bits */
+	for (i = 0; i < mc_cnt; i++, mcptr = mcptr->next) {
+		hash_val = cal_CRC((char *) mcptr->dmi_addr, 6, 0) & 0x3f;
+		hash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);
+	}
+
+	/* Write the hash table to MAC MD table */
+	for (i = 0, oft = 0x16; i < 4; i++) {
+		iow(db, oft++, hash_table[i] & 0xff);
+		iow(db, oft++, (hash_table[i] >> 8) & 0xff);
+	}
+
+	spin_unlock_irqrestore(&db->lock,flags);
+}
+
+
+/*
+ *   Read a word from phyxcer
+ */
+static int
+dm9000_phy_read(struct net_device *dev, int phy_reg_unused, int reg)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&db->lock,flags);
+	/* Fill the phyxcer register into REG_0C */
+	iow(db, DM9000_EPAR, DM9000_PHY | reg);
+
+	iow(db, DM9000_EPCR, 0xc);	/* Issue phyxcer read command */
+	udelay(100);		/* Wait read complete */
+	iow(db, DM9000_EPCR, 0x0);	/* Clear phyxcer read command */
+
+	/* The read data keeps on REG_0D & REG_0E */
+	ret = (ior(db, DM9000_EPDRH) << 8) | ior(db, DM9000_EPDRL);
+
+	spin_unlock_irqrestore(&db->lock,flags);
+
+	return ret;
+}
+
+/*
+ *   Write a word to phyxcer
+ */
+static void
+dm9000_phy_write(struct net_device *dev, int phyaddr_unused, int reg, int value)
+{
+	board_info_t *db = (board_info_t *) dev->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&db->lock,flags);
+
+	/* Fill the phyxcer register into REG_0C */
+	iow(db, DM9000_EPAR, DM9000_PHY | reg);
+
+	/* Fill the written data into REG_0D & REG_0E */
+	iow(db, DM9000_EPDRL, (value & 0xff));
+	iow(db, DM9000_EPDRH, ((value >> 8) & 0xff));
+
+	iow(db, DM9000_EPCR, 0xa);	/* Issue phyxcer write command */
+	udelay(500);		/* Wait write complete */
+	iow(db, DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
+
+	spin_unlock_irqrestore(&db->lock,flags);
+}
+
+static int
+dm9000_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+
+	if (ndev && level == SUSPEND_DISABLE) {
+		if (netif_running(ndev)) {
+			netif_device_detach(ndev);
+			dm9000_shutdown(ndev);
+		}
+	}
+	return 0;
+}
+
+static int
+dm9000_drv_resume(struct device *dev, u32 level)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	board_info_t *db = (board_info_t *) ndev->priv;
+
+	if (ndev && level == RESUME_ENABLE) {
+
+		if (netif_running(ndev)) {
+			dm9000_reset(db);
+			dm9000_init_dm9000(ndev);
+
+			netif_device_attach(ndev);
+		}
+	}
+	return 0;
+}
+
+static int
+dm9000_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = dev_get_drvdata(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	unregister_netdev(ndev);
+	dm9000_release_board(pdev, (board_info_t *) ndev->priv);
+	kfree(ndev);		/* free device structure */
+
+	PRINTK1("clean_module() exit\n");
+
+	return 0;
+}
+
+static struct device_driver dm9000_driver = {
+	.name    = "dm9000",
+	.bus     = &platform_bus_type,
+	.probe   = dm9000_probe,
+	.remove  = dm9000_drv_remove,
+	.suspend = dm9000_drv_suspend,
+	.resume  = dm9000_drv_resume,
+};
+
+static int __init
+dm9000_init(void)
+{
+	return driver_register(&dm9000_driver);	/* search board and register */
+}
+
+static void __exit
+dm9000_cleanup(void)
+{
+	driver_unregister(&dm9000_driver);
+}
+
+module_init(dm9000_init);
+module_exit(dm9000_cleanup);
+
+MODULE_AUTHOR("Sascha Hauer, Ben Dooks");
+MODULE_DESCRIPTION("Davicom DM9000 network driver");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.12/drivers/net/dm9000.h linux-2.6.12-work/drivers/net/dm9000.h
--- linux-2.6.12/drivers/net/dm9000.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/drivers/net/dm9000.h	2005-06-29 09:22:45.000000000 +0200
@@ -0,0 +1,135 @@
+/*
+ * dm9000 Ethernet
+ */
+
+#ifndef _DM9000X_H_
+#define _DM9000X_H_
+
+#define DM9000_ID		0x90000A46
+
+/* although the registers are 16 bit, they are 32-bit aligned.
+ */
+
+#define DM9000_NCR             0x00
+#define DM9000_NSR             0x01
+#define DM9000_TCR             0x02
+#define DM9000_TSR1            0x03
+#define DM9000_TSR2            0x04
+#define DM9000_RCR             0x05
+#define DM9000_RSR             0x06
+#define DM9000_ROCR            0x07
+#define DM9000_BPTR            0x08
+#define DM9000_FCTR            0x09
+#define DM9000_FCR             0x0A
+#define DM9000_EPCR            0x0B
+#define DM9000_EPAR            0x0C
+#define DM9000_EPDRL           0x0D
+#define DM9000_EPDRH           0x0E
+#define DM9000_WCR             0x0F
+
+#define DM9000_PAR             0x10
+#define DM9000_MAR             0x16
+
+#define DM9000_GPCR	       0x1e
+#define DM9000_GPR             0x1f
+#define DM9000_TRPAL           0x22
+#define DM9000_TRPAH           0x23
+#define DM9000_RWPAL           0x24
+#define DM9000_RWPAH           0x25
+
+#define DM9000_VIDL            0x28
+#define DM9000_VIDH            0x29
+#define DM9000_PIDL            0x2A
+#define DM9000_PIDH            0x2B
+
+#define DM9000_CHIPR           0x2C
+#define DM9000_SMCR            0x2F
+
+#define DM9000_MRCMDX          0xF0
+#define DM9000_MRCMD           0xF2
+#define DM9000_MRRL            0xF4
+#define DM9000_MRRH            0xF5
+#define DM9000_MWCMDX          0xF6
+#define DM9000_MWCMD           0xF8
+#define DM9000_MWRL            0xFA
+#define DM9000_MWRH            0xFB
+#define DM9000_TXPLL           0xFC
+#define DM9000_TXPLH           0xFD
+#define DM9000_ISR             0xFE
+#define DM9000_IMR             0xFF
+
+#define NCR_EXT_PHY         (1<<7)
+#define NCR_WAKEEN          (1<<6)
+#define NCR_FCOL            (1<<4)
+#define NCR_FDX             (1<<3)
+#define NCR_LBK             (3<<1)
+#define NCR_RST	            (1<<0)
+
+#define NSR_SPEED           (1<<7)
+#define NSR_LINKST          (1<<6)
+#define NSR_WAKEST          (1<<5)
+#define NSR_TX2END          (1<<3)
+#define NSR_TX1END          (1<<2)
+#define NSR_RXOV            (1<<1)
+
+#define TCR_TJDIS           (1<<6)
+#define TCR_EXCECM          (1<<5)
+#define TCR_PAD_DIS2        (1<<4)
+#define TCR_CRC_DIS2        (1<<3)
+#define TCR_PAD_DIS1        (1<<2)
+#define TCR_CRC_DIS1        (1<<1)
+#define TCR_TXREQ           (1<<0)
+
+#define TSR_TJTO            (1<<7)
+#define TSR_LC              (1<<6)
+#define TSR_NC              (1<<5)
+#define TSR_LCOL            (1<<4)
+#define TSR_COL             (1<<3)
+#define TSR_EC              (1<<2)
+
+#define RCR_WTDIS           (1<<6)
+#define RCR_DIS_LONG        (1<<5)
+#define RCR_DIS_CRC         (1<<4)
+#define RCR_ALL	            (1<<3)
+#define RCR_RUNT            (1<<2)
+#define RCR_PRMSC           (1<<1)
+#define RCR_RXEN            (1<<0)
+
+#define RSR_RF              (1<<7)
+#define RSR_MF              (1<<6)
+#define RSR_LCS             (1<<5)
+#define RSR_RWTO            (1<<4)
+#define RSR_PLE             (1<<3)
+#define RSR_AE              (1<<2)
+#define RSR_CE              (1<<1)
+#define RSR_FOE             (1<<0)
+
+#define FCTR_HWOT(ot)	(( ot & 0xf ) << 4 )
+#define FCTR_LWOT(ot)	( ot & 0xf )
+
+#define IMR_PAR             (1<<7)
+#define IMR_ROOM            (1<<3)
+#define IMR_ROM             (1<<2)
+#define IMR_PTM             (1<<1)
+#define IMR_PRM             (1<<0)
+
+#define ISR_ROOS            (1<<3)
+#define ISR_ROS             (1<<2)
+#define ISR_PTS             (1<<1)
+#define ISR_PRS             (1<<0)
+#define ISR_CLR_STATUS      (ISR_ROOS | ISR_ROS | ISR_PTS | ISR_PRS)
+
+#define EPCR_REEP           (1<<5)
+#define EPCR_WEP            (1<<4)
+#define EPCR_EPOS           (1<<3)
+#define EPCR_ERPRR          (1<<2)
+#define EPCR_ERPRW          (1<<1)
+#define EPCR_ERRE           (1<<0)
+
+#define GPCR_GEP_CNTL       (1<<0)
+
+#define DM9000_PKT_RDY		0x01	/* Packet ready to receive */
+#define DM9000_PKT_MAX		1536	/* Received packet max size */
+
+#endif /* _DM9000X_H_ */
+
diff -urN linux-2.6.12/drivers/serial/imx.c linux-2.6.12-work/drivers/serial/imx.c
--- linux-2.6.12/drivers/serial/imx.c	2005-06-29 09:26:47.000000000 +0200
+++ linux-2.6.12-work/drivers/serial/imx.c	2005-06-29 09:22:45.000000000 +0200
@@ -293,11 +293,28 @@
 
 static unsigned int imx_get_mctrl(struct uart_port *port)
 {
-	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+        struct imx_port *sport = (struct imx_port *)port;
+        unsigned int tmp = TIOCM_DSR | TIOCM_CAR;
+
+        if (USR1((u32)sport->port.membase) & USR1_RTSS)
+                tmp |= TIOCM_CTS;
+
+        if (UCR2((u32)sport->port.membase) & UCR2_CTS)
+                tmp |= TIOCM_RTS;
+
+        return tmp;
 }
 
+
 static void imx_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
+        struct imx_port *sport = (struct imx_port *)port;
+
+        if (mctrl & TIOCM_RTS)
+                UCR2((u32)sport->port.membase) |= UCR2_CTS;
+        else
+                UCR2((u32)sport->port.membase) &= ~UCR2_CTS;
+
 }
 
 /*
@@ -839,6 +856,8 @@
 
 	imx_setup_ufcr(sport, 0);
 
+        imx_setup_ufcr(sport, 0);
+	
 	return uart_set_options(&sport->port, co, baud, parity, bits, flow);
 }
 
diff -urN linux-2.6.12/include/asm-arm/arch-imx/hardware.h linux-2.6.12-work/include/asm-arm/arch-imx/hardware.h
--- linux-2.6.12/include/asm-arm/arch-imx/hardware.h	2005-06-29 09:26:48.000000000 +0200
+++ linux-2.6.12-work/include/asm-arm/arch-imx/hardware.h	2005-06-29 09:23:04.000000000 +0200
@@ -96,4 +96,12 @@
 #include "mx1ads.h"
 #endif
 
+#ifdef CONFIG_MACH_MX1FS2
+#include "mx1fs2.h"
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+#include "scb9328.h"
+#endif
+
 #endif
diff -urN linux-2.6.12/include/asm-arm/arch-imx/mmc.h linux-2.6.12-work/include/asm-arm/arch-imx/mmc.h
--- linux-2.6.12/include/asm-arm/arch-imx/mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/include/asm-arm/arch-imx/mmc.h	2005-06-29 09:23:05.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef ASMARM_ARCH_MMC_H
+#define ASMARM_ARCH_MMC_H
+
+#include <linux/mmc/protocol.h>
+
+struct imxmmc_platform_data {
+	int (*card_present)(void);
+};
+
+extern void imx_set_mmc_info(struct imxmmc_platform_data *info);
+
+#endif
diff -urN linux-2.6.12/include/asm-arm/arch-imx/mx1fs2.h linux-2.6.12-work/include/asm-arm/arch-imx/mx1fs2.h
--- linux-2.6.12/include/asm-arm/arch-imx/mx1fs2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/include/asm-arm/arch-imx/mx1fs2.h	2005-06-29 09:23:05.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * linux/include/asm-arm/arch-imx/mx1fs2.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ */
+
+#ifndef __ASM_ARCH_MX1FS2_H
+#define __ASM_ARCH_MX1FS2_H
+
+/* ------------------------------------------------------------------------ */
+/* Memory Map for the FS2 Board                                             */
+/* ------------------------------------------------------------------------ */
+
+#define MX1FS2_FLASH_PHYS		0x10000000
+#define MX1FS2_FLASH_SIZE		(16*1024*1024)
+
+#define IMX_FB_PHYS			(0x0C000000 - 0x40000)
+
+/* external uart 1 */
+#define MX1FS2_UART1_VIRT  		( IMX_CS4_VIRT )
+#define MX1FS2_UART1_PHYS		( IMX_CS4_PHYS )
+#define MX1FS2_UART1_IRQ   		IRQ_GPIOC(10)
+
+/* external uart 2 */
+#define MX1FS2_UART2_VIRT		( IMX_CS5_VIRT )
+#define MX1FS2_UART2_PHYS		( IMX_CS5_PHYS )
+#define MX1FS2_UART2_IRQ   		IRQ_GPIOC(9)
+
+/* external LPT port */
+#define MX1FS2_LPT_VIRT    		( IMX_CS1_VIRT )
+#define MX1FS2_LPT_PHYS    		( IMX_CS1_PHYS )
+
+
+#define CLK32 32768
+
+#endif /* __ASM_ARCH_MX1FS2_H */
diff -urN linux-2.6.12/include/asm-arm/arch-imx/scb9328.h linux-2.6.12-work/include/asm-arm/arch-imx/scb9328.h
--- linux-2.6.12/include/asm-arm/arch-imx/scb9328.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/include/asm-arm/arch-imx/scb9328.h	2005-06-29 09:23:05.000000000 +0200
@@ -0,0 +1,46 @@
+ /*
+ * linux/include/asm-arm/arch-imx/scb9328.h
+ *
+ * Copyright (C) 2005 Robert Schwebel, Pengutronix
+ * Copyright (C) 2005 Sascha Hauer, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define SCB9328_UART1_VIRT  ( IMX_CS3_VIRT + 0x30000 )
+#define SCB9328_UART1_PHYS  ( IMX_CS3_PHYS + 0x30000 )
+#define SCB9328_UART1_IRQ   IRQ_GPIOA(1)
+
+#define SCB9328_UART2_VIRT  ( IMX_CS3_VIRT + 0x10000 )
+#define SCB9328_UART2_PHYS  ( IMX_CS3_PHYS + 0x10000 )
+#define SCB9328_UART2_IRQ   IRQ_GPIOA(1)
+
+#define SCB9328_ETH_VIRT ( IMX_CS5_VIRT )
+#define SCB9328_ETH_PHYS ( IMX_CS5_PHYS )
+#define SCB9328_ETH_IRQ  ( IRQ_GPIOC(3) )
+
+#define SCB9328_FLASH_PHYS	IMX_CS0_PHYS
+#define SCB9328_FLASH_SIZE	0x01000000
+#define SCB9328_FLASH_BASE	IMX_CS0_VIRT
+
+#define CLK32 32768
+
+#ifndef __ASSEMBLER__
+void scb9328_ledon(int);
+void scb9328_ledoff(int);
+
+int scb9328_get_buttons(void);
+
+#endif // _SCB9328_H
diff -urN linux-2.6.12/include/linux/dm9000.h linux-2.6.12-work/include/linux/dm9000.h
--- linux-2.6.12/include/linux/dm9000.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-work/include/linux/dm9000.h	2005-06-29 09:23:05.000000000 +0200
@@ -0,0 +1,36 @@
+/* include/linux/dm9000.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *   Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for dm9000 platform data
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#ifndef __DM9000_PLATFORM_DATA
+#define __DM9000_PLATFORM_DATA __FILE__
+
+/* IO control flags */
+
+#define DM9000_PLATF_8BITONLY	(0x0001)
+#define DM9000_PLATF_16BITONLY	(0x0002)
+#define DM9000_PLATF_32BITONLY	(0x0004)
+
+/* platfrom data for platfrom device structure's platfrom_data field */
+
+struct dm9000_plat_data {
+	unsigned int	flags;
+
+	/* allow replacement IO routines */
+
+	void	(*inblk)(void __iomem *reg, void *data, int len);
+	void	(*outblk)(void __iomem *reg, void *data, int len);
+	void	(*dumpblk)(void __iomem *reg, int len);
+};
+
+#endif /* __DM9000_PLATFORM_DATA */
+
