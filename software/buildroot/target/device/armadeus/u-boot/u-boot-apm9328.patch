diff -purN u-boot-1.1.3-ref/board/apm9328/apd9328fpga.c u-boot-1.1.3/board/apm9328/apd9328fpga.c
--- u-boot-1.1.3-ref/board/apm9328/apd9328fpga.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/apd9328fpga.c	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,100 @@
+/*
+ * (C) Copyright 2005
+ * Nicolas Colombin <thom25@users.sourceforge.net>
+ * Eric Jarrige <jorasse@users.sourceforge.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+/*
+ * Spartan 3 FPGA configuration support for the APD9328 daughter board
+ */
+
+#include <common.h>
+#include <spartan2.h>
+#include <command.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/io.h>
+#include "apd9328fpga.h"
+
+#if (CONFIG_FPGA)
+#if 0
+#define FPGA_DEBUG
+#endif
+
+#ifdef FPGA_DEBUG
+#define	PRINTF(fmt,args...)	printf (fmt ,##args)
+#else
+#define	PRINTF(fmt,args...)
+#endif
+
+/* Note that these are pointers to code that is in Flash.  They will be
+ * relocated at runtime.
+ * Spartan2 code is used to download our Spartan 3 :) code is compatible. 
+ * Just take care about the file size  
+*/
+Xilinx_Spartan2_Slave_Serial_fns fpga_fns = {
+	fpga_pre_fn,
+	fpga_pgm_fn,
+	fpga_clk_fn,
+	fpga_init_fn,
+	fpga_done_fn,
+	fpga_wr_fn,
+};
+
+Xilinx_desc fpga[CONFIG_FPGA_COUNT] = {
+	{Xilinx_Spartan2,
+	 slave_serial,
+	 XILINX_XC3S400_SIZE,
+	 (void *) &fpga_fns,
+	 0}
+};
+
+/*
+ * Initialize the fpga.  Return 1 on success, 0 on failure.
+ */
+int
+APD9328_init_fpga (void)
+{
+	char *autoload = getenv ("firmware_autoload");
+	DECLARE_GLOBAL_DATA_PTR;
+
+	int i,lout=1;
+
+	PRINTF ("%s:%d: Initialize FPGA interface (relocation offset = 0x%.8lx)\n",
+		__FUNCTION__, __LINE__, gd->reloc_off);
+	fpga_init (gd->reloc_off);
+
+	for (i = 0; i < CONFIG_FPGA_COUNT; i++) {
+		PRINTF ("%s:%d: Adding fpga %d\n", __FUNCTION__, __LINE__, i);
+		fpga_add (fpga_xilinx, &fpga[i]);
+	}
+
+	if (( autoload ) && (0 == strcmp(autoload, "1"))) {
+		if (FPGA_SUCCESS != fpga_load( 0, (void *)CONFIG_FIRMWARE_ADDR, 
+				(size_t) CONFIG_FIRMWARE_LEN )) {
+			lout = 0;
+			printf("Firmware not loaded!\n");
+		}
+	}
+	return 1;
+}
+
+#endif /* CONFIG_FPGA */
diff -purN u-boot-1.1.3-ref/board/apm9328/apd9328fpga.h u-boot-1.1.3/board/apm9328/apd9328fpga.h
--- u-boot-1.1.3-ref/board/apm9328/apd9328fpga.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/apd9328fpga.h	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2002
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+/*
+ * Spartan 3 FPGA configuration support for the APD9328 daughter board
+ */
+ 
+#include "fpga.h"
+extern int APD9328_init_fpga (void);
diff -purN u-boot-1.1.3-ref/board/apm9328/apm9328.c u-boot-1.1.3/board/apm9328/apm9328.c
--- u-boot-1.1.3-ref/board/apm9328/apm9328.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/apm9328.c	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2004 Sascha Hauer, Synertronixx GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <asm/arch/imx-regs.h>
+#include "apd9328fpga.h"
+
+extern void imx_gpio_mode (int gpio_mode);
+
+int
+board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_arch_number = CONFIG_MACH_TYPE;
+	gd->bd->bi_boot_params = CONFIG_BOOT_PARAMS_ADDR;
+
+	return 0;
+}
+
+int
+dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#if ( CONFIG_NR_DRAM_BANKS > 0 )
+	gd->bd->bi_dram[0].start = CFG_SDRAM_1_BASE;
+	gd->bd->bi_dram[0].size = CFG_SDRAM_1_SIZE;
+#endif
+#if ( CONFIG_NR_DRAM_BANKS > 1 )
+	gd->bd->bi_dram[1].start = CFG_SDRAM_2_BASE;
+	gd->bd->bi_dram[1].size = CFG_SDRAM_2_SIZE;
+#endif
+
+	return 0;
+}
+
+/*
+ * Miscellaneous intialization
+ */
+int
+misc_init_r (void)
+{
+#if (CONFIG_FPGA)
+	APD9328_init_fpga ();
+#endif
+
+#if (CONFIG_DRIVER_DM9000)
+	imx_gpio_mode (GPIO_PORTB | GPIO_GPIO | GPIO_IN | 14);
+#endif
+	return 0;
+}
+
+void
+show_boot_progress (int status)
+{
+	return;
+}
diff -purN u-boot-1.1.3-ref/board/apm9328/config.mk u-boot-1.1.3/board/apm9328/config.mk
--- u-boot-1.1.3-ref/board/apm9328/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/config.mk	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,10 @@
+#
+# This config file is used for compilation of armadeus sources
+#
+# You might change location of U-Boot in memory by setting right TEXT_BASE.
+# This allows for example having one copy located at the end of ram and stored
+# in flash device and later on while developing use other location to test
+# the code in RAM device only.
+#
+
+TEXT_BASE = 0x0BF80000
diff -purN u-boot-1.1.3-ref/board/apm9328/fpga.c u-boot-1.1.3/board/apm9328/fpga.c
--- u-boot-1.1.3-ref/board/apm9328/fpga.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/fpga.c	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,140 @@
+/*
+ * (C) Copyright 2002
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#include <common.h>
+
+#if (CONFIG_FPGA)
+
+#include <asm/arch/imx-regs.h>
+#include <asm/io.h>
+#include <config.h>
+
+extern void imx_gpio_mode (int gpio_mode);
+
+
+#define GPIO_PORT(x)  ((x >> 5) & 3)
+#define GPIO_SET(x)   (DR(GPIO_PORT(x)) |= (1<<(x & GPIO_PIN_MASK)))
+#define GPIO_CLEAR(x) (DR(GPIO_PORT(x)) &= ~(1<<(x & GPIO_PIN_MASK)))
+#define GPIO_WRITE(x,y) ( y ? GPIO_SET(x) : GPIO_CLEAR(x) )
+#define GPIO_READ(x)  ((SSR (GPIO_PORT(x)) & (1<<(x & GPIO_PIN_MASK))))
+
+#if 0
+#define FPGA_DEBUG
+#endif
+
+#ifdef FPGA_DEBUG
+#define	PRINTF(fmt,args...)	printf (fmt ,##args)
+#else
+#define	PRINTF(fmt,args...)
+#endif
+
+/*
+ * Port bit numbers for the serial slave controls
+ */
+#define FPGA_INIT	CFG_FPGA_INIT
+#define FPGA_DONE	CFG_FPGA_DONE
+#define FPGA_DIN	CFG_FPGA_DATA
+#define FPGA_PROGRAM	CFG_FPGA_PRG
+#define FPGA_CLOCK	CFG_FPGA_CLK
+
+/* Note that these are pointers to code that is in Flash.  They will be
+ * relocated at runtime.
+ * Spartan2 code is used to download our Spartan 3 :) code is compatible. 
+ * Just take care about the file size  
+*/
+
+/*
+ * nitialize GPIO port B before download
+ */
+int
+fpga_pre_fn (int cookie)
+{
+	PRINTF ("%s:%d: FPGA PRE ", __FUNCTION__, __LINE__);
+
+	// Initialize GPIO pins
+	imx_gpio_mode (FPGA_INIT | GPIO_GPIO | GPIO_IN );
+	imx_gpio_mode (FPGA_DONE | GPIO_GPIO | GPIO_IN );
+	imx_gpio_mode (FPGA_DIN  | GPIO_GPIO | GPIO_OUT );
+	imx_gpio_mode (FPGA_PROGRAM | GPIO_GPIO | GPIO_OUT );
+	imx_gpio_mode (FPGA_CLOCK | GPIO_GPIO | GPIO_OUT );
+	return cookie;
+}
+
+/*
+ * Set the FPGA's active-low program line to the specified level
+ */
+int
+fpga_pgm_fn (int assert, int flush, int cookie)
+{
+	PRINTF ("%s:%d: FPGA PROGRAM %s", __FUNCTION__, __LINE__, 
+					assert?"high":"low");
+	GPIO_WRITE( FPGA_PROGRAM, !assert);
+	return assert;
+}
+
+/*
+ * Set the FPGA's active-high clock line to the specified level
+ */
+int
+fpga_clk_fn (int assert_clk, int flush, int cookie)
+{
+	PRINTF ("%s:%d: FPGA CLOCK %s", __FUNCTION__, __LINE__, 
+					assert_clk?"high":"low");
+	GPIO_WRITE( FPGA_CLOCK, assert_clk);
+	return assert_clk;
+}
+
+/*
+ * Test the state of the active-low FPGA INIT line.  Return 1 on INIT
+ * asserted (low).
+ */
+int
+fpga_init_fn (int cookie)
+{
+	PRINTF ("%s:%d: INIT check... ", __FUNCTION__, __LINE__);
+	return(!GPIO_READ(FPGA_INIT));
+}
+
+/*
+ * Test the state of the active-high FPGA DONE pin
+ */
+int
+fpga_done_fn (int cookie)
+{
+	PRINTF ("%s:%d: DONE check... ", __FUNCTION__, __LINE__);
+	return(GPIO_READ(FPGA_DONE));
+}
+
+/*
+ * Set the FPGA's data line to the specified level
+ */
+int
+fpga_wr_fn (int assert_write, int flush, int cookie)
+{
+	PRINTF ("%s:%d: DATA write... ", __FUNCTION__, __LINE__);
+	GPIO_WRITE( FPGA_DIN, assert_write);
+	return assert_write;
+}
+
+#endif /* CONFIG_FPGA */
diff -purN u-boot-1.1.3-ref/board/apm9328/fpga.h u-boot-1.1.3/board/apm9328/fpga.h
--- u-boot-1.1.3-ref/board/apm9328/fpga.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/fpga.h	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,30 @@
+/*
+ * (C) Copyright 2002
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+extern int fpga_pre_fn (int cookie);
+extern int fpga_pgm_fn (int assert_pgm, int flush, int cookie);
+extern int fpga_init_fn (int cookie);
+extern int fpga_done_fn (int cookie);
+extern int fpga_clk_fn (int assert_clk, int flush, int cookie);
+extern int fpga_wr_fn (int assert_write, int flush, int cookie);
diff -purN u-boot-1.1.3-ref/board/apm9328/i2c.c u-boot-1.1.3/board/apm9328/i2c.c
--- u-boot-1.1.3-ref/board/apm9328/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/i2c.c	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,327 @@
+/*
+ * Eric Jarrige <jorasse@users.sourceforge.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ *
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_HARD_I2C
+
+#include <asm/io.h>
+#include <asm/arch/imx-regs.h>
+#include <i2c.h>
+
+/*#define       DEBUG_I2C*/
+
+extern void imx_gpio_mode (int gpio_mode);
+
+/*-----------------------------------------------------------------------
+ * Definitions
+ */
+
+#define I2C_ACK		0	/* level to ack a byte */
+#define I2C_NOACK	1	/* level to noack a byte */
+
+
+#ifdef DEBUG_I2C
+#define PRINTD(fmt,args...)	do {	\
+	DECLARE_GLOBAL_DATA_PTR;	\
+	if (gd->have_console)		\
+		printf (fmt ,##args);	\
+	} while (0)
+#else
+#define PRINTD(fmt,args...)
+#endif
+
+/*-----------------------------------------------------------------------
+ * Local functions
+ */
+
+/*-----------------------------------------------------------------------
+ * START: High -> Low on SDA while SCL is High
+ * after check for a bus free
+ */
+static void
+imxi2c_send_start (void)
+{
+	while ((I2SR & I2SR_IBB)) ;
+	I2CR |= I2CR_MSTA;
+	I2SR &= ~I2SR_IIF;
+}
+
+/*-----------------------------------------------------------------------
+ * STOP: Low -> High on SDA while SCL is High
+ * after the end of previous transfer
+ */
+static void
+imxi2c_send_stop (void)
+{
+	while (!(I2SR & I2SR_ICF)) ;
+	I2CR &= ~I2CR_MSTA;
+}
+
+/*-----------------------------------------------------------------------
+ * Send 8 bits and look for an acknowledgement.
+ */
+static int
+imxi2c_write_byte (uchar data)
+{
+	while (!(I2SR & I2SR_ICF)) ;	/* Wait end of transfer */
+
+	I2CR |= I2CR_MTX;
+	I2SR &= ~I2SR_IIF;
+	I2DR = data;
+
+	while (!(I2SR & I2SR_IIF)) ;	/* checking IIF before ICF seems required */
+
+	I2SR &= ~I2SR_IIF;
+
+	while (!(I2SR & I2SR_ICF)) ;	/* Wait end of transfer */
+
+	return (I2SR & I2SR_RXAK);	/* not a nack is an ack */
+}
+
+/*-----------------------------------------------------------------------
+ * if ack == I2C_ACK, ACK the byte so can continue reading, else
+ * send I2C_NOACK to end the read.
+ */
+static uchar
+imxi2c_read_byte (int ack)
+{
+	int data;
+
+	while (!(I2SR & I2SR_ICF)) ;
+	I2CR &= ~I2CR_MTX;
+
+	if (ack)
+	{
+		I2CR |= I2CR_TXAK;
+	}
+	else
+	{
+		I2CR &= ~I2CR_TXAK;
+	}
+
+	data = I2DR;
+	return (data);
+}
+
+/* ------------------------------------------------------------------------
+ * API Functions
+ * ------------------------------------------------------------------------
+ */
+
+/*-----------------------------------------------------------------------
+ * i2c_init compute the i2c divider to reach the requested speed
+ * see mxl reference manual
+ */
+void
+i2c_init (int speed, int slaveaddr)
+{
+	int hclk_dividers[] = {
+		30, 32, 36, 42, 48, 52, 60, 72,
+		80, 88, 104, 128, 144, 160, 192, 240,
+		288, 320, 384, 480, 576, 640, 768, 960,
+		1152, 1280, 1536, 1920, 2304, 2560, 3072, 3840,
+		22, 24, 26, 26, 32, 36, 40, 44,
+		48, 56, 64, 72, 80, 96, 112, 128,
+		160, 192, 224, 256, 320, 384, 448, 512,
+		640, 768, 896, 1024, 1280, 1536, 1792, 2048
+	};
+	int refDiv = get_HCLK () / speed;
+	int i, tmpIC;
+
+	imx_gpio_mode (PA15_PF_I2C_SDA);
+	imx_gpio_mode (PA16_PF_I2C_SCL);
+
+	tmpIC = (sizeof (hclk_dividers) / sizeof (int)) - 1;
+	for (i = tmpIC; i >= 0; i--)
+	{
+		if ((hclk_dividers[i] >= refDiv)
+		    && (hclk_dividers[i] < hclk_dividers[tmpIC]))
+		{
+			tmpIC = i;
+		}
+	}
+	
+	IFDR = tmpIC;
+	IADR = slaveaddr << 1;
+
+	if (I2SR & I2SR_IBB)
+		imxi2c_send_stop ();
+
+	I2CR |= I2CR_IEN;
+}
+
+/*-----------------------------------------------------------------------
+ * Probe to see if a chip is present. Also good for checking for the
+ * completion of EEPROM writes since the chip stops responding until
+ * the write completes (typically 10mSec).
+ * probe sends a read command to probe a an address
+ */
+int
+i2c_probe (uchar addr)
+{
+	int rc;
+
+	imxi2c_send_start ();
+	rc = imxi2c_write_byte ((addr << 1) | 0);
+	imxi2c_send_stop ();
+
+	return (rc ? 1 : 0);
+}
+
+/*-----------------------------------------------------------------------
+ * Read bytes
+ */
+int
+i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int shift;
+	PRINTD ("i2c_read: chip %02X addr %02X alen %d buffer %p len %d\n",
+		chip, addr, alen, buffer, len);
+
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	/*
+	 * EEPROM chips that implement "address overflow" are ones
+	 * like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	 * address and the extra bits end up in the "chip address"
+	 * bit slots. This makes a 24WC08 (1Kbyte) chip look like
+	 * four 256 byte chips.
+	 *
+	 * Note that we consider the length of the address field to
+	 * still be one byte because the extra address bits are
+	 * hidden in the chip address.
+	 */
+	chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+
+	PRINTD ("i2c_read: fix addr_overflow: chip %02X addr %02X\n",
+		chip, addr);
+#endif
+
+	/*
+	 * Do the addressing portion of a write cycle to set the
+	 * chip's address pointer. If the address length is zero,
+	 * don't do the normal write cycle to set the address pointer,
+	 * there is no address pointer in this chip.
+	 */
+	imxi2c_send_start ();
+	if (alen > 0)
+	{
+		if (imxi2c_write_byte (chip << 1))
+		{		/* write cycle */
+			imxi2c_send_stop ();
+			PRINTD ("i2c_read, no chip responded %02X\n", chip);
+			return (1);
+		}
+		shift = (alen - 1) * 8;
+		while (alen-- > 0)
+		{
+			if (imxi2c_write_byte (addr >> shift))
+			{
+				PRINTD ("i2c_read, address not <ACK>ed\n");
+				return (1);
+			}
+			shift -= 8;
+		}
+		imxi2c_send_stop ();	/* reportedly some chips need a full stop */
+		imxi2c_send_start ();
+	}
+	/*
+	 * Send the chip address again, this time for a read cycle.
+	 * Then read the data. On the last byte, we do a NACK instead
+	 * of an ACK(len == 0) to terminate the read.
+	 */
+	imxi2c_write_byte ((chip << 1) | 1);	/* read cycle */
+	imxi2c_read_byte (len <= 2);
+	while (len-- > 1)
+	{
+		*buffer++ = imxi2c_read_byte (len == 1);
+	}
+	imxi2c_send_stop ();
+	*buffer++ = imxi2c_read_byte (0);
+	return (0);
+}
+
+/*-----------------------------------------------------------------------
+ * Write bytes
+ */
+int
+i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int shift, failures = 0;
+
+	PRINTD ("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
+		chip, addr, alen, buffer, len);
+
+	imxi2c_send_start ();
+	if (imxi2c_write_byte (chip << 1))
+	{			/* write cycle */
+		imxi2c_send_stop ();
+		PRINTD ("i2c_write, no chip responded %02X\n", chip);
+		return (1);
+	}
+	shift = (alen - 1) * 8;
+	while (alen-- > 0)
+	{
+		if (imxi2c_write_byte (addr >> shift))
+		{
+			PRINTD ("i2c_write, address not <ACK>ed\n");
+			return (1);
+		}
+		shift -= 8;
+	}
+
+	while (len-- > 0)
+	{
+		if (imxi2c_write_byte (*buffer++))
+		{
+			failures++;
+		}
+	}
+	imxi2c_send_stop ();
+	return (failures);
+}
+
+/*-----------------------------------------------------------------------
+ * Read a register
+ */
+uchar
+i2c_reg_read (uchar i2c_addr, uchar reg)
+{
+	char buf;
+
+	i2c_read (i2c_addr, reg, 1, &buf, 1);
+
+	return (buf);
+}
+
+/*-----------------------------------------------------------------------
+ * Write a register
+ */
+void
+i2c_reg_write (uchar i2c_addr, uchar reg, uchar val)
+{
+	i2c_write (i2c_addr, reg, 1, &val, 1);
+}
+
+#endif /* CONFIG_HARD_I2C */
diff -purN u-boot-1.1.3-ref/board/apm9328/lowlevel_init.S u-boot-1.1.3/board/apm9328/lowlevel_init.S
--- u-boot-1.1.3-ref/board/apm9328/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/lowlevel_init.S	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2004 Sascha Hauer, Synertronixx GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/imx-regs.h>
+
+.globl lowlevel_init
+lowlevel_init:
+
+	mov	r10, lr
+
+/* Change PERCLK1DIV to 14 ie 14+1 */
+	ldr		r0,	=PCDR
+	ldr		r1,	=CFG_PCDR_VAL
+	str		r1,	[r0]
+
+/* set MCU PLL Control Register 0 */
+
+	ldr		r0,	=MPCTL0
+	ldr		r1,	=CFG_MPCTL0_VAL
+	str		r1,	[r0]
+
+/* set MCU PLL Control Register 1 */
+
+	ldr		r0,	=MPCTL1
+	ldr		r1,	=CFG_MPCTL1_VAL
+	str		r1,	[r0]
+
+/* set mpll restart bit */
+	ldr		r0, =CSCR
+	ldr		r1, [r0]
+	orr		r1,r1,#(1<<21)
+	str		r1, [r0]
+
+	mov		r2,#0x10
+1:
+	mov		r3,#0x2000
+2:
+	subs	r3,r3,#1
+	bne		2b
+
+	subs	r2,r2,#1
+	bne		1b
+
+/* set System PLL Control Register 0 */
+
+	ldr		r0,	=SPCTL0
+	ldr		r1,	=CFG_SPCTL0_VAL
+	str		r1,	[r0]
+
+/* set System PLL Control Register 1 */
+
+	ldr		r0,	=SPCTL1
+	ldr		r1,	=CFG_SPCTL1_VAL
+	str		r1,	[r0]
+
+/* set spll restart bit */
+	ldr		r0, =CSCR
+	ldr		r1, [r0]
+	orr		r1,r1,#(1<<22)
+	str		r1, [r0]
+
+	mov		r2,#0x10
+1:
+	mov		r3,#0x2000
+2:
+	subs	r3,r3,#1
+	bne		2b
+
+	subs	r2,r2,#1
+	bne		1b
+
+	ldr		r0,	=CSCR
+	ldr		r1,	=CFG_CSCR_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=GPCR
+	ldr		r1,	=CFG_GPCR_VAL
+	str		r1,	[r0]
+
+/* I have now read the ARM920 DataSheet back-to-Back, and have stumbled upon
+ *this.....
+ *
+ * It would appear that from a Cold-Boot the ARM920T enters "FastBus" mode CP15
+ * register 1, this stops it using the output of the PLL and thus runs at the
+ * slow rate. Unless you place the Core into "Asynch" mode, the CPU will never
+ * use the value set in the CM_OSC registers...regardless of what you set it
+ * too!  Thus, although i thought i was running at 140MHz, i'm actually running
+ * at 40!..
+
+ * Slapping this into my bootloader does the trick...
+
+ * MRC p15,0,r0,c1,c0,0	 ; read core configuration register
+ * ORR r0,r0,#0xC0000000	; set asynchronous clocks and not fastbus mode
+ * MCR p15,0,r0,c1,c0,0	 ; write modified value to core configuration
+ * register
+ */
+	MRC p15,0,r0,c1,c0,0
+	ORR r0,r0,#0xC0000000
+	MCR p15,0,r0,c1,c0,0
+
+/*	ldr		r0,	=GPR(0) 
+	ldr		r1,	=CFG_GPR_A_VAL
+	str		r1,	[r0]
+*/
+	ldr		r0,	=GIUS(0)
+	ldr		r1,	=CFG_GIUS_A_VAL
+	str		r1,	[r0]
+
+/* CS3 becomes CS3 by clearing reset default bit 1 in FMCR */
+
+	ldr		r0,	=FMCR
+	ldr		r1,	=CFG_FMCR_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS0U
+	ldr		r1,	=CFG_CS0U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS0L
+	ldr		r1,	=CFG_CS0L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS1U
+	ldr		r1,	=CFG_CS1U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS1L
+	ldr		r1,	=CFG_CS1L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS2U
+	ldr		r1,	=CFG_CS2U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS2L
+	ldr		r1,	=CFG_CS2L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS3U
+	ldr		r1,	=CFG_CS3U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS3L
+	ldr		r1,	=CFG_CS3L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS4U
+	ldr		r1,	=CFG_CS4U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS4L
+	ldr		r1,	=CFG_CS4L_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS5U
+	ldr		r1,	=CFG_CS5U_VAL
+	str		r1,	[r0]
+
+	ldr		r0,	=CS5L
+	ldr		r1,	=CFG_CS5L_VAL
+	str		r1,	[r0]
+
+	adr	r0, lowlevel_init	/* r0 <- current position of code */
+	ldr	r1, =CFG_SDRAM_1_BASE	/* test if we run from flash or RAM */
+	cmp	r1, r0		/* don't reloc during debug*/
+	bhi		sdramsetup
+	ldr	r1, =CFG_FLASH_BASE	/* test if we run from flash or RAM */
+	cmp	r0, r1		/* don't reloc during debug */
+	bmi		endofmemsetup
+
+/* SDRAM Setup */
+sdramsetup:
+	ldr		r0, =SDCTL0
+	ldr		r1, =CFG_PRECHARGE_CMD
+	str		r1,	[r0]
+
+	ldr		r1, =CFG_SDRAM_1_BASE+CFG_SDRAM_PRECHARGE_ALL_VAL
+	ldr		r2,	[r1]
+
+	ldr		r1, =CFG_AUTOREFRESH_CMD
+	str		r1,	[r0]
+
+	ldr		r1, =CFG_SDRAM_1_BASE
+	ldr		r2,	[r1] /* Issue AutoRefresh Command */
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+	ldr		r2,	[r1]
+
+	ldr		r1, =CFG_SET_MODE_REG_CMD
+	str		r1,	[r0]
+
+	ldr		r1, =CFG_SDRAM_1_BASE+CFG_SDRAM_MODE_REGISTER_VAL
+	str		r2,	[r1]
+
+	ldr		r1, =CFG_NORMAL_RW_CMD 
+	str		r1,	[r0]
+
+endofmemsetup:
+	mov	pc,r10
diff -purN u-boot-1.1.3-ref/board/apm9328/Makefile u-boot-1.1.3/board/apm9328/Makefile
--- u-boot-1.1.3-ref/board/apm9328/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/Makefile	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= apm9328.o i2c.o apd9328fpga.o fpga.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -purN u-boot-1.1.3-ref/board/apm9328/u-boot.lds u-boot-1.1.3/board/apm9328/u-boot.lds
--- u-boot-1.1.3-ref/board/apm9328/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/board/apm9328/u-boot.lds	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+		cpu/arm920t/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -purN u-boot-1.1.3-ref/common/spartan2.c u-boot-1.1.3/common/spartan2.c
--- u-boot-1.1.3-ref/common/spartan2.c	2005-12-04 15:32:23.000000000 +0100
+++ u-boot-1.1.3/common/spartan2.c	2005-12-04 15:45:17.000000000 +0100
@@ -516,7 +516,7 @@ static int Spartan2_ss_load (Xilinx_desc
 				(*fn->clk) (FALSE, TRUE, cookie);
 				CONFIG_FPGA_DELAY ();
 				/* Write data */
-				(*fn->wr) ((val < 0), TRUE, cookie);
+				(*fn->wr) (val & 0x80, TRUE, cookie);
 				CONFIG_FPGA_DELAY ();
 				/* Assert the clock */
 				(*fn->clk) (TRUE, TRUE, cookie);
@@ -554,7 +554,7 @@ static int Spartan2_ss_load (Xilinx_desc
 			putc ('*');
 
 			if (get_timer (ts) > CFG_FPGA_WAIT) {	/* check the time */
-				puts ("** Timeout waiting for DONE to clear.\n");
+				puts ("** Timeout waiting for DONE.\n");
 				ret_val = FPGA_FAIL;
 				break;
 			}
diff -purN u-boot-1.1.3-ref/cpu/arm920t/imx/interrupts.c u-boot-1.1.3/cpu/arm920t/imx/interrupts.c
--- u-boot-1.1.3-ref/cpu/arm920t/imx/interrupts.c	2005-12-04 15:32:23.000000000 +0100
+++ u-boot-1.1.3/cpu/arm920t/imx/interrupts.c	2005-12-04 15:45:17.000000000 +0100
@@ -60,7 +60,7 @@ void reset_timer (void)
 
 ulong get_timer (ulong base)
 {
-	return get_timer_masked ();
+	return get_timer_masked () - base;
 }
 
 void set_timer (ulong t)
diff -purN u-boot-1.1.3-ref/cpu/arm920t/imx/speed.c u-boot-1.1.3/cpu/arm920t/imx/speed.c
--- u-boot-1.1.3-ref/cpu/arm920t/imx/speed.c	2005-12-04 15:32:23.000000000 +0100
+++ u-boot-1.1.3/cpu/arm920t/imx/speed.c	2005-12-04 16:21:08.000000000 +0100
@@ -36,33 +36,27 @@
  * the specified bus in HZ.
  */
 /* ------------------------------------------------------------------------- */
-
-ulong get_systemPLLCLK(void)
+static ulong get_PLLCLK(u32 sys_clk_freq, u32 pllctl0)
 {
 	/* FIXME: We assume System_SEL = 0 here */
-	u32 spctl0 = SPCTL0;
-	u32 mfi = (spctl0 >> 10) & 0xf;
-	u32 mfn = spctl0 & 0x3f;
-	u32 mfd = (spctl0 >> 16) & 0x3f;
-	u32 pd =  (spctl0 >> 26) & 0xf;
+	u32 mfi = (pllctl0 >> 10) & 0xf;
+	u32 mfn = pllctl0 & 0x3ff;
+	u32 mfd = (pllctl0 >> 16) & 0x3ff;
+	u32 pd =  (pllctl0 >> 26) & 0xf;
 
 	mfi = mfi<=5 ? 5 : mfi;
+/*	return (2*(CONFIG_SYSPLL_CLK_FREQ>>10)*( (mfi<<10) + (mfn<<10)/(mfd+1)))/(pd+1);*/
+	return (2*(u64)sys_clk_freq* (mfi*(mfd+1) + mfn))/((mfd+1)*(pd+1));
+}
 
-	return (2*(CONFIG_SYSPLL_CLK_FREQ>>10)*( (mfi<<10) + (mfn<<10)/(mfd+1)))/(pd+1);
+ulong get_systemPLLCLK(void)
+{
+	return (get_PLLCLK(CONFIG_SYSPLL_CLK_FREQ, SPCTL0));
 }
 
 ulong get_mcuPLLCLK(void)
 {
-	/* FIXME: We assume System_SEL = 0 here */
-	u32 mpctl0 = MPCTL0;
-	u32 mfi = (mpctl0 >> 10) & 0xf;
-	u32 mfn = mpctl0 & 0x3f;
-	u32 mfd = (mpctl0 >> 16) & 0x3f;
-	u32 pd =  (mpctl0 >> 26) & 0xf;
-
-	mfi = mfi<=5 ? 5 : mfi;
-
-	return (2*(CONFIG_SYS_CLK_FREQ>>10)*( (mfi<<10) + (mfn<<10)/(mfd+1)))/(pd+1);
+	return (get_PLLCLK(CONFIG_SYS_CLK_FREQ, MPCTL0));
 }
 
 ulong get_FCLK(void)
@@ -74,7 +68,6 @@ ulong get_FCLK(void)
 ulong get_HCLK(void)
 {
 	u32 bclkdiv = (( CSCR >> 10 ) & 0xf) + 1;
-	printf("bclkdiv: %d\n", bclkdiv);
 	return get_systemPLLCLK() / bclkdiv;
 }
 
diff -purN u-boot-1.1.3-ref/drivers/dm9000x.c u-boot-1.1.3/drivers/dm9000x.c
--- u-boot-1.1.3-ref/drivers/dm9000x.c	2005-12-04 15:32:25.000000000 +0100
+++ u-boot-1.1.3/drivers/dm9000x.c	2005-11-27 20:55:22.000000000 +0100
@@ -100,6 +100,8 @@ static int dm9000_probe(void);
 static u16 phy_read(int);
 static void phy_write(int, u16);
 static u16 read_srom_word(int);
+static void write_srom_word(int offset, u16 val);
+static void program_eeprom(char* mac_addr);
 static u8 DM9000_ior(int);
 static void DM9000_iow(int reg, u8 value);
 
@@ -124,7 +126,7 @@ dump_regs(void)
 	DM9000_DBG("TSRII (0x04): %02x\n", DM9000_ior(4));
 	DM9000_DBG("RCR   (0x05): %02x\n", DM9000_ior(5));
 	DM9000_DBG("RSR   (0x06): %02x\n", DM9000_ior(6));
-	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(ISR));
+	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(DM9000_ISR));
 	DM9000_DBG("\n");
 }
 #endif				/*  */
@@ -274,8 +276,18 @@ int
 eth_init(bd_t * bd)
 {
 	int i, oft, lnk;
+	unsigned char env_enetaddr[6];
+	char *tmp = getenv ("ethaddr");
+	char *end;
+
 	DM9000_DBG("eth_init()\n");
 
+	for (i=0; i<6; i++) {
+		env_enetaddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
+		if (tmp)
+			tmp = (*end) ? end+1 : end;
+	}
+
 	/* RESET device */
 	dm9000_reset();
 	dm9000_probe();
@@ -302,9 +314,43 @@ eth_init(bd_t * bd)
 	/* Set Node address */
 	for (i = 0; i < 6; i++)
 		((u16 *) bd->bi_enetaddr)[i] = read_srom_word(i);
+
+	if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6) != 0 &&
+	    memcmp(env_enetaddr, bd->bi_enetaddr, 6) != 0) {
+		printf ("\nWarning: MAC addresses don't match:\n");
+		printf ("\tHW MAC address:  "
+			"%02X:%02X:%02X:%02X:%02X:%02X\n",
+			bd->bi_enetaddr[0], bd->bi_enetaddr[1],
+			bd->bi_enetaddr[2], bd->bi_enetaddr[3],
+			bd->bi_enetaddr[4], bd->bi_enetaddr[5] );
+		printf ("\t\"ethaddr\" value: "
+			"%02X:%02X:%02X:%02X:%02X:%02X\n",
+			env_enetaddr[0], env_enetaddr[1],
+			env_enetaddr[2], env_enetaddr[3],
+			env_enetaddr[4], env_enetaddr[5]) ;
+		program_eeprom(env_enetaddr);
+		debug ("### Set MAC addr from environment\n");
+		memcpy (bd->bi_enetaddr, env_enetaddr, 6);
+	}
+	if (!tmp) {
+		char ethaddr[20];
+		sprintf (ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+			 bd->bi_enetaddr[0], bd->bi_enetaddr[1],
+			 bd->bi_enetaddr[2], bd->bi_enetaddr[3],
+			 bd->bi_enetaddr[4], bd->bi_enetaddr[5]) ;
+		debug ("### Set environment from HW MAC addr = \"%s\"\n", ethaddr);
+		setenv ("ethaddr", ethaddr);
+	}
+
+
 	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
 	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
 	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
+	/*printf("FLASH:"); 
+	for (i = 0; i < 8; i++)
+		printf(" 0x%02X", read_srom_word(i));
+	printf("\n"); */
+
 	for (i = 0, oft = 0x10; i < 6; i++, oft++)
 		DM9000_iow(oft, bd->bi_enetaddr[i]);
 	for (i = 0, oft = 0x16; i < 8; i++, oft++)
@@ -530,6 +576,45 @@ read_srom_word(int offset)
 }
 
 /*
+ * Write a word data to SROM
+ */
+static void
+write_srom_word(int offset, u16 val)
+{
+	DM9000_iow(DM9000_EPAR, offset);
+	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
+	DM9000_iow(DM9000_EPDRL, (val & 0xff));
+	DM9000_iow(DM9000_EPCR, 0x12);
+	udelay(8000);		/* same shit */
+	DM9000_iow(DM9000_EPCR, 0);
+}
+
+/*
+ * Only for development:
+ * Here we write static data to the eeprom in case
+ * we don't have valid content on a new board
+ */
+static void
+program_eeprom(char* mac_addr)
+{
+	u16 eeprom[] = { 0x8180, 0x8382, 0x8584,	/* MAC Address */
+		0x0000 /*0x1455*/,		/* Autoload: accept nothing */
+		0x0a46, 0x9000,	/* 0x0a46, 0x9000 Vendor / Product ID */
+		0x01E6,		/* 0x0016 pin control */
+		0x0180,		/* 0x0180 Wake-up mode control, PHY DIS*/
+		0, 0, 0, 0
+	};			
+	u16* tmp = mac_addr;
+	int i;
+	for (i = 0; i < 3; i++)
+		eeprom[i] = *tmp++;
+	for (i = 0; i < 12; i++)
+		write_srom_word(i, eeprom[i]);
+}
+
+
+
+/*
    Read a byte from I/O port
 */
 static u8
diff -purN u-boot-1.1.3-ref/examples/Makefile u-boot-1.1.3/examples/Makefile
--- u-boot-1.1.3-ref/examples/Makefile	2005-12-04 15:32:26.000000000 +0100
+++ u-boot-1.1.3/examples/Makefile	2005-12-04 15:45:17.000000000 +0100
@@ -30,7 +30,7 @@ LOAD_ADDR = 0x40000
 endif
 
 ifeq ($(ARCH),arm)
-LOAD_ADDR = 0xc100000
+LOAD_ADDR = 0x8000000
 endif
 
 ifeq ($(ARCH),mips)
@@ -56,7 +56,8 @@ endif
 include $(TOPDIR)/config.mk
 
 SREC	= hello_world.srec
-BIN	= hello_world.bin hello_world
+BIN	= hello_world.bin hello_world
+# tftploadscripts.img testcmds.img
 
 ifeq ($(CPU),mpc8xx)
 SREC	= test_burst.srec
@@ -129,6 +130,10 @@ $(LIB): .depend $(LIBOBJS)
 %.bin:	%
 	$(OBJCOPY) -O binary $< $@ 2>/dev/null
 
+%.img:	%.txt
+	mkimage -T script -C none -n '$@ Script File' -d  $^ $@
+
+
 #########################################################################
 
 .depend:	Makefile $(OBJS:.o=.c) $(LIBCOBJS:.o=.c) $(LIBAOBJS:.o=.S)
diff -purN u-boot-1.1.3-ref/examples/testcmds.txt u-boot-1.1.3/examples/testcmds.txt
--- u-boot-1.1.3-ref/examples/testcmds.txt	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/examples/testcmds.txt	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,17 @@
+setenv load_addr 08020000
+setenv test_script 'tftp  $load_addr /tftpboot/u-boot/examples/testcmds.img; auto $load_addr'
+echo ===== test toolsettings ===== 
+setenv test_addr 10040000
+setenv test_len 020000
+setenv test_path /tftpboot/u-boot/u-boot.bin
+setenv load_test 'tftp $load_addr $test_path;'
+setenv install_test 'era $test_addr +$test_len; if cp.b $fileaddr $test_addr $filesize; then echo test update succeed; else echo test update failed; fi'
+
+setenv run_test 'go 10040000'
+
+setenv update_test run load_test install_test 
+run update_test
+echo ===== Save new definitions =====
+setenv load_addr 08000000
+saveenv
+run run_test
diff -purN u-boot-1.1.3-ref/examples/tftploadscripts.txt u-boot-1.1.3/examples/tftploadscripts.txt
--- u-boot-1.1.3-ref/examples/tftploadscripts.txt	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/examples/tftploadscripts.txt	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,27 @@
+setenv load_addr 08000000
+setenv tftp_script 'tftp  $load_addr /tftpboot/u-boot/examples/tftploadscripts.img; auto $load_addr'
+echo ===== U-Boot settings ===== 
+setenv uboot_path /tftpboot/u-boot/u-boot.bin
+setenv load_uboot 'mw.b $load_addr FF $uboot_len; tftp $load_addr $uboot_path;'
+setenv update_uboot run load_uboot flash_uboot
+echo ===== Linux Firmware settings =====
+setenv firmware_path /tftpboot/dev/firmware.img
+setenv load_firmware 'mw.b $load_addr FF $firmware_len; tftp $load_addr $firmware_path;'
+setenv update_firmware run load_firmware flash_firmware
+echo ===== Linux Kernel settings =====
+setenv kernel_path /tftpboot/linux-2.6.12/arch/arm/boot/uImage
+setenv load_kernel 'mw.b $load_addr FF $kernel_len; tftp $load_addr $kernel_path;'
+setenv update_kernel run load_kernel flash_kernel
+echo ===== Rootfs settings =====
+setenv rootfs_path /tftpboot/buildroot/root_fs_arm_nofpu.jffs2
+setenv load_rootfs 'mw.b $load_addr FF $rootfs_len; tftp $load_addr $rootfs_path;'
+setenv update_rootfs run load_rootfs flash_rootfs
+echo ===== allinone settings =====
+setenv update_all run update_kernel update_rootfs update_uboot update_firmware
+echo ===== env settings =====
+setenv erase_env 'protect off $env_addr +$env_len; era $env_addr +$env_len'
+echo ===== tftp ram boot settings =====
+setenv netfull 'tftp 08800000 /tftpboot/fullimage.img;setenv bootargs root=/dev/ram rw rootfstype=ext2 $console $mtdparts;bootm 08800000'
+setenv netroot 'tftp 08400000 /tftpboot/buildroot/root_fs_arm_nofpu.ext2.gz.img;setenv bootargs root=/dev/ram rw rootfstype=ext2 $console $mtdparts;bootm 100A0000 08400000'
+echo ===== Save new definitions =====
+saveenv
diff -purN u-boot-1.1.3-ref/include/asm-arm/arch-imx/imx-regs.h u-boot-1.1.3/include/asm-arm/arch-imx/imx-regs.h
--- u-boot-1.1.3-ref/include/asm-arm/arch-imx/imx-regs.h	2005-12-04 15:32:26.000000000 +0100
+++ u-boot-1.1.3/include/asm-arm/arch-imx/imx-regs.h	2005-12-04 15:45:17.000000000 +0100
@@ -573,5 +573,27 @@
 #define TPRER_PRES     (0xff)  /* Prescale */
 #define TSTAT_CAPT     (1<<1)  /* Capture event */
 #define TSTAT_COMP     (1)     /* Compare event */
+/*
+ * I2C module
+ */
+#define IADR   __REG(IMX_I2C_BASE + 0x000) /* I2C Address Register */
+#define IFDR   __REG(IMX_I2C_BASE + 0x004) /* I2C Frequency Divider Register*/
+#define I2CR   __REG(IMX_I2C_BASE + 0x008) /* I2C Control Register */
+#define I2SR   __REG(IMX_I2C_BASE + 0x00C) /* I2C Status Register */
+#define I2DR   __REG(IMX_I2C_BASE + 0x010) /* I2C Data I/O Register */
+/* I2C Control Register Bit Fields */
+#define I2CR_IEN 	(1<<7)		/* I2C Enable */
+#define I2CR_IIEN 	(1<<6)		/* I2C Interrupt Enable */
+#define I2CR_MSTA 	(1<<5)		/* I2C Master/Slave Mode Select */
+#define I2CR_MTX 	(1<<4)		/* I2C Transmit/Receive Mode Select */
+#define I2CR_TXAK 	(1<<3)		/* I2C Transmit Acknowledge Enable */
+#define I2CR_RSTA 	(1<<2)		/* I2C Repeated START */
+#define I2SR_ICF 	(1<<7)		/* I2C Data Transfer */
+#define I2SR_IAAS 	(1<<6)		/* I2C Addressed As a Slave */
+#define I2SR_IBB 	(1<<5)		/* I2C Bus Busy */
+#define I2SR_IAL 	(1<<4)		/* I2C Arbitration Lost */
+#define I2SR_SRW 	(1<<2)		/* I2C Slave Read/Write	*/
+#define I2SR_IIF 	(1<<1)		/* I2C interrupt */
+#define I2SR_RXAK 	(1<<0)		/* I2C Received Acknowledge */
 
 #endif				/* _IMX_REGS_H */
diff -purN u-boot-1.1.3-ref/include/configs/apm9328.h u-boot-1.1.3/include/configs/apm9328.h
--- u-boot-1.1.3-ref/include/configs/apm9328.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/include/configs/apm9328.h	2005-12-04 15:44:11.000000000 +0100
@@ -0,0 +1,864 @@
+/*
+ * Eric Jarrige <jorasse@users.sourceforge.net>
+ *
+ * Configuation settings for the Armadeus Project motherboard 9328 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * 2005/01/14 Initial version taken from the scb9328 configuration file
+ * 2005/03/10 APM9328 configuration file and trial to improve of
+ *		hardware register control.
+ * 2005/08/16 added APD9328 fpgas and ethernet
+ * 2005/12/02 added filesystem boot over NFS
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	" apm9328 patch 2.3"
+
+#define CONFIG_ARM920T		1	/* this is an ARM920T CPU */
+#define CONFIG_IMX		1	/* in a Motorola MC9328MXL Chip */
+#define CONFIG_APM9328		1	/* on a Armadeus project board */
+#undef	CONFIG_USE_IRQ		/* don't need use IRQ/FIQ */
+
+/*
+ * Enable the call to misc_init_r() for miscellaneous platform
+ * dependent initialization.
+ */
+
+#define CONFIG_MISC_INIT_R
+
+/*
+ * Select serial console configuration
+ */
+#define CONFIG_IMX_SERIAL1
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200, 230400 }
+#define CONFIG_BAUDRATE 	115200
+
+/*
+ * Definition of u-boot build in commands. Check out CONFIG_CMD_DFL if
+ * neccessary in include/cmd_confdefs.h file. (Un)comment for getting
+ * functionality or size of u-boot code.
+ */
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL		\
+				| CFG_CMD_NET		\
+				| CFG_CMD_PING		\
+				| CFG_CMD_DHCP		\
+				| CFG_CMD_JFFS2		\
+				| CFG_CMD_I2C		\
+				| CFG_CMD_EEPROM	\
+				| CONFIG_CMD_ALL	\
+				)
+
+#include <cmd_confdefs.h>
+
+/*
+ * Select some advanced features of the commande line parser
+ */
+#define CONFIG_AUTO_COMPLETE 	1	/* Enable auto completion of */
+					/* commands using TAB */
+#define CFG_HUSH_PARSER		1	/* enable the "hush" shell */
+#define CFG_PROMPT_HUSH_PS2	"> "	/* secondary prompt string */
+
+/* eval_board=evk9328
+ * Boot options. Setting delay to -1 stops autostart count down.
+ */
+#define CONFIG_BOOTDELAY	20
+
+#define CONFIG_BOOTARGS \
+	CONFIG_CONSOLE " root=/dev/mtdblock4 rootfstype=jffs2 "CONFIG_MTDPARTS
+
+#define CONFIG_CONSOLE "console=ttySMX0,"MK_STR(CONFIG_BAUDRATE)"n8"
+#define CONFIG_MTDPARTS "mtdparts=scb9328_flash:256k(U-boot)ro,128k(U-boot_env)"\
+			",256k(firmware),1536k(kernel),5632k(root),-(fs)"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"fileaddr="		MK_STR(CFG_LOAD_ADDR)		"\0"	\
+	"filesize="		MK_STR(CFG_MONITOR_LEN)		"\0"	\
+	"console="		CONFIG_CONSOLE			"\0"	\
+	"mtdparts="		CONFIG_MTDPARTS			"\0"	\
+	"uboot_addr="		MK_STR(CFG_MONITOR_BASE)	"\0"	\
+	"uboot_len="		MK_STR(CFG_MONITOR_LEN)		"\0"	\
+	"env_addr="		MK_STR(CFG_ENV_ADDR)		"\0"	\
+	"env_len="		MK_STR(CFG_ENV_SIZE)		"\0"	\
+	"firmware_addr="	MK_STR(CONFIG_FIRMWARE_ADDR)	"\0"	\
+	"firmware_len="		MK_STR(CONFIG_FIRMWARE_LEN)	"\0"	\
+	"kernel_addr="		MK_STR(CONFIG_KERNEL_ADDR)	"\0"	\
+	"kernel_len="		MK_STR(CONFIG_KERNEL_LEN)	"\0"	\
+	"rootfs_addr="		MK_STR(CONFIG_ROOTFS_ADDR)	"\0"	\
+	"rootfs_len="		MK_STR(CONFIG_ROOTFS_LEN)	"\0"	\
+	"addnfsargs=setenv bootargs ${bootargs} "			\
+		"root=/dev/nfs rw nfsroot=${serverip}:${rootpath}\0"    \
+	"addjffsargs=setenv bootargs ${bootargs} "			\
+		"root=/dev/mtdblock4 rootfstype=jffs2\0"   		\
+	"addipargs=setenv bootargs ${bootargs} "			\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}::off \0"\
+	"nfsboot=setenv bootargs ${console} ${mtdparts};"		\
+		"run addnfsargs addipargs; bootm ${kernel_addr}\0"	\
+	"jffsboot=setenv bootargs ${console} ${mtdparts};"		\
+		"run addjffsargs addipargs; bootm ${kernel_addr}\0"	\
+	"firmware_autoload=0\0"						\
+	"flash_uboot=protect off ${uboot_addr} +${uboot_len};"		\
+		"era ${uboot_addr} +${uboot_len};"			\
+		"if cp.b ${fileaddr} ${uboot_addr} ${filesize};"	\
+			"then protect on ${uboot_addr} +${uboot_len};"	\
+				"echo Flashing uboot succeed;"		\
+			"else echo Flashing uboot failed;"		\
+		"fi; \0"						\
+	"flash_firmware=era ${firmware_addr} +${firmware_len};"		\
+		"if cp.b ${fileaddr} ${firmware_addr} ${filesize} ;"	\
+			"then echo Flashing Firmware succeed;"		\
+			"else echo Flashing Firmware failed;"		\
+		"fi\0"							\
+	"flash_kernel=era ${kernel_addr} +${kernel_len};"		\
+		"if cp.b ${fileaddr} ${kernel_addr} ${filesize} ;"	\
+			"then echo Flashing kernel succeed;"		\
+			"else echo Flashing kernel failed;"		\
+		"fi\0"							\
+	"flash_rootfs=era ${rootfs_addr} +${rootfs_len};"		\
+		"if cp.b ${fileaddr} ${rootfs_addr} ${filesize};"	\
+			"then echo Flashing rootfs succeed;"		\
+			"else echo Flashing rootfs failed;"		\
+		"fi\0"							\
+
+#define CONFIG_BOOTCOMMAND	"run jffsboot"
+#define CFG_AUTOLOAD		"yes"
+
+#define CONFIG_MACH_TYPE	MACH_TYPE_SCB9328
+#define CONFIG_BOOT_PARAMS_ADDR	0x08000100
+
+//#define CONFIG_SHOW_BOOT_PROGRESS
+
+#define CONFIG_ETHADDR		00:0E:32:00:00:01
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_IPADDR		192.168.000.2
+#define CONFIG_HOSTNAME		"apm9328dev"
+#define CONFIG_GATEWAYIP	192.168.000.1
+#define CONFIG_SERVERIP		192.168.000.1
+#define CONFIG_ROOTPATH		"/tftpboot/root"
+
+/*
+ * General options for u-boot. Modify to save memory foot print
+ */
+#define CFG_LONGHELP
+#define CFG_PROMPT		"BIOS> "	/* prompt string      */
+#define CFG_CBSIZE		256		/* console I/O buffer */
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)	/* print buffer size  */
+#define CFG_MAXARGS		16		/* max command args   */
+#define CFG_BARGSIZE		CFG_CBSIZE	/* boot args buf size */
+
+#define CFG_MEMTEST_START	0x08000000	/* memtest test area  */
+#define CFG_MEMTEST_END		0x08700000
+
+#undef	CFG_CLKS_IN_HZ				/* use HZ for freq. display  */
+#define CFG_HZ			1000000		/* incrementer freq: 1 MHz   */
+/*
+ * Definitions related to passing arguments to kernel.
+ */
+#define CONFIG_CMDLINE_TAG	1	/* send commandline to Kernel        */
+#define CONFIG_SETUP_MEMORY_TAGS 1	/* send memory definition to kernel */
+#define CONFIG_INITRD_TAG	1	/* send initrd params                */
+#undef	CONFIG_VFD			/* do not send framebuffer setup    */
+
+/*
+ * Malloc pool need to host env + 128 Kb reserve for other allocations.
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + (128<<10) )
+
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+#define CONFIG_STACKSIZE	(120<<10)	/* stack size                 */
+
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4<<10)		/* IRQ stack                  */
+#define CONFIG_STACKSIZE_FIQ	(4<<10)		/* FIQ stack                  */
+#endif
+
+/*
+* Clocks configuration
+*/
+/*
+ * PLL configuration
+
+   f_{dpll}=2*f{ref}*(MFI+MFN/(MFD+1))/(PD+1)
+   f_ref=16,777216MHz
+   32768 Hz xtal
+   0x07B32DA5: 192.0000173
+   0x002a141f: 191,9944MHz
+   0x040b2007: 144MHz
+   0x0FB32DA5: 96.00000864 MHz
+   0x042a141f: 96MHz
+   0x0811140d: 64MHz
+   0x040e200e: 150MHz
+   0x00321431: 200MHz
+
+  16 MHz xtal 
+   0x08001800: 64MHz mit 16er Quarz
+   0x04001800: 96MHz mit 16er Quarz
+   0x04002400: 144MHz mit 16er Quarz
+
+   31 |x x x x|x x x x|x x x x|x x x x|x x x x|x x x x|x x x x|x x x x| 0
+      |XXX|--PD---|-------MFD---------|XXX|--MFI--|-----MFN-----------|
+ */
+
+#define CFG_OSC32	32768	/* 32768 or 32000 Hz crystal */
+#undef  CFG_OSC16		/* there is no external 16MHz external clock */
+
+/* MPU CLOCK source before PLL  (should be named CFG_SYS_CLK_FREQ) */
+#define CONFIG_SYS_CLK_FREQ	(512*CFG_OSC32)
+#define CFG_MPCTL0_VAL		0x07B32DA5	/* 192.000017 MHz */
+#define CFG_MPCTL1_VAL		0
+
+/* system clock source before PLL (should be named CFG_SYSPLL_CLK_FREQ) */
+#ifndef CFG_OSC16
+#define CONFIG_SYSPLL_CLK_FREQ	(512*CFG_OSC32)
+#if (CFG_OSC32 == 32000)
+#define CFG_SPCTL0_VAL		0x043F1437	/* 96 MHz */
+#define CFG_SPCTL1_VAL		0
+#define CONFIG_SYS_FREQ		96		/* MHz */
+#else /* CFG_OSC32 == 32768*/
+#define CFG_SPCTL0_VAL		0x0FB32DA5	/* 96.000009 MHz */
+#define CFG_SPCTL1_VAL		0
+#define CONFIG_SYS_FREQ		96		/* MHz */
+#endif /* CFG_OSC32 */
+#else /* CFG_OSC16 in use*/
+#define CONFIG_SYSPLL_CLK_FREQ	CFG_OSC16
+#define CFG_SPCTL0_VAL		0x04001401	/* 96 MHz */
+#define CFG_SPCTL1_VAL		0x0C000040
+#define CONFIG_SYS_FREQ		96		/* MHz */
+#endif /* CFG_OSC16 */
+
+/* external bus frequency (have to be a CONFIG_SYS_FREQ ratio) */
+#define CONFIG_SYS_BUS_FREQ 	96	/* 96|48... MHz (BCLOCK and HCLOCK) */
+#define CONFIG_USB_FREQ		48	/* 48 MHz */
+#define CONFIG_PERIF1_FREQ	16	/* 16 MHz UART, Timer PWM*/
+#define CONFIG_PERIF2_FREQ 48	/* 48 MHz LCD SD SPI*/
+#define CONFIG_PERIF3_FREQ	16	/* 16 MHz SSI*/
+
+
+/*
+ * SDRAM definition parameter
+ */
+#define CONFIG_NR_DRAM_BANKS	1	/* we have and support only 1 bank of SDRAM */
+
+#define CFG_SDRAM_MBYTE_SYZE 32
+
+#if (CFG_SDRAM_MBYTE_SYZE == 8)
+/* micron 8MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits         */
+#define CFG_SDRAM_1_SIZE	0x00800000 /* 8 MB                */
+#define CFG_SDRAM_NUM_COL		8  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		11 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		2  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+#if (CFG_SDRAM_MBYTE_SYZE == 16)
+/* micron 16MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits    */
+#define CFG_SDRAM_1_SIZE	0x01000000 /* 16 MB                   */
+#define CFG_SDRAM_NUM_COL		8  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		12 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		2  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+#if (CFG_SDRAM_MBYTE_SYZE == 32)
+/* micron 32MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits    */
+#define CFG_SDRAM_1_SIZE	0x02000000 /* 32 MB                   */
+#define CFG_SDRAM_NUM_COL		9  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		12 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		2  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+#if (CFG_SDRAM_MBYTE_SYZE == 64)
+/* micron 64MB */
+#define CFG_SDRAM_1_BASE	0x08000000 /* SDRAM bank #1 32bits    */
+#define CFG_SDRAM_1_SIZE	0x04000000 /* 64 MB                   */
+#define CFG_SDRAM_NUM_COL		9  /* 8, 9, 10 or 11 column address bits */
+#define CFG_SDRAM_NUM_ROW		13 /* 11, 12 or 13 row address bits */
+#define CFG_SDRAM_REFRESH		3  /* 0=OFF 1=2048 2=4096 3=8192 refresh */
+#define CFG_SDRAM_CLOCK_CYCLE_CL_1	20 /* ns clock cycle time when CL=1 */
+#define CFG_SDRAM_ROW_PRECHARGE_DELAY	20 /* ns SRP */
+#define CFG_SDRAM_ROW_2_COL_DELAY	20 /* ns SRCD */
+#define CFG_SDRAM_ROW_CYCLE_DELAY	70 /* ns SRC */
+#define CFG_SDRAM_BURST_LENGTH		3  /* 2^N BYTES (N=0..3) */
+#define CFG_SDRAM_SINGLE_ACCESS		0  /* 1= single access; 0 = Burst mode */
+#endif
+
+/*
+ * Configuration for a maximum 32MB of FLASH memory
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* FLASH banks count (not chip count) */
+#define CFG_MAX_FLASH_SECT	256	/* number of sector in FLASH bank     */
+#define CFG_FLASH_BASE		0x10000000 /* location of flash memory        */
+
+/* This should be defined if CFI FLASH device is present. */
+#define	CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+#define CFG_FLASH_USE_BUFFER_WRITE 	1 /* use buffered writes (20x faster) */
+#define CFG_FLASH_PROTECTION		1
+
+/*
+ * This is setting for JFFS2 support in u-boot.
+ * NOTE: Enable CFG_CMD_JFFS2 for JFFS2 support.
+ */
+#define CFG_JFFS2_FIRST_BANK		0
+#define CFG_JFFS2_FIRST_SECTOR		5
+#define CFG_JFFS2_NUM_BANKS		1
+/*
+ * Environment setup. Definitions of monitor location and size with
+ * definition of environment setup ends up in 2 possibilities.
+ * 1. Embeded environment - in u-boot code is space for environment
+ * 2. Environment is read from predefined sector of flash
+ * Right now we support 2. possiblity, but expecting no env placed
+ * on mentioned address right now. This also needs to provide whole
+ * sector for it - for us 256Kb is really waste of memory. U-boot uses
+ * default env. and until kernel parameters could be sent to kernel
+ * env. has no sense to us.
+ */
+
+#define	CFG_MONITOR_BASE	0x10000000
+#define	CFG_MONITOR_LEN		0x00040000	/* 256kB ( 2 flash sector )  */
+#define	CFG_ENV_IS_IN_FLASH	1
+#define	CFG_ENV_ADDR		0x10040000	/* absolute address for now  */
+#define	CFG_ENV_SIZE		0x00020000
+#define	CFG_ENV_SECT_SIZE	0x00020000
+#define	CONFIG_ENV_OVERWRITE	1		/* env is writable now   */
+#define	CONFIG_FIRMWARE_ADDR	0x10060000
+#define	CONFIG_FIRMWARE_LEN	0x00040000	/* 256kB ( 2 flash sector )  */
+#define	CONFIG_KERNEL_ADDR	0x100A0000
+#define	CONFIG_KERNEL_LEN	0x00180000	/* 1.5MB */
+#define	CONFIG_ROOTFS_ADDR	0x10220000
+#define	CONFIG_ROOTFS_LEN	0x00580000	/* 5.5MB */
+
+/*
+ * Default load address for user programs and kernel
+ */
+#define CFG_LOAD_ADDR		0x08000000
+#define	CONFIG_LOADADDR		0x08000000
+
+/* Setup for PA23 which is Reset Default PA23 but has to become
+   CS5 */
+#define CFG_GIUS_A_VAL		0x00007ff8
+#define CFG_GPCR_VAL		0x000003AB
+/* FMCR Bit 1 becomes 0 to make CS3 CS3 :P since we have only one sdram bank*/
+#if (CONFIG_NR_DRAM_BANKS == 1)
+#define CFG_FMCR_VAL 0x00000001
+#elif (CONFIG_NR_DRAM_BANKS == 2)
+#define CFG_FMCR_VAL 0x00000003
+#endif
+
+
+/*
+ * Hardware drivers
+ */
+
+/* DM9000 ethernet chipset assigned to CS4 */
+#define CONFIG_DRIVER_DM9000	1
+#undef  CONFIG_DM9000_DEBUG
+#define CONFIG_DM9000_BASE	0x15C3FFFC
+#define DM9000_IO		CONFIG_DM9000_BASE
+#define DM9000_DATA		(CONFIG_DM9000_BASE+4)
+#define CONFIG_DM9000_USE_16BIT
+
+/*-----------------------------------------------------------------------
+ * FPGA stuff
+ */
+#define CONFIG_FPGA_COUNT	1
+#define CONFIG_FPGA		0x101	/* CFG_XILINX_SPARTAN2 */
+#define CFG_FPGA_WAIT                 250
+/* FPGA program pin configuration */
+#define CFG_FPGA_PRG	(GPIO_PORTB | 18)	/* FPGA prog pin (SSI output) */
+#define CFG_FPGA_CLK	(GPIO_PORTB | 19)	/* FPGA clk pin  (SSI output) */
+#define CFG_FPGA_DATA	(GPIO_PORTB | 17)	/* FPGA data pin (SSI output) */
+#define CFG_FPGA_INIT	(GPIO_PORTB | 15)	/* FPGA init pin (SSI input)  */
+#define CFG_FPGA_DONE	(GPIO_PORTB | 16)	/* FPGA done pin (SSI input)  */
+
+/*
+ * I2C bus
+ */
+
+#define	CONFIG_HARD_I2C		1	/* I2C with hardware support    */
+
+#define CFG_I2C_SPEED		400000	/* 400 kHz */
+#define CFG_I2C_SLAVE		0x7F
+
+# define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM 24LC256               */
+# define CFG_I2C_EEPROM_ADDR_LEN 2	/* bytes of address             */
+/* mask of address bits that overflow into the "EEPROM chip address"    */
+/*#define CFG_I2C_EEPROM_ADDR_OVERFLOW	0x00*/
+#define CFG_EEPROM_PAGE_WRITE_BITS	6
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	10	/* takes up to 10 msec */
+
+/*
+ * External interfaces module
+ *
+ * CSxU_VAL:
+ * 63|    x    |x|x x|x x x x|x x| x | x  |x x x x|48
+ *   |DTACK_SEL|0|BCD|  BCS  |PSZ|PME|SYNC|  DOL  |
+ *
+ * 47| x x  | x x x x x x | x | x x x x | x x x x |32
+ *   | CNC  |     WSC     | 0 |   WWS   |   EDC   |
+ *
+ * CSxL_VAL:
+ * 31|  x x x x  | x x x x  | x x x x  | x x x x  |24
+ *   |    OEA    |   OEN    |   WEA    |   WEN    |
+ * 23|x x x x| x | x x x | x x  x x |x x| x |  x  | 0
+ *   |  CSA  |EBC|  DSZ  | 0|SP|0|WP|0 0|PA |CSEN |
+ */
+
+/* CS0 configuration for  flash memory Micron MT28F128J3-150 */
+#define CFG_CS0_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals */
+#define CFG_CS0_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins  */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS0_SUPERVISOR_PROTECT	0   /* 1 : user mode access prohibited  */
+#define CFG_CS0_WRITE_PROTECT		0   /* 1 : write access prohibited  */
+#define CFG_CS0_EB_SIGNAL_CONTROL_WRITE	1   /* 1 when EB is used as write signal */
+#define CFG_CS0_READ_CYC_LGTH		150	/* ns */
+#define CFG_CS0_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS0_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS0_CS_NEG_LGTH 	0	/* ns CS HIGH to CS LOW : tCWH */
+#define CFG_CS0_XTRA_DEAD_CYC	35	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS0_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS0_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS0_EB_NEG_DLY		0	/* ns */
+#define CFG_CS0_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS0_SYNC_ENABLE		1	/* enable synchronous burst mode */
+#define CFG_CS0_SYNC_PAGE_MODE_EMUL	1	/* enable page mode emulation */
+#define CFG_CS0_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS0_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS0_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS0_SYNC_DAT_OUT_LGTH	25	/* ns */
+
+/* CS1 configuration for  */
+#define CFG_CS1_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals  */
+#define CFG_CS1_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS1_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins*/
+						/* 3=8bits on D[7:0] 6=32 bits..*/ 
+#define CFG_CS1_SUPERVISOR_PROTECT	0	/* 1 : user mode access prohibited  */
+#define CFG_CS1_WRITE_PROTECT		0	/* 1 : write access prohibited  */
+#define CFG_CS1_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal */
+
+#define CFG_CS1_READ_CYC_LGTH		30	/* ns */
+#define CFG_CS1_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS1_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS1_CS_NEG_LGTH 	0	/* max 30 ns CS HIGH to CS LOW at 100MHz */
+#define CFG_CS1_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS1_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS1_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS1_EB_NEG_DLY		0	/* ns */
+#define CFG_CS1_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS1_SYNC_ENABLE		0	/* enable synchronous burst mode */
+#define CFG_CS1_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation */
+#define CFG_CS1_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS1_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS1_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS1_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS2 configuration for  */
+#define CFG_CS2_CHIP_SELECT_ENABLE	0	/* 1 : enable CS0 peripherals  */
+#define CFG_CS2_PIN_ASSERT		0	/* chip select pin state when */
+						/*chip select disabled  */
+#define CFG_CS2_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS2_SUPERVISOR_PROTECT	0	/* 1 : user mode access prohibited  */
+#define CFG_CS2_WRITE_PROTECT		0	/* 1 : write access prohibited  */
+#define CFG_CS2_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal */
+
+#define CFG_CS2_READ_CYC_LGTH		0	/* ns */
+#define CFG_CS2_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS2_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS2_CS_NEG_LGTH 	0	/* max 30 ns CS HIGH to CS LOW at 100MHz */
+#define CFG_CS2_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS2_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS2_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS2_EB_NEG_DLY		0	/* ns */
+#define CFG_CS2_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS2_SYNC_ENABLE		0	/* enable synchronous burst mode */
+#define CFG_CS2_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation*/
+#define CFG_CS2_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS2_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS2_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS2_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS3 configuration for  */
+#define CFG_CS3_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals  */
+#define CFG_CS3_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS3_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS3_SUPERVISOR_PROTECT	0	/* 1: user mode access prohibited*/
+#define CFG_CS3_WRITE_PROTECT		0	/* 1: write access prohibited  */
+#define CFG_CS3_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal*/
+
+#define CFG_CS3_READ_CYC_LGTH		0	/* ns */
+#define CFG_CS3_OE_ASSERT_DLY		0	/* ns */
+#define CFG_CS3_OE_NEG_DLY		0	/* ns */
+
+#define CFG_CS3_CS_NEG_LGTH 	0	/* max 30 ns CS HIGH to CS LOW at 100MHz */
+#define CFG_CS3_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS3_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS3_EB_ASSERT_DLY		0	/* ns */
+#define CFG_CS3_EB_NEG_DLY		0	/* ns */
+#define CFG_CS3_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS3_SYNC_ENABLE		0	/* enable synchronous burst mode*/
+#define CFG_CS3_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation*/
+#define CFG_CS3_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS3_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS3_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS3_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS4 configuration for DM9000 ethernet chipset */
+#define CFG_CS4_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals  */
+#define CFG_CS4_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS4_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS4_SUPERVISOR_PROTECT	0	/* 1 : user mode access prohibited*/
+#define CFG_CS4_WRITE_PROTECT		0	/* 1 : write access prohibited  */
+#define CFG_CS4_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal*/
+
+#define CFG_CS4_READ_CYC_LGTH		72	/* ns */
+#define CFG_CS4_OE_ASSERT_DLY		5	/* ns */
+#define CFG_CS4_OE_NEG_DLY		45	/* ns */
+
+#define CFG_CS4_CS_NEG_LGTH 	30	/* max 30 ns CS HIGH to CS LOW at 100MHz*/
+#define CFG_CS4_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS4_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS4_EB_ASSERT_DLY		5	/* ns */
+#define CFG_CS4_EB_NEG_DLY		45	/* ns */
+#define CFG_CS4_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS4_SYNC_ENABLE		0	/* enable synchronous burst mode*/
+#define CFG_CS4_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation */
+#define CFG_CS4_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS4_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS4_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS4_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/* CS5 configuration for  */
+#define CFG_CS5_CHIP_SELECT_ENABLE	1	/* 1 : enable CS0 peripherals */
+#define CFG_CS5_PIN_ASSERT		0	/* chip select pin state when */
+						/* chip select disabled  */
+#define CFG_CS5_DATA_PORT_SIZE		0x5	/* 5=16 bits on D[15:0] pins */
+						/* 3=8bits on D[7:0] 6=32 bits..*/
+#define CFG_CS5_SUPERVISOR_PROTECT	0	/* 1: user mode access prohibited*/
+#define CFG_CS5_WRITE_PROTECT		0	/* 1 : write access prohibited*/
+#define CFG_CS5_EB_SIGNAL_CONTROL_WRITE	1	/* 1 when EB is used as write signal*/
+#define CFG_CS5_DTACK_SELECT		1	/* Activate DTACK fonction */
+						/* (asynchrone bus) */
+
+#define CFG_CS5_READ_CYC_LGTH		-1	/* ns or -1 to DTACK function */
+#define CFG_CS5_OE_ASSERT_DLY		10	/* ns */
+#define CFG_CS5_OE_NEG_DLY		10	/* ns */
+
+#define CFG_CS5_CS_NEG_LGTH 	10	/* max 30 ns CS HIGH to CS LOW at 100MHz*/
+#define CFG_CS5_XTRA_DEAD_CYC	0	/* ns from CS HIGH to tristate bus */
+
+#define CFG_CS5_WRITE_XTRA_LGTH		0	/* ns */
+#define CFG_CS5_EB_ASSERT_DLY		10	/* ns */
+#define CFG_CS5_EB_NEG_DLY		10	/* ns */
+#define CFG_CS5_CS_ASSERT_NEG_DLY	0	/* ns */
+
+#define CFG_CS5_SYNC_ENABLE		0	/* enable synchron burst mode */
+#define CFG_CS5_SYNC_PAGE_MODE_EMUL	0	/* enable page mode emulation */
+#define CFG_CS5_SYNC_PAGE_SIZE		0	/* 4 words page size (8bytes) */
+#define CFG_CS5_SYNC_BURST_CLK_START	0	/* 0 ns burst clock delay */
+#define CFG_CS5_SYNC_BURST_CLK_DIV	0	/* 0 : divider is 1 */
+#define CFG_CS5_SYNC_DAT_OUT_LGTH	0	/* ns */
+
+/*
+ * FIXME: From here, there should not be any user configuration.
+ * All Equations are automatic
+ */
+
+
+#define CFG_HCLK_LGTH		(1000/CONFIG_SYS_BUS_FREQ)	/* ns */
+
+/* USB 48 MHz ; BUS 96MHz*/
+#ifdef CFG_OSC16
+#define CSCR_MASK 0x23030003
+#else
+#define CSCR_MASK 0x23000003
+#endif
+#define CFG_CSCR_VAL\
+	(CSCR_MASK 						\
+	|((((CONFIG_SYS_FREQ/CONFIG_USB_FREQ)-1)&0x07)<<26)	\
+	|((((CONFIG_SYS_FREQ/CONFIG_SYS_BUS_FREQ)-1)&0x0F)<<10))
+
+/* PERCLKx 16MHz */
+#define CFG_PCDR_VAL\
+	(((((CONFIG_SYS_FREQ/CONFIG_PERIF1_FREQ)-1)&0x0F)<<0)	\
+	|((((CONFIG_SYS_FREQ/CONFIG_PERIF2_FREQ)-1)&0x0F)<<4)	\
+	|((((CONFIG_SYS_FREQ/CONFIG_PERIF3_FREQ)-1)&0x7F)<<16))
+
+/* SDRAM controller programming Values */
+#if ((CFG_SDRAM_CLOCK_CYCLE_CL_1>(3*CFG_HCLK_LGTH))\
+	||(CFG_SDRAM_CLOCK_CYCLE_CL_1<1))
+#define REG_FIELD_SCL_VAL 3
+#else
+#define REG_FIELD_SCL_VAL\
+	((CFG_SDRAM_CLOCK_CYCLE_CL_1+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)
+#endif
+
+#if ((CFG_SDRAM_ROW_PRECHARGE_DELAY>(2*CFG_HCLK_LGTH))\
+	||(CFG_SDRAM_ROW_PRECHARGE_DELAY<1))
+#define REG_FIELD_SRP_VAL 0
+#else
+#define REG_FIELD_SRP_VAL 1
+#endif
+
+#if (CFG_SDRAM_ROW_2_COL_DELAY>(3*CFG_HCLK_LGTH))
+#define REG_FIELD_SRCD_VAL 0
+#else
+#define REG_FIELD_SRCD_VAL\
+	((CFG_SDRAM_ROW_2_COL_DELAY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)
+#endif
+
+#if (CFG_SDRAM_ROW_CYCLE_DELAY>(7*CFG_HCLK_LGTH))
+#define REG_FIELD_SRC_VAL 0
+#else
+#define REG_FIELD_SRC_VAL\
+	((CFG_SDRAM_ROW_CYCLE_DELAY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)
+#endif
+
+#define REG_SDCTL_BASE_CONFIG (0x800a1000\
+				| (((CFG_SDRAM_NUM_ROW-11)&0x3)<<24)\
+				| (((CFG_SDRAM_NUM_COL-8)&0x3)<<20)\
+				| (((CFG_SDRAM_REFRESH)&0x3)<<14)\
+				| (((REG_FIELD_SCL_VAL)&0x3)<<8)\
+				| (((REG_FIELD_SRP_VAL)&0x1)<<6)\
+				| (((REG_FIELD_SRCD_VAL)&0x3)<<4)\
+				| (((REG_FIELD_SRC_VAL)&0x7)<<0))
+
+#define CFG_NORMAL_RW_CMD	((0x0<<28)+REG_SDCTL_BASE_CONFIG)
+#define CFG_PRECHARGE_CMD	((0x1<<28)+REG_SDCTL_BASE_CONFIG)
+#define CFG_AUTOREFRESH_CMD	((0x2<<28)+REG_SDCTL_BASE_CONFIG)
+#define CFG_SET_MODE_REG_CMD	((0x3<<28)+REG_SDCTL_BASE_CONFIG)
+
+/* Issue Mode register Command to SDRAM*/
+#define CFG_SDRAM_MODE_REGISTER_VAL\
+	((((CFG_SDRAM_BURST_LENGTH)&0x7)<<(CFG_SDRAM_NUM_COL+4))\
+	| (((REG_FIELD_SCL_VAL)&0x3)<<(CFG_SDRAM_NUM_COL+4+4))\
+	| (((CFG_SDRAM_SINGLE_ACCESS)&0x1)<<(CFG_SDRAM_NUM_COL+4+9)))
+
+/* Issue Precharge all Command to SDRAM*/
+#define CFG_SDRAM_PRECHARGE_ALL_VAL\
+	(((CFG_SDRAM_SINGLE_ACCESS)&0x1)<<(CFG_SDRAM_NUM_COL+4+9))
+
+/* undef CONFIG_INIT_CRITICAL is no more required to boot from sdram */
+#undef CONFIG_INIT_CRITICAL
+
+/*
+ * CSxU_VAL:
+ * 63|    x    |x|x x|x x x x|x x| x | x  |x x x x|48
+ *   |DTACK_SEL|0|BCD|  BCS  |PSZ|PME|SYNC|  DOL  |
+ *
+ * 47| x x  | x x x x x x | x | x x x x | x x x x |32
+ *   | CNC  |     WSC     | 0 |   WWS   |   EDC   |
+ *
+ * CSxL_VAL:
+ * 31|  x x x x  | x x x x  | x x x x  | x x x x  |24
+ *   |    OEA    |   OEN    |   WEA    |   WEN    |
+ * 23|x x x x| x | x x x | x x  x x |x x| x |  x  | 0
+ *   |  CSA  |EBC|  DSZ  | 0|SP|0|WP|0 0|PA |CSEN |
+ */
+#define CFG_CS0U_VAL\
+	((((CFG_CS0_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS0_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS0_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS0_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS0_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS0_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS0_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS0_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS0_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS0_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS0L_VAL\
+	((CFG_CS0_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS0_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS0_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS0_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS0_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS0_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS0_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS0_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS0_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS0_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS1U_VAL\
+	((((CFG_CS1_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS1_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS1_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS1_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS1_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS1_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS1_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS1_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS1_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS1_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS1L_VAL\
+	((CFG_CS1_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS1_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS1_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS1_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS1_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS1_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS1_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS1_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS1_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS1_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS1_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS2U_VAL\
+	(((((CFG_CS2_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS2_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS2_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS2_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|(((CFG_CS2_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS2_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS2_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS2_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS2_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS2_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS2L_VAL\
+	((CFG_CS2_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS2_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS2_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS2_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS2_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS2_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS2_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS2_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS2_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS2_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS2_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS3U_VAL\
+	((((CFG_CS3_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS3_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS3_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS3_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS3_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS3_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS3_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS3_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS3_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS3_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS3L_VAL\
+	((CFG_CS3_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS3_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS3_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS3_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS3_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS3_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS3_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS3_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS3_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS3_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS3_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS4U_VAL\
+	(((((CFG_CS4_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS4_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS4_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS4_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS4_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16))\
+	|((CFG_CS4_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS4_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS4_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS4_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS4_SYNC_BURST_CLK_DIV&0x03)<<28))
+
+#define CFG_CS4L_VAL\
+	((CFG_CS4_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS4_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS4_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS4_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS4_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS4_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS4_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS4_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS4_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS4_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS4_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#define CFG_CS5U_VAL\
+	((((CFG_CS5_XTRA_DEAD_CYC+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)\
+	|((((CFG_CS5_WRITE_XTRA_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<4)\
+	|(((((CFG_CS5_READ_CYC_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)-1)&0x3F)<<8)\
+	|((((CFG_CS5_CS_NEG_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x03)<<14)\
+	|((((CFG_CS5_SYNC_DAT_OUT_LGTH+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|((CFG_CS5_SYNC_ENABLE&0x01)<<20)\
+	|((CFG_CS5_SYNC_PAGE_MODE_EMUL&0x01)<<21)\
+	|((CFG_CS5_SYNC_PAGE_SIZE&0x03)<<22)\
+	|((((CFG_CS5_SYNC_BURST_CLK_START+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|((CFG_CS5_SYNC_BURST_CLK_DIV&0x03)<<28)\
+	|((CFG_CS5_DTACK_SELECT&0x01)<<31))
+
+#define CFG_CS5L_VAL\
+	((CFG_CS5_CHIP_SELECT_ENABLE&0x01)\
+	|((CFG_CS5_PIN_ASSERT&0x01)<<1)\
+	|((CFG_CS5_WRITE_PROTECT&0x01)<<4)\
+	|((CFG_CS5_SUPERVISOR_PROTECT&0x01)<<6)\
+	|((CFG_CS5_DATA_PORT_SIZE&0x07)<<8)\
+	|((CFG_CS5_EB_SIGNAL_CONTROL_WRITE&0x01)<<11)\
+	|((((CFG_CS5_CS_ASSERT_NEG_DLY+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<12)\
+	|(((((CFG_CS5_EB_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<16)\
+	|(((((CFG_CS5_EB_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<20)\
+	|(((((CFG_CS5_OE_NEG_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<24)\
+	|(((((CFG_CS5_OE_ASSERT_DLY*2)+CFG_HCLK_LGTH-1)/CFG_HCLK_LGTH)&0x0F)<<28))
+
+#endif				/* __CONFIG_H */
diff -purN u-boot-1.1.3-ref/include/spartan2.h u-boot-1.1.3/include/spartan2.h
--- u-boot-1.1.3-ref/include/spartan2.h	2005-12-04 15:32:27.000000000 +0100
+++ u-boot-1.1.3/include/spartan2.h	2005-12-04 15:45:17.000000000 +0100
@@ -77,6 +77,16 @@ typedef struct {
 #define XILINX_XC2S200E_SIZE    1442016/8
 #define XILINX_XC2S300E_SIZE    1875648/8
 
+/* Spartan-III (1.2V) */
+#define XILINX_XC3S50_SIZE  	439264/8
+#define XILINX_XC3S200_SIZE  	1047616/8
+#define XILINX_XC3S400_SIZE  	1699136/8
+#define XILINX_XC3S1000_SIZE 	3223488/8
+#define XILINX_XC3S1500_SIZE 	5214784/8
+#define XILINX_XC3S2000_SIZE 	7673024/8
+#define XILINX_XC3S4000_SIZE 	11316864/8
+#define XILINX_XC3S5000_SIZE 	13271936/8
+
 /* Descriptor Macros
  *********************************************************************/
 /* Spartan-II devices */
diff -purN u-boot-1.1.3-ref/MAKEALL u-boot-1.1.3/MAKEALL
--- u-boot-1.1.3-ref/MAKEALL	2005-12-04 15:32:14.000000000 +0100
+++ u-boot-1.1.3/MAKEALL	2005-12-04 15:45:17.000000000 +0100
@@ -168,7 +168,7 @@ LIST_ARM9="	\
 	lpd7a400	mx1ads		mx1fs2		omap1510inn	\
 	omap1610h2	omap1610inn	omap730p2	scb9328		\
 	smdk2400	smdk2410	trab		VCMA9		\
-	versatile	voiceblue					\
+	versatile	voiceblue	apm9328				\
 "
 
 #########################################################################
diff -purN u-boot-1.1.3-ref/Makefile u-boot-1.1.3/Makefile
--- u-boot-1.1.3-ref/Makefile	2005-12-04 15:32:14.000000000 +0100
+++ u-boot-1.1.3/Makefile	2005-12-04 15:45:17.000000000 +0100
@@ -138,7 +138,7 @@ SUBDIRS	= tools \
 #########################################################################
 #########################################################################
 
-ALL = u-boot.srec u-boot.bin System.map
+ALL = u-boot.srec u-boot.brec u-boot.bin System.map
 
 all:		$(ALL)
 
@@ -158,6 +158,9 @@ u-boot.img:	u-boot.bin
 			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
 		-d $< $@
 
+u-boot.brec:	u-boot.bin
+		./tools/mkbrecimage $< $@
+
 u-boot.dis:	u-boot
 		$(OBJDUMP) -d $< > $@
 
@@ -1423,6 +1426,9 @@ omap730p2_cs3boot_config :	unconfig
 scb9328_config	:	unconfig
 	@./mkconfig $(@:_config=) arm arm920t scb9328 NULL imx
 
+apm9328_config	:	unconfig
+	@./mkconfig $(@:_config=) arm arm920t apm9328 NULL imx
+
 smdk2400_config	:	unconfig
 	@./mkconfig $(@:_config=) arm arm920t smdk2400 NULL s3c24x0
 
@@ -1741,7 +1747,8 @@ clean:
 
 clobber:	clean
 	find . -type f \( -name .depend \
-		-o -name '*.srec' -o -name '*.bin' -o -name u-boot.img \) \
+		-o -name '*.srec' -o -name '*.bin' -o -name '*.brec'\
+		-o -name '*.img' -o -name u-boot.img \) \
 		-print0 \
 		| xargs -0 rm -f
 	rm -f $(OBJS) *.bak tags TAGS
diff -purN u-boot-1.1.3-ref/tools/breclib.c u-boot-1.1.3/tools/breclib.c
--- u-boot-1.1.3-ref/tools/breclib.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/tools/breclib.c	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,79 @@
+/*
+ * (C) Copyright 2005
+ * Eric JARRIGE, <jorasse@users.sourceforge.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+
+#include "breclib.h"
+
+#define BS_WRITE	0x00<<5
+#define BS_READ		0x01<<5
+#define BS_BYTE		0x00<<6
+#define BS_HALF_WORD	0x01<<6
+#define BS_WORD		0x03<<6
+
+#define BS_WRITE_BYTES( X ) 	(BS_WRITE | BS_BYTE | X)
+#define BS_WRITE_HALF_WORD( X ) (BS_WRITE | BS_HALF_WORD | X)
+#define BS_WRITE_WORD( X ) 	(BS_WRITE | BS_WORD | X)
+#define BS_READ_BYTES( X ) 	(BS_READ | BS_BYTE | X)
+#define BS_READ_HALF_WORD( X ) 	(BS_READ | BS_HALF_WORD | X)
+#define BS_READ_WORD( X ) 	(BS_READ | BS_WORD | X)
+#define BS_EXEC( ) 		0x00
+
+
+
+int build_brec_long_read_req(char *a_brecord, long a_addr) {
+	sprintf(a_brecord, "%08lX%02X", a_addr, BS_READ_WORD( 4 ));
+	return 0;
+}
+
+int build_brec_long_write_req(char *a_brecord, long a_addr, long a_value) {
+	sprintf(a_brecord, "%08lX%02X%08lX", a_addr, BS_WRITE_WORD( 4 ), a_value);
+	return 0;
+}
+
+int build_brec_mem_write_req(char *a_brecord, long a_addr, void *a_mem, int a_size) {
+	int  i = a_size;
+	char buff[63];
+	char *dst_ptr = buff;
+	unsigned char *src_ptr = a_mem;
+
+	
+
+	if (i > 31) {
+		fprintf(stderr, "cannot write more than 31 bytes at once in a bootstrap record\n");
+		exit (EXIT_FAILURE);
+	}
+
+	for(;i>0;i--, dst_ptr+=2, src_ptr++)
+		sprintf(dst_ptr,"%02X", *src_ptr);
+	sprintf(a_brecord, "%08lX%02X%s", a_addr, BS_WRITE_BYTES(a_size), buff);
+	return 0;
+}
+
+int build_brec_exe_req(char *a_brecord, long a_addr) {
+	sprintf(a_brecord, "%08lX%02X", a_addr, BS_EXEC());
+	return 0;
+}
diff -purN u-boot-1.1.3-ref/tools/breclib.h u-boot-1.1.3/tools/breclib.h
--- u-boot-1.1.3-ref/tools/breclib.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/tools/breclib.h	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,27 @@
+/*
+ * (C) Copyright 2005
+ * Eric JARRIGE, <jorasse@users.sourceforge.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+int build_brec_long_read_req(char *a_brecord, long a_addr);
+int build_brec_long_write_req(char *a_brecord, long a_addr, long a_value);
+int build_brec_mem_write_req(char *a_brecord, long a_addr, void *a_mem, int a_size);
+int build_brec_exe_req(char *a_brecord, long a_addr);
diff -purN u-boot-1.1.3-ref/tools/Makefile u-boot-1.1.3/tools/Makefile
--- u-boot-1.1.3-ref/tools/Makefile	2005-12-04 15:32:27.000000000 +0100
+++ u-boot-1.1.3/tools/Makefile	2005-12-04 15:45:17.000000000 +0100
@@ -22,8 +22,9 @@
 #
 
 BINS	= img2srec$(SFX) mkimage$(SFX) envcrc$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX)
+	
 
-OBJS	= environment.o img2srec.o mkimage.o crc32.o envcrc.o gen_eth_addr.o bmp_logo.o
+OBJS	= environment.o img2srec.o mkimage.o crc32.o envcrc.o gen_eth_addr.o bmp_logo.o 
 
 ifeq ($(ARCH),mips)
 BINS   += inca-swap-bytes$(SFX)
@@ -42,6 +43,12 @@ ifeq ($(LOGO_BMP),)
 LOGO_BMP= logos/denx.bmp
 endif
 
+# only for bootstrap supported architecture
+ifeq ($(SOC),imx)
+BINS   += mkbrecimage$(SFX)
+OBJS   += breclib.o mkbrecimage.o
+endif
+
 #-------------------------------------------------------------------------
 
 HOSTARCH := $(shell uname -m | \
@@ -118,6 +125,9 @@ MAKEDEPEND = makedepend
 
 all:	.depend $(BINS) $(LOGO_H) subdirs
 
+mkbrecimage$(SFX):	mkbrecimage.o breclib.o 
+		$(CC) $(CFLAGS) -o $@ $^
+
 envcrc$(SFX):	envcrc.o crc32.o environment.o
 		$(CC) $(CFLAGS) -o $@ $^
 
@@ -149,6 +159,12 @@ mpc86x_clk$(SFX):	mpc86x_clk.o
 		$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
 		$(STRIP) $@
 
+mkbrecimage.o:	mkbrecimage.c
+		$(CC) -g $(CFLAGS) -c $<
+
+breclib.o:	breclib.c
+		$(CC) -g $(CFLAGS) -c $<
+
 envcrc.o:	envcrc.c
 		$(CC) -g $(CFLAGS) -c $<
 
diff -purN u-boot-1.1.3-ref/tools/mkbrecimage.c u-boot-1.1.3/tools/mkbrecimage.c
--- u-boot-1.1.3-ref/tools/mkbrecimage.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.3/tools/mkbrecimage.c	2005-12-04 15:45:17.000000000 +0100
@@ -0,0 +1,216 @@
+/*
+ * (C) Copyright 2005
+ * Eric JARRIGE, <jorasse@users.sourceforge.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <memory.h>
+#include <unistd.h>
+
+#include "breclib.h"
+
+#ifndef __ASSEMBLY__
+#define	__ASSEMBLY__			/* Dirty trick to get only #defines	*/
+#endif
+#define	__ASM_STUB_PROCESSOR_H__	/* don't include asm/processor.		*/
+#include <asm/arch/imx-regs.h>
+#include <config.h>
+#undef	__ASSEMBLY__
+
+/* if not defined generate default freescale MX1ADS eval board */
+#ifndef CFG_GPCR_VAL
+#warning "CFG_GPCR_VAL is not defined in your config file!! assume 0x03AB"
+#define CFG_GPCR_VAL 0x03AB
+#endif
+
+#ifndef CFG_PRECHARGE_CMD
+#warning "CFG_PRECHARGE_CMD is not defined in your config file!! assume 0x92120200"
+#define CFG_PRECHARGE_CMD 0x92120200
+#endif
+
+#ifndef CFG_SDRAM_1_BASE
+#warning "CFG_SDRAM_1_BASE is not defined in your config file!! assume 0x08000000"
+#define CFG_SDRAM_1_BASE 0x08000000
+#endif
+#ifndef CFG_SDRAM_PRECHARGE_ALL_VAL
+#warning "CFG_SDRAM_PRECHARGE_ALL_VAL is not defined in your config file!! assume 0x00200000"
+#define CFG_SDRAM_PRECHARGE_ALL_VAL 0x00200000
+#endif
+#ifndef CFG_AUTOREFRESH_CMD
+#warning "CFG_AUTOREFRESH_CMD is not defined in your config file!! assume 0xA2120200"
+#define CFG_AUTOREFRESH_CMD 0xA2120200
+#endif
+#ifndef CFG_SET_MODE_REG_CMD
+#warning "CFG_SET_MODE_REG_CMD is not defined in your config file!! assume 0xB2120200"
+#define CFG_SET_MODE_REG_CMD 0xB2120200
+#endif
+#ifndef CFG_SDRAM_MODE_REGISTER_VAL
+#warning "CFG_SDRAM_MODE_REGISTER_VAL is not defined in your config file!! assume 0x00111800"
+#define CFG_SDRAM_MODE_REGISTER_VAL 0x00111800
+#endif
+#ifndef CFG_NORMAL_RW_CMD
+#warning "CFG_NORMAL_RW_CMD is not defined in your config file!! assume 0x82124200"
+#define CFG_NORMAL_RW_CMD 0x82124200
+#endif
+
+
+char *the_prog_name;
+
+
+void
+usage ()
+{
+	fprintf (stderr, "Usage: %s u-boot.bin [u-boot.brec]\n"
+			 "\n"
+			 "    %s converts binary files (u-boot.bin) into so called \n"
+			 "    bootstrap records file (u-boot.brec) that are accepted by\n"
+			 "    Motorola's MC9328MX1/L (a.k.a. DragaonBall i.MX) in \"Bootstrap Mode\" \n"
+			 "    add memory init commands and run command\n"
+			 "    at end of file\n"
+			 "    NOTE: \n"
+			 " \n",
+ 		the_prog_name, the_prog_name);
+}
+
+int generate_init_brec(FILE *a_ifd) {
+	char a_buf[80];
+
+
+	fprintf (a_ifd, "********************************************\n");
+	fprintf (a_ifd, "* Initialize I/O Pad Driving Strength      *\n");
+	fprintf (a_ifd, "********************************************\n");
+	build_brec_long_write_req(a_buf, GPCR, CFG_GPCR_VAL);
+	fprintf (a_ifd, "%s	; pre-charge command\n",a_buf);
+	fprintf (a_ifd, "********************************************\n");
+	fprintf (a_ifd, "* Initialize SDRAM                         *\n");
+	fprintf (a_ifd, "********************************************\n");
+	build_brec_long_write_req(a_buf, SDCTL0, CFG_PRECHARGE_CMD);
+	fprintf (a_ifd, "%s	; pre-charge command\n",a_buf);
+	build_brec_long_read_req(a_buf, CFG_SDRAM_1_BASE+CFG_SDRAM_PRECHARGE_ALL_VAL);
+	fprintf (a_ifd, "%s		; special read\n",a_buf);
+	build_brec_long_write_req(a_buf, SDCTL0, CFG_AUTOREFRESH_CMD);
+	fprintf (a_ifd, "%s	; auto-refresh command\n",a_buf);
+	build_brec_long_read_req(a_buf, CFG_SDRAM_1_BASE);
+	fprintf (a_ifd, "%s		; 8 special reads\n",a_buf);
+	fprintf (a_ifd, "%s		; Issue AutoRefresh Command\n",a_buf);
+	fprintf (a_ifd, "%s		;\n",a_buf);
+	fprintf (a_ifd, "%s		;\n",a_buf);
+	fprintf (a_ifd, "%s		;\n",a_buf);
+	fprintf (a_ifd, "%s		;\n",a_buf);
+	fprintf (a_ifd, "%s		;\n",a_buf);
+	fprintf (a_ifd, "%s		;\n",a_buf);
+	build_brec_long_write_req(a_buf, SDCTL0, CFG_SET_MODE_REG_CMD);
+	fprintf (a_ifd, "%s	; set mode register\n",a_buf);
+	build_brec_long_read_req(a_buf, CFG_SDRAM_1_BASE+CFG_SDRAM_MODE_REGISTER_VAL);
+	fprintf (a_ifd, "%s		; special read\n",a_buf);
+	build_brec_long_write_req(a_buf, SDCTL0, CFG_NORMAL_RW_CMD);
+	fprintf (a_ifd, "%s	; set normal mode\n",a_buf);
+
+	return 0;
+}
+
+int generate_start_uboot_brec(FILE *a_ifd) {
+	char a_buf[80];
+
+	fprintf (a_ifd, "********************************************\n");
+	fprintf (a_ifd, "* send execute command	                    *\n");
+	fprintf (a_ifd, "********************************************\n");
+	build_brec_exe_req(a_buf, CFG_SDRAM_1_BASE);
+	fprintf (a_ifd, "%s		; execute\n", a_buf);
+
+	return 0;
+}
+
+int generate_uboot_code_brec(FILE *a_uboot_fd, FILE *a_ifd) {
+	char a_in_buf[80];
+	char a_out_buf[80];
+	size_t byte_read;
+	long dest_addr = CFG_SDRAM_1_BASE;
+
+	fprintf (a_ifd, "********************************************\n");
+	fprintf (a_ifd, "* bin code                                 *\n");
+	fprintf (a_ifd, "********************************************\n");
+
+	byte_read =fread(a_in_buf, 1, 16, a_uboot_fd);
+
+	while ( byte_read != 0)
+	{
+		build_brec_mem_write_req(a_out_buf, dest_addr, a_in_buf, byte_read);
+		fprintf (a_ifd, "%s\n",a_out_buf);
+		dest_addr += byte_read;
+		byte_read =fread(a_in_buf, 1, 16, a_uboot_fd);
+
+	} 
+
+	return 0;
+}
+
+int main (int argc, char *argv[])
+{
+	FILE *in_fd, *out_fd;
+
+	the_prog_name = *argv;
+
+	if ((argc < 2)||(argc > 3)||(*argv[1] == '-')) {
+		usage();
+		return (0);
+	}
+	else {
+
+		in_fd = fopen(argv[1], "r");
+
+		if (in_fd == NULL) {
+			fprintf (stderr, "%s: Can't open input file %s: %s\n",
+			the_prog_name, argv[1], strerror(errno));
+			exit (EXIT_FAILURE);
+		}
+		
+		out_fd = fopen(argv[2], "w");
+		if (out_fd == NULL) {
+			fprintf (stderr, "%s: Can't open output file %s: %s\n",
+			the_prog_name, argv[2], strerror(errno));
+			exit (EXIT_FAILURE);
+		}
+
+		generate_init_brec(out_fd);
+		generate_uboot_code_brec(in_fd, out_fd);
+		generate_start_uboot_brec(out_fd);
+
+		if (fclose(out_fd)) {
+			fprintf (stderr, "%s: write error on %s: %s\n",
+				the_prog_name, argv[2], strerror(errno));
+			exit (EXIT_FAILURE);
+		}
+
+		if (fclose(in_fd)) {
+			fprintf (stderr, "%s: read error on %s: %s\n",
+				the_prog_name, argv[1], strerror(errno));
+			exit (EXIT_FAILURE);
+		}
+	}
+
+	return (0);
+}
diff -purN -x '*~' u-boot-1.1.3ref/include/asm-arm/mach-types.h u-boot-1.1.3/include/asm-arm/mach-types.h
--- u-boot-1.1.3ref/include/asm-arm/mach-types.h	2005-08-14 01:53:35.000000000 +0200
+++ u-boot-1.1.3/include/asm-arm/mach-types.h	2006-01-30 21:45:43.000000000 +0100
@@ -624,6 +624,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_RMS100               611
 #define MACH_TYPE_KB9200               612
 #define MACH_TYPE_SX1                  613
+#define MACH_TYPE_APF9328              906
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -7945,6 +7946,18 @@ extern unsigned int __machine_arch_type;
 # define machine_is_sx1()	(0)
 #endif
 
+#ifdef CONFIG_MACH_APF9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF9328
+# endif
+# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
+#else
+# define machine_is_apf9328()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff -purN -x '*~' u-boot-1.1.3ref/include/configs/apm9328.h u-boot-1.1.3/include/configs/apm9328.h
--- u-boot-1.1.3ref/include/configs/apm9328.h	2006-01-30 21:48:32.000000000 +0100
+++ u-boot-1.1.3/include/configs/apm9328.h	2006-01-30 21:47:09.000000000 +0100
@@ -141,7 +141,9 @@
 #define CONFIG_BOOTCOMMAND	"run jffsboot"
 #define CFG_AUTOLOAD		"yes"
 
-#define CONFIG_MACH_TYPE	MACH_TYPE_SCB9328
+#define MACH_TYPE_APM9328	MACH_TYPE_SCB9328
+
+#define CONFIG_MACH_TYPE	MACH_TYPE_APM9328
 #define CONFIG_BOOT_PARAMS_ADDR	0x08000100
 
 //#define CONFIG_SHOW_BOOT_PROGRESS
