diff -purN -x '*~' ref/linux-2.6.18/drivers/usb/gadget/imx_udc.c linux-2.6.18/drivers/usb/gadget/imx_udc.c
--- ref/linux-2.6.18/drivers/usb/gadget/imx_udc.c	2006-10-01 14:49:39.000000000 +0200
+++ linux-2.6.18/drivers/usb/gadget/imx_udc.c	2006-10-01 09:41:50.000000000 +0200
@@ -402,7 +402,7 @@ static int imx_ep_disable (struct usb_ep
  *     imx_ep_alloc_request - allocate a request data structure
  */
 static struct usb_request *
-imx_ep_alloc_request (struct usb_ep *_ep, int gfp_flags)
+imx_ep_alloc_request (struct usb_ep *_ep, gfp_t gfp_flags)
 {
     struct imx_request *req;
 
@@ -435,7 +435,7 @@ imx_ep_free_request (struct usb_ep *_ep,
 
 static void *
 imx_ep_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
-    dma_addr_t *dma, int gfp_flags)
+    dma_addr_t *dma, gfp_t gfp_flags)
 {
     void           *retval;
 
@@ -656,6 +656,7 @@ read_fifo (struct imx_ep *ep, struct imx
         i=0;
         last=0;
         while (count>0) {
+            int t; 
 #if 0
             if (!(i%4))
                 //tmp = be32_to_cpu(USB_EP_FDAT(EP_NO(ep)));
@@ -675,7 +676,7 @@ read_fifo (struct imx_ep *ep, struct imx
             if ((USB_EP_FSTAT(EP_NO(ep)) & USB_FRAME_STAT) == 0x08000000) {
                 last=1;
             }
-            int t; t =imx_fifo_bcount(ep);
+            t =imx_fifo_bcount(ep);
             D4("frame boundary stat <%08x>\n",USB_EP_FSTAT(EP_NO(ep)));
             tmp = (USB_EP_FDAT0(EP_NO(ep)));
             if (imx_fifo_bcount(ep)-t > 1) 
@@ -763,7 +764,7 @@ read_ep0_fifo (struct imx_ep *ep, struct
 
 
 static int
-imx_ep_queue(struct usb_ep *_ep, struct usb_request *_req, int gfp_flags)
+imx_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 { 
     struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
     struct imx_request *req = container_of(_req, struct imx_request, req);
@@ -1026,7 +1027,7 @@ static const struct usb_gadget_ops imx_u
 /*
  * "function" sysfs attribute
  */
-static ssize_t show_function (struct device *_dev, char *buf)
+static ssize_t show_function (struct device *_dev, struct device_attribute *attr, char *buf)
 {
     struct imx_udc *dev = dev_get_drvdata (_dev);
 
@@ -1843,14 +1848,14 @@ irqreturn_t(*intr_handler(int i))(int, v
 /*
  *  probe - binds to the platform device
  */
-static int __init imx_udc_probe(struct device *_dev)
+static int imx_udc_probe(struct platform_device *_dev)
 {
     struct imx_udc *dev = &memory;
     int retval = 0;
     int i;
     
     /* TODO: probe for IMX cpu */
-    
+    
     if (!imx_get_usb_clk()) {
         WARN("USB clock should be 48MHz, but is not\n");
         return -EIO;
@@ -1877,14 +1882,14 @@ static int __init imx_udc_probe(struct d
         return -EBUSY;
     }
     
-    dev->dev = _dev;
+    dev->dev = &(_dev->dev);
     
     device_initialize(&dev->gadget.dev);
-    dev->gadget.dev.parent = _dev;
-    dev->gadget.dev.dma_mask = _dev->dma_mask;
+    dev->gadget.dev.parent = &(_dev->dev);
+    dev->gadget.dev.dma_mask = (_dev->dev).dma_mask;
     
     the_controller = dev;
-    dev_set_drvdata(_dev, dev);
+    dev_set_drvdata(&(_dev->dev), dev);
     
     udc_disable(dev);
     udc_hardinit(dev);
@@ -1895,9 +1900,9 @@ static int __init imx_udc_probe(struct d
     return 0;
 }
 
-static int __exit imx_udc_remove(struct device *_dev)
+static int imx_udc_remove(struct platform_device *_dev)
 {
-    struct imx_udc *dev = dev_get_drvdata(_dev);
+    struct imx_udc *dev = dev_get_drvdata(&(_dev->dev));
     
     udc_disable(dev);
     remove_proc_files();
@@ -1910,7 +1915,7 @@ static int __exit imx_udc_remove(struct 
     free_irq(USBD_INT2, dev);
     free_irq(USBD_INT1, dev);
     free_irq(USBD_INT0, dev);
-    dev_set_drvdata(_dev, NULL);
+    dev_set_drvdata(&(_dev->dev), NULL);
     the_controller = NULL;
     return 0;
 }
@@ -1932,12 +1937,12 @@ static struct platform_driver udc_driver
     .bus        = &platform_bus_type,*/
     //.shutdown   = ???
     .probe      = imx_udc_probe,
-    .remove     = __exit_p(imx_udc_remove),
+    .remove     = imx_udc_remove,
     .suspend    = imx_udc_suspend,
     .resume     = imx_udc_resume,
     .driver     = {
         .owner = THIS_MODULE,
-        .name  = "i.MX-udc",
+        .name  = "imx-usb",
     },
 };
