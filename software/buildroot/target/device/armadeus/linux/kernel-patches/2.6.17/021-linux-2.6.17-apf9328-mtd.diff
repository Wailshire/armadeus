diff -uprN -X dontdiff linux-2.6.16/drivers/mtd/maps/apf9328.c linux-2.6.16.work/drivers/mtd/maps/apf9328.c
--- linux-2.6.16/drivers/mtd/maps/apf9328.c    1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.work/drivers/mtd/maps/apf9328.c    2006-01-28 19:41:19.000000000 +0100
@@ -0,0 +1,139 @@
+/*
+ * $Id: drivers/mtd/maps/apf9328.c, v1.0 
+ *
+ * Map driver for the Armadeus development board
+ *
+ * Author:  Julien Boibessot
+ * Copyright:   (C) 2005 Armadeus
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <linux/dma-mapping.h>
+
+
+static void apf9328_map_inval_cache(struct map_info *map, unsigned long from, ssize_t len)
+{
+    consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
+}
+
+static u32 flash_virt = APF9328_FLASH_BASE;
+
+static struct map_info apf9328_map = {
+    .size        = APF9328_FLASH_SIZE,
+    .virt        = &flash_virt,
+    .phys        = APF9328_FLASH_PHYS,
+    .name        = "apf9328_flash",
+    .inval_cache = apf9328_map_inval_cache,
+    .bankwidth   = 2
+};
+
+static struct mtd_partition apf9328_partitions[] = {
+    {
+        .name =         "Bootloader",
+        .size =         0x00040000,     // 256k
+        .offset =       0,
+        .mask_flags =   MTD_WRITEABLE  /* force read-only */
+    },{
+        .name =     "Bootloader env",
+        .size =     0x00020000,         // 128k
+        .offset =   0x00040000,
+    },{
+        .name =     "FPGA data",
+        .size =     0x00040000,         // 256k
+        .offset =   0x00060000,
+    },{
+        .name =     "Kernel",
+        .size =     0x00100000,         // 1M
+        .offset =   0x000a0000,
+    },{
+        .name =     "Rootfs",
+        .size =     0x00600000,         // 6M
+        .offset =   0x001a0000,
+    },{
+        .name =     "Userfs",
+        .size =     MTDPART_SIZ_FULL,
+        .offset =   0x007a0000
+    }
+};
+
+static struct mtd_info *mymtds;
+static struct mtd_partition *parsed_parts;
+static int nr_parsed_parts;
+
+static const char *probes[] = { "cmdlinepart", NULL };
+
+static int __init init_apf9328(void)
+{
+    int ret = 0;
+    
+    apf9328_map.virt = ioremap_nocache(apf9328_map.phys, APF9328_FLASH_SIZE);
+    if (!apf9328_map.virt) {
+        printk(KERN_WARNING "Failed to ioremap %s\n", apf9328_map.name);
+    }
+    
+    apf9328_map.cached = ioremap_cached(apf9328_map.phys, APF9328_FLASH_SIZE);
+    if (!apf9328_map.cached) {
+       printk(KERN_WARNING "Failed to ioremap cached %s\n", apf9328_map.name);
+    }
+    
+    simple_map_init(&apf9328_map);
+    
+    printk(KERN_NOTICE "Probing %s at physical address 0x%08lx (%d-bit buswidth)\n", apf9328_map.name, apf9328_map.phys, apf9328_map.bankwidth * 8);
+    
+    mymtds = do_map_probe("cfi_probe", &apf9328_map);
+    
+    if (!mymtds) {
+        iounmap((void *)apf9328_map.virt);
+        if (apf9328_map.cached)
+            iounmap(apf9328_map.cached);
+        if (!ret)
+            return -EIO;
+    }
+    mymtds->owner = THIS_MODULE;
+    
+    nr_parsed_parts = parse_mtd_partitions(mymtds, probes, &parsed_parts, 0);
+    
+    if (nr_parsed_parts > 0) {
+        add_mtd_partitions(mymtds, parsed_parts, nr_parsed_parts);
+    } else {
+        printk("Using static partitions on %s\n", apf9328_map.name);
+        add_mtd_partitions(mymtds, apf9328_partitions, ARRAY_SIZE(apf9328_partitions));
+    }
+    
+    return 0;
+}
+
+static void __exit cleanup_apf9328(void)
+{
+    if (nr_parsed_parts)
+        del_mtd_partitions(mymtds);
+    else
+        del_mtd_device(mymtds);
+
+    map_destroy(mymtds);
+    iounmap((void *)apf9328_map.virt);
+    if (apf9328_map.cached)
+        iounmap(apf9328_map.cached);
+    if (parsed_parts)
+        kfree(parsed_parts);
+}
+
+module_init(init_apf9328);
+module_exit(cleanup_apf9328);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Julien Boibessot");
+MODULE_DESCRIPTION("MTD map driver for apf9328");
diff -uprN -X dontdiff linux-2.6.16/drivers/mtd/maps/Kconfig linux-2.6.16.work/drivers/mtd/maps/Kconfig
--- linux-2.6.16/drivers/mtd/maps/Kconfig  2006-01-23 00:12:43.000000000 +0100
+++ linux-2.6.16.work/drivers/mtd/maps/Kconfig  2005-12-17 17:28:23.000000000 +0100
@@ -422,6 +422,10 @@
 	tristate "CFI Flash device mapped on scb9328 board"
 	depends on ARM && MTD_CFI
 
+config MTD_APF9328
+    tristate "CFI Flash device mapped on APF9328 board"
+    depends on ARM
+
 config MTD_CDB89712
 	tristate "Cirrus CDB89712 evaluation board mappings"
 	depends on MTD_CFI && ARCH_CDB89712
diff -uprN -X dontdiff linux-2.6.16/drivers/mtd/maps/Makefile linux-2.6.16.work/drivers/mtd/maps/Makefile
--- linux-2.6.16/drivers/mtd/maps/Makefile 2006-01-29 22:42:54.000000000 +0100
+++ linux-2.6.16.work/drivers/mtd/maps/Makefile 2006-01-29 22:47:16.000000000 +0100
@@ -69,6 +69,7 @@
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
 obj-$(CONFIG_MTD_MX1FS2)	+= mx1fs2.o
 obj-$(CONFIG_MTD_SCB9328)	+= scb9328.o
+obj-$(CONFIG_MTD_APF9328)   += apf9328.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o

