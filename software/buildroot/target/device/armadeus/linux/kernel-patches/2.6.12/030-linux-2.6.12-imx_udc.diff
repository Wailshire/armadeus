diff -urN linux-2.6.12/arch/arm/mach-imx/generic.c linux-2.6.12.work/arch/arm/mach-imx/generic.c
--- linux-2.6.12/arch/arm/mach-imx/generic.c	2004-12-25 05:35:50.000000000 +0800
+++ linux-2.6.12.work/arch/arm/mach-imx/generic.c	2005-06-20 15:12:26.000000000 +0800
@@ -159,6 +159,15 @@
 }
 EXPORT_SYMBOL(imx_get_hclk);
 
+/*
+ *  get usb_clk
+ */
+unsigned int imx_get_usb_clk(void)
+{
+	return imx_get_system_clk() / (((CSCR>>26) & 0x7)+1);
+}
+EXPORT_SYMBOL(imx_get_usb_clk);
+
 static struct resource imx_mmc_resources[] = {
 	[0] = {
 		.start	= 0x00214000,
@@ -264,11 +273,62 @@
 	.resource	= imxfb_resources,
 };
 
+static struct resource imx_usb_resources[] = {
+	[0] = {
+		.start	= 0x00212000,
+		.end	= 0x00212FFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= USBD_INT0,
+		.end	= USBD_INT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= USBD_INT1,
+		.end	= USBD_INT1,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start	= USBD_INT2,
+		.end	= USBD_INT2,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[4] = {
+		.start	= USBD_INT3,
+		.end	= USBD_INT3,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[5] = {
+		.start	= USBD_INT4,
+		.end	= USBD_INT4,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[6] = {
+		.start	= USBD_INT5,
+		.end	= USBD_INT5,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[7] = {
+		.start	= USBD_INT6,
+		.end	= USBD_INT6,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx_usb_device = {
+	.name		= "imx-usb",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(imx_usb_resources),
+	.resource	= imx_usb_resources,
+};
+
 static struct platform_device *devices[] __initdata = {
 	&imx_mmc_device,
 	&imxfb_device,
 	&imx_uart1_device,
 	&imx_uart2_device,
+	&imx_usb_device,
 };
 
 static struct map_desc imx_io_desc[] __initdata = {

diff -urN linux-2.6.12/drivers/usb/gadget/ether.c linux-2.6.12.work/drivers/usb/gadget/ether.c
--- linux-2.6.12/drivers/usb/gadget/ether.c	2004-12-25 05:35:39.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/ether.c	2005-06-20 15:12:26.000000000 +0800
@@ -2303,6 +2303,9 @@
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0212);
 	} else if (gadget_is_at91(gadget)) {
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0213);
+	} else if (gadget_is_imx(gadget)) {
+		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0214);
+		cdc = 0; //not support altsetting in version 0.5, mikelee
 	} else {
 		/* can't assume CDC works.  don't want to default to
 		 * anything less functional on CDC-capable hardware,

diff -urN linux-2.6.12/drivers/usb/gadget/file_storage.c linux-2.6.12.work/drivers/usb/gadget/file_storage.c
--- linux-2.6.12/drivers/usb/gadget/file_storage.c	2004-12-25 05:36:01.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/file_storage.c	2005-06-20 15:12:26.000000000 +0800
@@ -3755,6 +3755,8 @@
 			mod_data.release = 0x0312;
 		else if (gadget_is_at91(fsg->gadget))
 			mod_data.release = 0x0313;
+		else if (gadget_is_imx(fsg->gadget))
+			mod_data.release = 0x0314;
 		else {
 			WARN(fsg, "controller '%s' not recognized\n",
 				fsg->gadget->name);

diff -urN linux-2.6.12/drivers/usb/gadget/gadget_chips.h linux-2.6.12.work/drivers/usb/gadget/gadget_chips.h
--- linux-2.6.12/drivers/usb/gadget/gadget_chips.h	2004-12-25 05:33:47.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/gadget_chips.h	2005-06-20 15:12:26.000000000 +0800
@@ -26,6 +26,12 @@
 #define	gadget_is_pxa(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_IMX
+#define	gadget_is_imx(g)	!strcmp("imx_udc", (g)->name)
+#else
+#define	gadget_is_imx(g)	0
+#endif
+
 #ifdef CONFIG_USB_GADGET_GOKU
 #define	gadget_is_goku(g)	!strcmp("goku_udc", (g)->name)
 #else

diff -urN linux-2.6.12/drivers/usb/gadget/imx_udc.c linux-2.6.12.work/drivers/usb/gadget/imx_udc.c
--- linux-2.6.12/drivers/usb/gadget/imx_udc.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/imx_udc.c	2005-06-20 15:37:42.000000000 +0800
@@ -0,0 +1,1954 @@
+/*
+ *   driver/usb/gadget/imx_udc.c
+ *
+ * Copyright (C) 2005 Mike Lee(eemike@gmail.com)
+ * 
+ * This udc driver is now under testing and code is based on pxa2xx_udc.c
+ * Please use it with your own risk!
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+*/
+
+/*
+ * support control, bulk, int transfer
+ * no power management, no double buffering, no dma
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/byteorder.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+#include <asm/unaligned.h>
+#include <asm/hardware.h>
+#include <asm/arch/imx-regs.h>
+
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+
+#define DRIVER_VERSION  "0.5"
+#define DRIVER_DESC     "i.MX USB Device Controller driver"
+
+static const char driver_name [] = "imx_udc";
+static const char ep0name [] = "ep0";
+
+
+#ifdef CONFIG_ARCH_IMX
+#undef USE_DMA
+#else
+#error "Only supported on i.MX platform"
+#endif
+
+#include "imx_udc.h"
+
+static struct imx_udc memory;
+static inline void ep0_idle (const char* label,struct imx_udc *dev);
+
+/*
+ * Hardware related function
+ */
+
+void imx_usb_disable(struct imx_udc *dev)
+{
+    USB_CTRL = USB_CTRL & ~(USB_FE_ENA | USB_AFE_ENA); 
+    
+    ep0_idle (__FUNCTION__,dev);
+    dev->gadget.speed = USB_SPEED_UNKNOWN;
+}
+
+void imx_usb_gpio(void)
+{
+    imx_gpio_mode(PB20_PF_USBD_AFE);
+    imx_gpio_mode(PB21_PF_USBD_OE);
+    imx_gpio_mode(PB22_PF_USBD_RCV);
+    imx_gpio_mode(PB23_PF_USBD_SUSPND);
+    imx_gpio_mode(PB24_PF_USBD_VP);
+    imx_gpio_mode(PB25_PF_USBD_VM);
+    imx_gpio_mode(PB26_PF_USBD_VPO);
+    imx_gpio_mode(PB27_PF_USBD_VMO);
+}
+
+// Perform reset and wait for device to be properly reseted
+void imx_usb_reset(struct imx_udc *dev)
+{
+    /* set RST bit */
+    USB_ENAB = USB_ENAB | USB_RST;
+    
+    /* Wait for the device to be properly reset (after writing to RST bit, wait for it to clear) before accessing the device registers. */
+    do {} while (USB_ENAB & USB_RST);
+    
+    /* Wait for the CFG bit in the USB_DDAR register to assert before attempting to communicate with the UDC. */
+    do {} while (!(USB_DADR & USB_CFG));
+    
+    /* udc module is now full reset */
+}
+
+// Download configuration data to the device.s USB Descriptor RAM/Endpoint Buffer Data
+int imx_download_conf(struct imx_udc *dev)
+{
+    u8 ep_conf[5];
+    u8 i,j;
+    struct imx_ep *ep;
+
+    /* wait CFG bit to assert. This ensures that the UDC is fully reset and is ready to take data. */
+    do {} while (!(USB_DADR & USB_CFG));
+
+    // the default pipe (Control Endpoint) must contain the value 0x0000080000.
+    for (j=0;j<5;j++) {
+        USB_DDAT = (u32)(j==2 ? dev->ep[0].wMaxPacketSize:0x00);
+        // Wait until write byte operation is complete
+        do {} while(USB_DADR & USB_BSY);
+    } 
+
+    /* only default the configuration to i.MX platform */
+    for (i=1;i<IMX_USB_NB_EP;i++)
+    {
+        // Get values from given paramater
+        ep = &dev->ep[i];
+        /* EP no | configuration no | Interface no*/
+        ep_conf[0] = ((EP_NO(ep) << 4) | 1 << 2 | 0) & 0xFF;
+        /* Alt setting | type | Direction | max pkt size(partly)*/
+        ep_conf[1] = (0 | (ep->bmAttributes << 3) |
+                (EP_DIR(ep) << 2) | (0)) & 0xFF;
+        /* max pkt size(partly) */
+        ep_conf[2] = ep->wMaxPacketSize & 0xFF;
+        /* TRXTYP */
+//     ep_conf[3] = (i) ? 0xC0 : 0;
+        ep_conf[3] = (i) ? 0xFF : 0;
+        /* FIFO no */
+        ep_conf[4] = i;
+        D3("ep_conf[%d] : [%02x-%02x-%02x-%02x-%02x]\n",i,
+        ep_conf[0],ep_conf[1],ep_conf[2],ep_conf[3],ep_conf[4]);
+
+        // Fill in Descriptor RAM with values got
+        for (j=0;j<5;j++) {
+            USB_DDAT = (u32)ep_conf[j];
+            do {} while(USB_DADR & USB_BSY);
+        } 
+    }
+
+    for (i=1;i<IMX_USB_NB_EP;i++){
+        ep = &dev->ep[i];
+        /* EP no | configuration no | Interface no*/
+        ep_conf[0] = ((EP_NO(ep) << 4) | 2 << 2 | 0) & 0xFF;
+        /* Alt setting | type | Direction | max pkt size(partly)*/
+        ep_conf[1] = (0 | (ep->bmAttributes << 3) |
+                    (EP_DIR(ep) << 2) | (0)) & 0xFF;
+        /* max pkt size(partly) */
+        ep_conf[2] = ep->wMaxPacketSize & 0xFF;
+        /* TRXTYP */
+        ep_conf[3] = (i) ? 0xFF : 0;
+        /* FIFO no */
+        ep_conf[4] = i;
+        
+        D3("ep_conf[%d] : [%02x-%02x-%02x-%02x-%02x-%02x]\n",i,ep_conf[0],
+                ep_conf[1],ep_conf[2],ep_conf[3],ep_conf[4],ep_conf[5]);
+
+        for (j=0;j<5;j++) {
+            USB_DDAT = (u32)ep_conf[j];
+            do {} while(USB_DADR & USB_BSY);
+        } 
+    }
+    
+    return (USB_DADR & USB_CFG) ? -1 : 0;
+}
+
+
+void imx_init_intr(void)
+{
+    int i;
+
+    /* block all irqs */
+    USB_MASK = 0xFFFFFFFF;
+    for (i=0; i<IMX_USB_NB_EP; i++){
+        USB_EP_MASK(i) = 0xFFFFFFFF;
+    }
+
+    // Program the USB Interrupt Mask (USB_MASK) to enable interrupts not associated with a particular endpoint
+    USB_MASK = 0x0 | USB_MSOF | USB_FRAME_MATCH;
+    
+    // Program each Endpoint n Interrupt Mask (USB_EPn_MASK) to support the intended data transfer modes.
+    USB_EP_MASK(0) = 0x1FF & ~USB_DEVREQ & ~USB_EOT & ~USB_EOF;
+    for (i=1;i<IMX_USB_NB_EP;i++){
+        USB_EP_MASK(i) = 0x1FA;
+    }
+}
+
+// Program endpoint type, direction, and maximum packet size for each endpoint
+void imx_init_ep(struct imx_udc *dev)
+{
+    int i,max;
+    struct imx_ep *ep;
+    
+    // Program endpoint type, direction, and maximum packet size in the USB_EPn_STAT register for each endpoint.
+    for (i=0; i<IMX_USB_NB_EP; i++)
+    {
+        ep = &dev->ep[i];
+        switch (ep->wMaxPacketSize) 
+        {
+            case 8:  max=0; /*0x00*/ break;
+            
+            default:
+            case 16: max=1; /*0x01*/ break;
+            
+            case 32: max=2; /*0x10*/ break;
+            
+            case 64: max=3; /*0x11*/ break;
+        }
+        USB_EP_STAT(i) = (EP_DIR(ep) << 7) | (max << 5) | (ep->bmAttributes << 3) | (0);
+        USB_EP_STAT(i) = USB_EP_STAT(i) | USB_FLUSH;
+        D3("ep%d_stat %08x\n",i,USB_EP_STAT(i));       
+    }
+}
+
+// Program the FIFO control registers. For each enabled endpoint programs: frame mode, granularity, alarm level
+void imx_init_fifo(struct imx_udc *dev)
+{
+    int i;
+    struct imx_ep *ep;
+    
+    for (i=0; i<IMX_USB_NB_EP; i++)
+    {
+        ep = &dev->ep[i];
+        USB_EP_FCTRL(i) = EP_DIR(ep) ? 0x0B000000 : 0x0F000000; //FIXME:no hardcode
+        D3("ep%d_fctrl %08x\n",i,USB_EP_FCTRL(i));     
+        // alarm set when w/wo max pkt size data
+        USB_EP_FALRM(i) = (i==0 ? 0 :ep->wMaxPacketSize);
+        D3("ep%d_falrm %08x\n",i,USB_EP_FALRM(i));     
+    }
+}
+
+void imx_usb_enable(struct imx_udc *dev)
+{
+    USB_CTRL = USB_CTRL | USB_FE_ENA | USB_AFE_ENA; 
+}
+
+int imx_ep_empty(struct imx_ep *ep)
+{
+    return (USB_EP_FSTAT(EP_NO(ep)) & USB_EMPTY);
+}
+
+unsigned imx_fifo_bcount(struct imx_ep *ep)
+{
+    return ((USB_EP_STAT(EP_NO(ep)) & USB_FIFO_BCOUNT) >> 16);
+}
+
+void imx_flush(struct imx_ep *ep)
+{
+    USB_EP_STAT(EP_NO(ep)) = USB_EP_STAT(EP_NO(ep)) | USB_FLUSH;
+}
+
+void imx_force_stall(struct imx_ep *ep)
+{
+    unsigned int i;
+    
+    imx_flush(ep);
+    USB_EP_STAT(EP_NO(ep)) = USB_EP_STAT(EP_NO(ep)) | USB_STALL;
+    
+    for (i = 0; i < 1000; i += 20) {
+        if (!(USB_EP_STAT(EP_NO(ep)) & USB_STALL))
+            break;
+        udelay(20);
+    }
+    if (i == 1000)
+        D3("Non finished stall on %s\n",ep->ep.name);
+}
+
+void ep0_chg_stat(const char* label, struct imx_udc *dev, enum ep0_state stat)
+{
+    enum ep0_state old = dev->ep0state;
+    
+    if (dev->ep0state == stat) return;
+    
+    dev->ep0state = stat;
+    
+    D(label,"FROM %15s TO %15s",state_name[old],state_name[stat]);
+} 
+
+
+/* ---------------------------------------------------------------------------
+ *     endpoint related parts of the api to the usb controller hardware,
+ * used by gadget driver; and the inner talker-to-hardware core.
+ * ---------------------------------------------------------------------------
+ */
+
+static void imx_ep_fifo_flush (struct usb_ep *ep);
+static void nuke (struct imx_ep *, int status);
+
+/*
+ * endpoint enable/disable
+ *
+ * we need to verify the descriptors used to enable endpoints.  since imx
+ * endpoint configurations are fixed, and are pretty much always enabled,
+ * there's not a lot to manage here.
+ *
+ */
+static int imx_ep_enable (struct usb_ep *_ep,
+        const struct usb_endpoint_descriptor *desc)
+{
+    struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
+    struct imx_udc       *dev;
+    unsigned long flags;
+
+    if (!_ep || !desc || ep->desc || _ep->name == ep0name
+            || desc->bDescriptorType != USB_DT_ENDPOINT
+            || ep->bEndpointAddress != desc->bEndpointAddress
+            || ep->wMaxPacketSize < le16_to_cpu
+                        (desc->wMaxPacketSize)) {
+        D1("%s, bad ep or descriptor\n", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    /* xfer types must match, except that interrupt ~= bulk */
+    if (ep->bmAttributes != desc->bmAttributes
+            && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+            && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
+        D1("%s, %s type mismatch\n", __FUNCTION__, _ep->name);
+        return -EINVAL;
+    }
+
+    /* hardware _could_ do smaller, but driver doesn't */
+    if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+                && le16_to_cpu (desc->wMaxPacketSize)
+                        != BULK_MAX_SIZE)
+            || !desc->wMaxPacketSize) {
+        D1("%s, bad %s maxpacket\n", __FUNCTION__, _ep->name);
+        return -ERANGE;
+    }
+
+    dev = ep->dev;
+    if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+        D1("%s, bogus device state\n", __FUNCTION__);
+        return -ESHUTDOWN;
+    }
+
+    local_irq_save(flags);
+
+    ep->desc = desc;
+    ep->stopped = 0;
+    ep->irqs = 0;
+    ep->ep.maxpacket = le16_to_cpu (desc->wMaxPacketSize);
+
+    local_irq_restore(flags);
+
+    /* flush fifo (mostly for OUT buffers) */
+    //imx_ep_fifo_flush (_ep);
+
+    D1("enabled %s\n", _ep->name);
+    return 0;
+}
+
+static int imx_ep_disable (struct usb_ep *_ep)
+{
+    struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
+    unsigned long flags;
+
+    if (!_ep || !ep->desc) {
+        D1("%s, %s not enabled\n", __FUNCTION__,
+            _ep ? ep->ep.name : NULL);
+        return -EINVAL;
+    }
+    nuke (ep, -ESHUTDOWN);
+
+    /* flush fifo (mostly for IN buffers) */
+    //imx_ep_fifo_flush (_ep);
+
+    local_irq_save(flags);
+
+    ep->desc = 0;
+    ep->stopped = 1;
+
+    local_irq_restore(flags);
+
+    D1("%s disabled\n", _ep->name);
+    return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ *     imx_ep_alloc_request - allocate a request data structure
+ */
+static struct usb_request *
+imx_ep_alloc_request (struct usb_ep *_ep, int gfp_flags)
+{
+    struct imx_request *req;
+
+    req = kmalloc (sizeof *req, gfp_flags);
+    if (!req)
+        return 0;
+
+    memset (req, 0, sizeof *req);
+    INIT_LIST_HEAD (&req->queue);
+    return &req->req;
+}
+
+
+/*
+ *     imx_ep_free_request - deallocate a request data structure
+ */
+static void
+imx_ep_free_request (struct usb_ep *_ep, struct usb_request *_req)
+{
+    struct imx_request *req;
+
+    req = container_of (_req, struct imx_request, req);
+    if (!req) {
+        D1("req doesn't exist\n");
+        return;
+    }
+    WARN_ON (!list_empty (&req->queue));
+    kfree(req);
+}
+
+static void *
+imx_ep_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
+    dma_addr_t *dma, int gfp_flags)
+{
+    void           *retval;
+
+    retval = kmalloc (bytes, gfp_flags & ~(__GFP_DMA|__GFP_HIGHMEM));
+    if (retval)
+        *dma = virt_to_phys (retval);
+    return retval;
+}
+
+static void
+imx_ep_free_buffer(struct usb_ep *_ep, void *buf, dma_addr_t dma, unsigned bytes)
+{
+    if (buf) kfree (buf);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * done - retire a request; caller blocked irqs
+ */
+static void done(struct imx_ep *ep, struct imx_request *req, int status)
+{
+    unsigned       stopped = ep->stopped;
+
+    list_del_init(&req->queue);
+
+    if (likely (req->req.status == -EINPROGRESS))
+        req->req.status = status;
+    else
+        status = req->req.status;
+
+    if (status && status != -ESHUTDOWN) 
+        D3("complete %s req %p stat %d len %u/%u\n",
+        ep->ep.name, &req->req, status,
+        req->req.actual, req->req.length);
+
+    /* don't modify queue heads during completion callback */
+    ep->stopped = 1;
+    req->req.complete(&ep->ep, &req->req);
+    ep->stopped = stopped;
+}
+
+
+static inline void ep0_idle (const char* label, struct imx_udc *dev)
+{
+    ep0_chg_stat(label, dev, EP0_IDLE);
+}
+
+static int write_packet(struct imx_ep *ep, struct imx_request *req, unsigned max)
+{
+    u8     *buf,tmp;
+    unsigned   length, count;
+
+    buf = req->req.buf + req->req.actual;
+    prefetch(buf);
+
+    /* how big will this packet be? */
+    length = min(req->req.length - req->req.actual, max);
+
+    if (imx_fifo_bcount(ep)+length > ep->fifosize) {
+        D4("packet overfill %s fifo, wait.. \n",ep->ep.name);
+        return -1;
+        imx_flush(ep);
+    }
+
+    req->req.actual += length;
+
+    count = length;
+    D4("count<%d>, fifo remain<%d>\n",count,ep->fifosize - imx_fifo_bcount(ep));
+    
+    if (!count && req->req.zero) {/* zero byte */ 
+        USB_EP_STAT(EP_NO(ep)) |= USB_ZLPS;
+        D3("zero packet\n");
+        return 0;
+    }
+
+//FIXME: find better solution
+#if 0
+    u32        *tmp1;
+    while (count >> 2) {
+        if (count == 4) {
+            USB_EP_FCTRL(EP_NO(ep)) = USB_EP_FCTRL(EP_NO(ep)) | USB_WFR;
+            //D4("end of frame marked\n");
+        }
+        tmp1 = (u32*)buf;
+        USB_EP_FDAT(EP_NO(ep)) = cpu_to_be32(*tmp1);
+        count -= 4;
+        buf += 4;
+        D4("byte wrote<%08x>;fifo count <%d>\n",
+            *tmp1,imx_fifo_bcount(ep));
+    }
+#endif
+    while (count--){
+        if (imx_fifo_bcount(ep)==ep->fifosize)
+            D3("fifo reach limit\n");
+
+        if (count == 0/* last byte */) {
+            USB_EP_FCTRL(EP_NO(ep)) = USB_EP_FCTRL(EP_NO(ep)) | USB_WFR;
+            //D4("end of frame marked\n");
+        }
+        tmp = *buf++;
+        USB_EP_FDAT0(EP_NO(ep)) = tmp; //byte write action
+        D4("byte written<%02x>;fstat<%08x>;fifo count <%d>\n",
+            tmp,USB_EP_FSTAT(EP_NO(ep)),imx_fifo_bcount(ep));
+    }
+
+    return length;
+}
+
+static int write_fifo (struct imx_ep *ep, struct imx_request *req)
+{
+    int    count;
+    int        is_short;
+
+    is_short = 0;
+    D3("write %s req %08x, fifo stat<%08x>\n",
+        ep->ep.name,req,USB_EP_FSTAT(EP_NO(ep)));
+    while(!is_short)
+    {
+        D4("fifostat<%08x> fifoctrl<%08x> fcount<%d>\n",USB_EP_FSTAT(EP_NO(ep)),
+            USB_EP_FCTRL(EP_NO(ep)),imx_fifo_bcount(ep));
+
+        count = write_packet(ep, req, ep->wMaxPacketSize);
+        if (count < 0) return is_short; /* busy */
+        //if (count < 0) continue; /* busy */
+        ep->dev->stats.write.bytes += count;
+
+        /* last packet "must be" short (or a zlp) */
+        is_short = (count != ep->wMaxPacketSize);
+
+        D4("%s %d bytes %d left\n",ep->ep.name,count,
+            req->req.length - req->req.actual);
+    }
+
+    /* return whenever short packet sent, or fifo full*/
+    return is_short;
+}
+
+static inline void ep0start(struct imx_udc *dev, u32 flags, const char *tag)
+{
+    USB_EP_STAT(0) = USB_EP_STAT(0) | flags;
+    D2("ep0 change status to %s\n",tag);
+}
+
+static int write_ep0_fifo (struct imx_ep *ep, struct imx_request *req)
+{
+    int    count;
+    int        is_short;
+
+    is_short = 0;
+    while(!is_short)
+    {
+        D4("fifostat<%08x> fifoctrl<%08x> fcount<%d>\n",USB_EP_FSTAT(EP_NO(ep)),
+            USB_EP_FCTRL(EP_NO(ep)),imx_fifo_bcount(ep));
+
+        count = write_packet(ep, req, ep->wMaxPacketSize);
+        if (count < 0) break;
+        ep->dev->stats.write.bytes += count;
+
+        /* last packet "must be" short (or a zero lenght packet) */
+        is_short = (count != ep->wMaxPacketSize);
+
+        D4("ep0in %d bytes %d left %p\n", count,
+            req->req.length - req->req.actual, req);
+
+        if (is_short) {
+            done (ep, req, 0);
+            //dump_ep_stat(__FUNCTION__,ep);
+            if (!EP_NO(ep))
+                ep0_idle(__FUNCTION__,ep->dev);
+        }
+    }
+
+    /* return whenever short packet sent, or fifo full*/
+    return is_short;
+}
+
+
+static int
+read_fifo (struct imx_ep *ep, struct imx_request *req)
+{
+    u32 tmp;
+    int i,last;
+
+    D3("read %s fifo, fifo count<%d> fifo stat<%08x>\n",
+        ep->ep.name,imx_fifo_bcount(ep),USB_EP_FSTAT(EP_NO(ep)));
+    for (;;)
+    {
+        u8          *buf,byte;
+        unsigned    bufferspace, count, is_short;
+
+        if (!(USB_EP_FSTAT(EP_NO(ep)) & USB_FR)) {
+            /* 
+            special care! I.MX seem to ignore some EOF, so
+            ensure there is no data in fifo and then out
+            */ 
+            if (imx_fifo_bcount(ep)) continue;
+            D3("no frame ready, fstat<%08x>\n",USB_EP_FSTAT(EP_NO(ep)));
+            return 0;
+        }
+        buf = req->req.buf + req->req.actual;
+        prefetchw(buf);
+        bufferspace = req->req.length - req->req.actual;
+
+        /* read all bytes from this packet */
+        if (!(USB_EP_FSTAT(EP_NO(ep)) & USB_EMPTY)) {
+            //check for available data
+            count = min(imx_fifo_bcount(ep),ep->wMaxPacketSize);
+            req->req.actual += min (count, bufferspace);
+        } else {/* zlp */
+            count = 0;
+        }
+        is_short = (count < ep->wMaxPacketSize);
+        D4("read %s , %d bytes%s req %p %d/%d\n",
+            ep->ep.name, count,
+            is_short ? "/S" : "",
+            req, req->req.actual, req->req.length);
+        i=0;
+        last=0;
+        while (count>0) {
+#if 0
+            if (!(i%4))
+                //tmp = be32_to_cpu(USB_EP_FDAT(EP_NO(ep)));
+                tmp = (USB_EP_FDAT(EP_NO(ep)));
+#else
+            if (last && i) {
+                /* 
+                IMX seem not clear the frame bit if it does
+                not perform a dump read so if it is the
+                start of frame, it will be misunderstood
+                */
+                //D2("host sent frame smaller than the req ,"
+                // "req remain %d\n",count);
+                //is_short = 1;
+                //break;
+            }
+            if ((USB_EP_FSTAT(EP_NO(ep)) & USB_FRAME_STAT) == 0x08000000) {
+                last=1;
+            }
+            int t =imx_fifo_bcount(ep);
+            D4("frame boundary stat <%08x>\n",USB_EP_FSTAT(EP_NO(ep)));
+            tmp = (USB_EP_FDAT0(EP_NO(ep)));
+            if (imx_fifo_bcount(ep)-t > 1) 
+                D1("byte read but fifo count drop %d bytes\n",t);
+#endif
+
+            if (unlikely (bufferspace == 0)) {
+                /* this happens when the driver's buffer
+                * is smaller than what the host sent.
+                * discard the extra data.
+                */
+                if (req->req.status != -EOVERFLOW)
+                    D1("%s overflow %d\n",
+                        ep->ep.name, count);
+                req->req.status = -EOVERFLOW;
+            } else {
+                byte = (u8) tmp&0xFF;
+                *buf++ = byte;
+                bufferspace--;
+                tmp = tmp >> 8;
+            }
+            i++;
+            count--;
+        }
+
+        /* completion */
+        if (is_short || req->req.actual == req->req.length) {
+            if (imx_fifo_bcount(ep) > 0)
+                D3("complete read but fifo byte count %d\n",
+                    imx_fifo_bcount(ep));
+            return 1;
+        }
+
+        /* finished that packet.  the next one may be waiting... */
+    }
+
+    return 0;
+}
+
+#if 0
+static int
+read_ep0_fifo (struct imx_ep *ep, struct imx_request *req)
+{
+   u8      *buf, byte;
+   unsigned    bufferspace;
+
+   POSITION;
+   buf = req->req.buf + req->req.actual;
+   bufferspace = req->req.length - req->req.actual;
+
+   if (USB_EP_FSTAT(EP_NO(ep)) & USB_EMPTY) {
+       return -1;
+   }
+   {
+       //FIXME: check frame boundary
+       //if ((USB_EP_FSTAT(EP_NO(ep))&USB_FRAME_STAT)== 0xF)   
+   
+       byte = USB_EP_FDAT3(EP_NO(ep));
+       if (bufferspace == 0) {
+           /* this happens when the driver's buffer
+            * is smaller than what the host sent.
+            * discard the extra data.
+            */
+           if (req->req.status != -EOVERFLOW)
+               D1("%s overflow\n", ep->ep.name);
+           req->req.status = -EOVERFLOW;
+       } else {
+           *buf++ = byte;
+           req->req.actual++;
+           bufferspace--;
+       }
+   }
+
+   /* completion */
+   if (req->req.actual >= req->req.length)
+       return 1;
+
+   /* finished that packet.  the next one may be waiting... */
+   return 0;
+}
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+
+
+static int
+imx_ep_queue(struct usb_ep *_ep, struct usb_request *_req, int gfp_flags)
+{ 
+    struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
+    struct imx_request *req = container_of(_req, struct imx_request, req);
+    struct imx_udc     *dev;
+    unsigned long      flags;
+
+    if (ep->dev->set_config) {
+        if (!EP_NO(ep)){
+        /*
+            Special care on IMX udc.
+            Ignore enqueue when after set configuration from the host
+            This assume all gadget drivers reply set configuration
+            with the next ep0 req enqueue.
+        */
+            local_irq_save(flags);
+            ep->dev->set_config = 0;
+            local_irq_restore(flags);
+            D2("gadget driver reply set configuration\n");
+            return 0;
+        }
+    }
+    if (!_req || !_req->complete || !_req->buf
+            || !list_empty(&req->queue)
+    ) {
+        D1("%s, bad params\n", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    if (unlikely (!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+        D1("%s, bad ep\n", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    dev = ep->dev;
+    if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+        D1("%s, bogus device state\n", __FUNCTION__);
+        return -ESHUTDOWN;
+    }
+
+
+    D3( "%s queue req %p, len %d buf %p\n",
+        _ep->name, _req, _req->length, _req->buf);
+
+    if ((ep->dev->ep0state==EP0_IN_DATA_PHASE && !EP_NO(ep))
+        || (EP_NO(ep) && EP_DIR(ep)))
+        dump_req(_req);
+
+    local_irq_save(flags);
+
+    _req->status = -EINPROGRESS;
+    _req->actual = 0;
+
+    /* kickstart this i/o queue? */
+    if (list_empty(&ep->queue) && !ep->stopped)
+    {
+        if (EP_NO(ep) == 0 /* ep0 */) {
+            unsigned   length = _req->length;
+
+            switch (dev->ep0state) {
+            case EP0_IN_DATA_PHASE:
+                dev->stats.write.ops++;
+                if (write_ep0_fifo(ep, req))
+                    req = 0;
+                break;
+
+            case EP0_OUT_DATA_PHASE:
+                dev->stats.read.ops++;
+                /* 
+                read_ep0 should handle read zero packet
+                instead serve here
+                */
+                if (length == 0 || read_fifo(ep, req)) {
+                    ep0_idle(__FUNCTION__,dev);
+                    done(ep, req, 0);
+                    req = 0;
+                }
+                break;
+
+            default:
+                D1("ep0 i/o, odd state %d\n", dev->ep0state);
+                local_irq_restore (flags);
+                return -EL2HLT;
+            }
+        }
+        else if (EP_DIR(ep) /* IN:1 */
+        /* can the FIFO satisfy the request immediately? */
+                && write_fifo(ep, req)) {
+            D3("%s req<%08x> completed\n",ep->ep.name,req);
+            done (ep, req, 0);
+            req = 0;
+            //dump_ep_stat(__FUNCTION__,ep);
+        } else if (!EP_DIR(ep) && (read_fifo(ep, req))) {
+            D3("%s req<%08x> completed\n",ep->ep.name,req);
+            done (ep, req, 0);
+            req = 0;
+            //dump_ep_stat(__FUNCTION__,ep);
+        }
+
+    }
+
+    if (req != 0) {
+        list_add_tail(&req->queue, &ep->queue);
+        D3("%s not finish req %p %d bytes %d left\n",ep->ep.name,req,
+            req->req.actual,req->req.length - req->req.actual);
+    }
+    D3("End of enqueue\n");
+
+    local_irq_restore(flags);
+
+    return 0;
+}
+
+
+/*
+ *     nuke - dequeue ALL requests
+ */
+static void nuke(struct imx_ep *ep, int status)
+{
+    struct imx_request *req;
+
+    while (!list_empty(&ep->queue)) {
+        req = list_entry(ep->queue.next,
+                struct imx_request,
+                queue);
+        done(ep, req, status);
+    }
+}
+
+/*
+*  dequeue JUST ONE request
+*/
+static int imx_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+
+    struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
+    struct imx_request *req;
+    unsigned long      flags;
+
+    if (!_ep || ep->ep.name == ep0name)
+        return -EINVAL;
+
+    local_irq_save(flags);
+
+    /* make sure it's actually queued on this endpoint */
+    list_for_each_entry (req, &ep->queue, queue) {
+        if (&req->req == _req)
+            break;
+    }
+    if (&req->req != _req) {
+        local_irq_restore(flags);
+        return -EINVAL;
+    }
+
+    done(ep, req, -ECONNRESET);
+
+    local_irq_restore(flags);
+    return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int imx_ep_set_halt(struct usb_ep *_ep, int value)
+{
+    struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
+    unsigned long      flags;
+
+    if (unlikely (!_ep
+            || (!ep->desc && ep->ep.name != ep0name))
+            || ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
+        D1("%s, bad ep\n", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    local_irq_save(flags);
+
+    if ((ep->bEndpointAddress & USB_DIR_IN) != 0
+            && (!list_empty(&ep->queue))) {
+        local_irq_restore(flags);
+        return -EAGAIN;
+    }
+
+    //TODO: flush ep fifo
+
+    /* ep0 needs special care */
+    if (!EP_NO(ep)) {
+        ep0_chg_stat(__FUNCTION__,ep->dev,EP0_STALL);
+    /* and bulk/intr endpoints like dropping stalls too */
+    } else {
+        imx_force_stall(ep);
+    }
+    local_irq_restore(flags);
+
+    D1("%s halt\n", _ep->name);
+    return 0;
+}
+
+static int imx_ep_fifo_status(struct usb_ep *_ep)
+{
+    struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
+
+    if (!_ep) {
+        D1("%s, bad ep\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    if (ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
+        return 0;
+    else
+        return imx_fifo_bcount(ep);
+}
+
+static void imx_ep_fifo_flush(struct usb_ep *_ep)
+{
+    struct imx_ep  *ep = container_of(_ep, struct imx_ep, ep);
+
+    if (!_ep || ep->ep.name == ep0name || !list_empty(&ep->queue)) {
+        D1("%s, bad ep\n", __FUNCTION__);
+        return;
+    }
+
+    /* toggle and halt bits stay unchanged */
+    imx_flush(ep);
+}
+
+static struct usb_ep_ops imx_ep_ops = {
+    .enable        = imx_ep_enable,
+    .disable   = imx_ep_disable,
+
+    .alloc_request = imx_ep_alloc_request,
+    .free_request  = imx_ep_free_request,
+
+    .alloc_buffer  = imx_ep_alloc_buffer,
+    .free_buffer   = imx_ep_free_buffer,
+
+    .queue     = imx_ep_queue,
+    .dequeue   = imx_ep_dequeue,
+
+    .set_halt  = imx_ep_set_halt,
+    .fifo_status   = imx_ep_fifo_status,
+    .fifo_flush    = imx_ep_fifo_flush,
+};
+
+static int imx_udc_get_frame(struct usb_gadget *_gadget)
+{
+    return 0;
+}
+
+static int imx_udc_wakeup(struct usb_gadget *_gadget)
+{
+    return 0;
+}
+
+static const struct usb_gadget_ops imx_udc_ops = {
+    .get_frame  = imx_udc_get_frame,
+    .wakeup     = imx_udc_wakeup,
+    // i.MX udc must always be self-powered
+};
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * "function" sysfs attribute
+ */
+static ssize_t show_function (struct device *_dev, char *buf)
+{
+    struct imx_udc *dev = dev_get_drvdata (_dev);
+
+    if (!dev->driver
+            || !dev->driver->function
+            || strlen (dev->driver->function) > PAGE_SIZE)
+        return 0;
+    return scnprintf (buf, PAGE_SIZE, "%s\n", dev->driver->function);
+}
+static DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ *     udc_disable - disable USB device controller
+ */
+static void udc_disable(struct imx_udc *dev)
+{
+    imx_usb_disable(dev);
+    ep0_idle (__FUNCTION__,dev);
+    dev->gadget.speed = USB_SPEED_UNKNOWN;
+}
+
+/*
+ *     udc_reinit - initialize software state
+ */
+static void udc_reinit(struct imx_udc *dev)
+{
+    u32    i;
+
+    /* device/ep0 records init */
+    INIT_LIST_HEAD (&dev->gadget.ep_list);
+    INIT_LIST_HEAD (&dev->gadget.ep0->ep_list);
+    ep0_chg_stat(__FUNCTION__,dev,EP0_IDLE);
+
+    /* basic endpoint records init */
+    for (i = 0; i < IMX_USB_NB_EP; i++) 
+    {
+        struct imx_ep *ep = &dev->ep[i];
+
+        if (i != 0)
+            list_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);
+
+        ep->desc = 0;
+        ep->stopped = 0;
+        INIT_LIST_HEAD (&ep->queue);
+        ep->irqs = 0;
+    }
+}
+
+// Device hardware initialization
+//
+// Following chapter 24.5 of iMXl User Manual
+//
+static void udc_hardinit(struct imx_udc *dev)
+{
+    int ret;
+    
+    // Activate USB pins functions
+    imx_usb_gpio();
+
+    // Perform reset and wait for device to be properly reseted
+    imx_usb_reset(dev);
+    
+    // Download configuration data to the device.s USB Descriptor RAM/Endpoint Buffer Data
+    ret = imx_download_conf(dev);
+    if (ret)
+        D1("download conf return <%d>\n",ret);
+    
+    /* Activate USB interrupts */
+    imx_init_intr();
+
+    /* Program endpoint type, direction, and maximum packet size in the USB_EPn_STAT register for each endpoint. */
+    imx_init_ep(dev);
+    
+    /* Program the FIFO control registers. For each enabled endpoint programs: frame mode, granularity, alarm level */
+    imx_init_fifo(dev);
+    
+    /* Enable is done when udc_enable is called */
+}
+
+/*
+ * until it's enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static void udc_enable (struct imx_udc *dev)
+{
+    imx_usb_enable(dev);
+    dev->gadget.speed = USB_SPEED_FULL;
+}
+
+
+/* when a driver is successfully registered, it will receive
+ * control requests including set_configuration(), which enables
+ * non-control requests.  then usb traffic follows until a
+ * disconnect is reported.  then a host may connect again, or
+ * the driver might get unbound.
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+    struct imx_udc *dev = the_controller;
+    int            retval;
+
+    if (!driver
+        || driver->speed != USB_SPEED_FULL
+        || !driver->bind
+        || !driver->unbind
+        || !driver->disconnect
+        || !driver->setup)
+        return -EINVAL;
+    if (!dev)
+        return -ENODEV;
+    if (dev->driver)
+        return -EBUSY;
+
+    /* first hook up the driver ... */
+    dev->driver = driver;
+    dev->gadget.dev.driver = &driver->driver;
+
+    device_add (&dev->gadget.dev);
+    retval = driver->bind(&dev->gadget);
+    if (retval) {
+        D1("bind to driver %s --> error %d\n",
+        driver->driver.name, retval);
+        device_del (&dev->gadget.dev);
+
+        dev->driver = 0;
+        dev->gadget.dev.driver = 0;
+        return retval;
+    }
+    device_create_file(dev->dev, &dev_attr_function);
+
+    /* ... then enable host detection and ep0; and we're ready
+    * for set_configuration as well as eventual disconnect.
+    * NOTE:  this shouldn't power up until later.
+    */
+    D1("registered gadget driver '%s'\n", driver->driver.name);
+    udc_disable(dev);
+    udc_reinit(dev);
+    udc_enable(dev);
+    dev->dev_config = 0;
+    dump_state(__FUNCTION__);
+    return 0;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+static void
+stop_activity(struct imx_udc *dev, struct usb_gadget_driver *driver)
+{
+    int i;
+    if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+        driver = 0;
+    /* prevent new request submissions, kill any outstanding requests  */
+    for (i = 0; i < IMX_USB_NB_EP; i++) {
+        struct imx_ep *ep = &dev->ep[i];
+
+        imx_flush(ep);
+        ep->stopped = 1;
+        nuke(ep, -ESHUTDOWN);
+    }
+    dev->gadget.speed = USB_SPEED_UNKNOWN;
+    if (driver) {
+        dev->dev_config = 0;
+        driver->disconnect(&dev->gadget);
+    }
+
+    /* re-init driver-visible data structures */
+    udc_reinit(dev);
+}
+
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+    struct imx_udc *dev = the_controller;
+
+    if (!dev)
+        return -ENODEV;
+    if (!driver || driver != dev->driver)
+        return -EINVAL;
+
+    local_irq_disable();
+    udc_disable(dev);
+    stop_activity(dev, driver);
+    local_irq_enable();
+
+    driver->unbind(&dev->gadget);
+    dev->driver = 0;
+
+    device_del (&dev->gadget.dev);
+    device_remove_file(dev->dev, &dev_attr_function);
+
+    D1("unregistered gadget driver '%s'\n", driver->driver.name);
+    dump_state(__FUNCTION__);
+    return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+
+/*-------------------------------------------------------------------------*/
+
+static int handle_ep0 (struct imx_udc *dev)
+{
+    struct imx_ep  *ep = &dev->ep [0];
+    struct imx_request *req=0;
+    union {
+        struct usb_ctrlrequest r;
+        u8         raw [8];
+        u32            word [2];
+    } u;
+
+    if (!list_empty(&ep->queue))
+        req = list_entry(ep->queue.next, struct imx_request, queue);
+
+    /* previous request unfinished?  non-error iff back-to-back ... */
+    if ((USB_EP_INTR(EP_NO(ep)) & USB_DEVREQ) && dev->ep0state != EP0_IDLE) {
+        nuke(ep, 0);
+        ep0_idle(__FUNCTION__,dev);
+    }
+
+    switch (dev->ep0state) {
+    case EP0_STALL:    //stall is clear by hardware auto
+        ep0_chg_stat(__FUNCTION__,dev,EP0_IDLE);
+        //dev->ep0state = EP0_IDLE;
+    case EP0_IDLE:
+        /* start control request? */
+    {
+        int i;
+            
+        nuke (ep, -EPROTO);
+        /* read SETUP packet */
+        for (i = 0; i < 2; i++) {
+            if (imx_ep_empty(ep)) {
+            bad_setup:
+                D1("SETUP %d!\n", i);
+
+                le16_to_cpus (&u.r.wValue);
+                le16_to_cpus (&u.r.wIndex);
+                le16_to_cpus (&u.r.wLength);
+                D2("SETUP %02x.%02x v%04x i%04x l%04x\n",
+                u.r.bRequestType, u.r.bRequest,
+                u.r.wValue, u.r.wIndex, u.r.wLength);
+                goto stall;
+            }
+            u.word[i] = USB_EP_FDAT(EP_NO(ep));
+            //u.word[i] = be32_to_cpu(tmp);
+        }
+        if (!imx_ep_empty(ep))
+            goto bad_setup;
+
+        le16_to_cpus (&u.r.wValue);
+        le16_to_cpus (&u.r.wIndex);
+        le16_to_cpus (&u.r.wLength);
+
+        D2("SETUP %02x.%02x v%04x i%04x l%04x\n",
+        u.r.bRequestType, u.r.bRequest,
+        u.r.wValue, u.r.wIndex, u.r.wLength);
+
+        if (dev->set_config) {
+            /* if set config is pending , we must NACK the host
+            by using CMDOVER
+            */
+            USB_CTRL = USB_CTRL | USB_CMDOVER;
+            D2("set config req is pending,NACK the host\n");
+            return 0;
+        }
+
+#ifdef LV3
+            switch (u.r.bRequest) {
+            //TODO: print standard request
+            }
+#endif
+
+            if (u.r.bRequestType & USB_DIR_IN)
+                ep0_chg_stat(__FUNCTION__,dev,EP0_IN_DATA_PHASE);
+            else
+                ep0_chg_stat(__FUNCTION__,dev,EP0_OUT_DATA_PHASE);
+
+            if (!dev->driver) 
+                i = -1;
+            else
+                i = dev->driver->setup(&dev->gadget, &u.r);
+            if (i < 0) {
+                D1("protocol STALL, "
+                    "ep0 err %d\n", i);
+stall:
+                imx_force_stall(ep);
+                ep0_chg_stat(__FUNCTION__,dev,EP0_STALL);
+                //dump_ep_stat(__FUNCTION__,ep);
+            }
+
+            return 0;
+        }
+        break;
+    case EP0_IN_DATA_PHASE:            /* GET_DESCRIPTOR etc */
+        if (req) {
+            /* this IN packet might finish the request */
+            if (write_ep0_fifo(ep, req)) {
+                //done(ep,req,0);
+                //ep0_idle(__FUNCTION__,dev);
+            }
+        } /* else IN token before response was written */
+        break;
+    case EP0_OUT_DATA_PHASE:       /* SET_DESCRIPTOR etc */
+        if (req) {
+            /* this OUT packet might finish the request */
+            if (read_fifo(ep, req)) {
+                done(ep, req, 0);
+                ep0_idle(__FUNCTION__,dev);
+            }
+            /* else more OUT packets expected */
+        } /* else OUT token before read was issued */
+        break;
+    case EP0_END_XFER:
+        if (req)
+            done(ep, req, 0);
+        /* ack control-IN status (maybe in-zlp was skipped)
+        * also appears after some config change events.
+        */
+        ep0_idle(__FUNCTION__,dev);
+        break;
+    }
+    return 0;
+}
+
+static int handle_ep(struct imx_ep *ep)
+{
+    struct imx_request *req;
+    int            completed;
+
+    do {
+        completed = 0;
+        if (!list_empty(&ep->queue))
+            req = list_entry(ep->queue.next,
+                    struct imx_request, queue);
+        else {
+            D3("no request on %s\n",ep->ep.name);
+            return 0;
+        }
+
+        if (EP_DIR(ep)) {  /* to host */
+            completed = write_fifo(ep, req);
+#if 0
+            //write fifo need to wait for available of the fifo,
+            //so if not completed, just go out and wait eof/eot
+            if (!completed)
+                return 0;
+#endif
+
+        } else {   /* to device */
+            /* fifos can hold packets, ready for reading... */
+            completed = read_fifo(ep, req);
+        }
+        D3("%s req<%08x> %s\n",ep->ep.name,req,
+        completed?"completed":"not completed");
+        if (completed) {
+            done (ep, req, 0);
+            //dump_ep_stat(__FUNCTION__,ep);
+            if (!EP_NO(ep))
+                ep0_idle(__FUNCTION__,ep->dev);
+        }
+    //} while (1);
+    } while (completed);
+    return 0;
+}
+
+/*
+ * imx_udc_irq - interrupt handler
+ *
+ * avoid delays in ep0 processing. the control handshaking isn't always
+ * under software control 
+ */
+static irqreturn_t
+imx_udc_irq(int irq, void *_dev, struct pt_regs *r)
+{
+    struct imx_udc  *dev = _dev;
+
+    dev->stats.irqs++;
+
+    if (!dev->driver) {
+        udc_disable(dev);
+        USB_INTR = USB_INTR;
+
+        return IRQ_HANDLED;
+    }
+
+    do {
+        if ((USB_INTR != USB_SOF) //reduce dumping sof-only intr
+            && (USB_INTR != (USB_SOF | USB_FRAME_MATCH))
+            && (USB_INTR != (USB_SOF | USB_MSOF))
+        ) {
+            dump_intr(__FUNCTION__);
+        }
+
+
+        if (USB_INTR & USB_WAKEUP){
+            if (dev->gadget.speed == USB_SPEED_UNKNOWN
+                && dev->driver
+                && dev->driver->resume)
+                dev->driver->resume(&dev->gadget);
+            /* ignore all other interrupt */
+            USB_INTR = USB_INTR;
+            dev->set_config = 0;
+            dev->gadget.speed = USB_SPEED_FULL;
+        }
+        
+        if (USB_INTR & USB_SUSP){
+//TODO: suspend handle
+            //stop_activity (dev, dev->driver);
+            //udc_disable(dev);
+            if (dev->gadget.speed != USB_SPEED_UNKNOWN
+                && dev->driver
+                && dev->driver->suspend)
+                dev->driver->suspend(&dev->gadget);
+            dev->gadget.speed = USB_SPEED_UNKNOWN;
+        }
+
+        if (USB_INTR & USB_RES){
+//TODO: resume handle
+            //udc_reinit(dev);
+            //udc_enable(dev);
+
+        }
+
+        if (USB_INTR & USB_RESET_START){
+//TODO: reset handle
+#if 1
+            stop_activity (dev, dev->driver);
+            dev->set_config = 0;
+            /* ignore all other interrupt */
+            USB_INTR = USB_INTR;
+            dev->gadget.speed = USB_SPEED_FULL;
+#endif
+        }
+
+        if (USB_INTR & USB_RESET_STOP) {
+#if 1
+            dev->gadget.speed = USB_SPEED_FULL;
+            //dev->driver->resume(&dev->gadget);
+#endif
+        }
+
+        if (USB_INTR & USB_CFG_CHG){
+            struct usb_ctrlrequest u;
+            unsigned long flags;
+
+            D2("host set config req, USB_STAT<%08x>\n",USB_STAT);
+            u.bRequest = USB_REQ_SET_CONFIGURATION;
+            u.bRequestType = (USB_DIR_OUT | USB_TYPE_STANDARD
+                    | USB_RECIP_DEVICE);
+            u.wValue = (USB_STAT & (3<<5)) >> 5;
+            D2("orig config #%d , req config #%d\n",
+            dev->dev_config,u.wValue);
+            if (u.wValue != 1 && u.wValue != 2)
+                break; /* can not happen */
+
+            local_irq_save(flags);
+            /* should make it aware to gadget driver, but 
+            some gadget drivers will perform an async on 
+            set config req, so 2 solutions:
+            1) disable all gadget configuration response
+                in the gadget driver
+            2) neglect any set_config response before enqueue 
+
+            I choose to use (2) which don't need to change gadget driver
+            */
+#if 1
+            if (dev->dev_config != u.wValue) {
+                dev->dev_config = u.wValue;
+                dev->set_config = 1;
+                dev->driver->setup(&dev->gadget,&u);
+            } else dev->set_config = 0;
+#else
+            dev->set_config = 0;
+            //ep0_chg_stat(__FUNCTION__,dev,EP0_IN_DATA_PHASE);
+#endif
+            //USB_MASK = USB_MASK | USB_CFG_CHG;
+            local_irq_restore(flags);
+            break;
+            
+        }
+        if (USB_INTR & USB_SOF) {
+            /* copy from motorola bsp.
+            We must enable SOF intr and signal CMDOVER.
+            Datasheet don't specifiy this action, but it
+            is done in motorola bsp, so just copy it
+            */
+            if (dev->ep0state==EP0_IDLE)
+            {
+                USB_CTRL = USB_CTRL | USB_CMDOVER;
+                //ep0_idle(__FUNCTION__,dev);
+            }
+            //USB_MASK = USB_MASK | USB_SOF;
+        }
+
+        break;
+
+    } while (1);
+    
+    //clear intr
+    USB_INTR= USB_INTR;
+
+    return IRQ_HANDLED;
+}
+
+/*
+ * imx_udc_ctrl_irq - interrupt handler
+ */
+static irqreturn_t imx_udc_ctrl_irq(int irq, void *_dev, struct pt_regs *r)
+{
+    struct imx_udc *dev = _dev;
+    //unsigned long flags;
+
+    dev->stats.irqs++;
+
+    if (!dev->driver) {
+        udc_disable(dev);
+        USB_EP_INTR(0)= USB_EP_INTR(0);
+
+        return IRQ_HANDLED;
+    }
+    
+    //local_irq_save(flags);
+    if (USB_EP_INTR(0) & USB_DEVREQ){
+        if (handle_ep0(dev) == -1)
+            imx_force_stall(&dev->ep[0]);
+    } else if ((USB_EP_INTR(0) & USB_EOF) && (dev->ep0state != EP0_IDLE)) {
+        if (handle_ep0(dev)==-1)
+            imx_force_stall(&dev->ep[0]);
+    }
+    //local_irq_restore(flags);
+    USB_EP_INTR(0)= USB_EP_INTR(0);
+    return IRQ_HANDLED;
+}
+
+/*
+ * imx_udc_bulk_irq - interrupt handler
+ *
+ */
+static irqreturn_t imx_udc_bulk_irq(int irq, void *_dev, struct pt_regs *r)
+{
+    struct imx_udc *dev = _dev;
+    struct imx_ep  *ep = &dev->ep[irq-USBD_INT0]; //XXX: use a function instead
+    unsigned long flags;
+
+    dev->stats.irqs++;
+
+    if (!dev->driver) {
+        udc_disable(dev);
+        USB_EP_INTR(EP_NO(ep))= USB_EP_INTR(EP_NO(ep));
+
+        return IRQ_HANDLED;
+    }
+
+    local_irq_save(flags);
+    if (handle_ep(ep)== -1)
+        imx_force_stall(ep);
+    local_irq_restore(flags);
+    USB_EP_INTR(EP_NO(ep))= USB_EP_INTR(EP_NO(ep));
+    
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t imx_udc_int_irq(int irq, void *_dev, struct pt_regs *r)
+{
+    imx_udc_bulk_irq(irq,_dev,r);
+
+    return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void nop_release (struct device *dev)
+{
+    D1("%s %s\n", __FUNCTION__, dev->bus_id);
+}
+
+/* this uses load-time allocation and initialization (instead of
+ * doing it at run-time) to save code, eliminate fault paths, and
+ * be more obviously correct.
+ */
+static struct imx_udc memory = {
+    .gadget = {
+        .ops       = &imx_udc_ops,
+        .ep0       = &memory.ep[0].ep,
+        .name      = driver_name,
+        .dev = {
+            .bus_id        = "gadget",
+            .release   = nop_release,
+        },
+    },
+
+    /* control endpoint */
+    .ep[0] = {
+        .ep = {
+            .name      = ep0name,
+            .ops       = &imx_ep_ops,
+            .maxpacket = EP0_MAX_SIZE,
+        },
+        .dev       = &memory,
+        .wMaxPacketSize    = EP0_MAX_SIZE,
+        .fifosize  = 32,
+        .bEndpointAddress = 0,
+        .bmAttributes  = USB_ENDPOINT_XFER_CONTROL,
+    },
+
+    /* first group of endpoints */
+    .ep[1] = {
+        .ep = {
+            .name      = "ep1in-bulk",
+            .ops       = &imx_ep_ops,
+            .maxpacket = BULK_MAX_SIZE,
+        },
+        .dev       = &memory,
+        .wMaxPacketSize    = BULK_MAX_SIZE,
+        .fifosize  = 64,
+        .bEndpointAddress = USB_DIR_IN | 1,
+        .bmAttributes  = USB_ENDPOINT_XFER_BULK,
+    },
+    .ep[2] = {
+        .ep = {
+            .name      = "ep2out-bulk",
+            .ops       = &imx_ep_ops,
+            .maxpacket = BULK_MAX_SIZE,
+        },
+        .dev       = &memory,
+        .wMaxPacketSize    = BULK_MAX_SIZE,
+        .fifosize  = 64,
+        .bEndpointAddress = 2,
+        .bmAttributes  = USB_ENDPOINT_XFER_BULK,
+    },
+#ifndef CONFIG_USB_IMX_SMALL
+    .ep[3] = {
+        .ep = {
+            .name      = "ep3out-bulk",
+            .ops       = &imx_ep_ops,
+            .maxpacket = BULK_MAX_SIZE,
+        },
+        .dev       = &memory,
+        .wMaxPacketSize    = BULK_MAX_SIZE,
+        .fifosize  = 32,
+        .bEndpointAddress = 3,
+        .bmAttributes  = USB_ENDPOINT_XFER_BULK,
+    },
+    .ep[4] = {
+        .ep = {
+            .name      = "ep4in-int",
+            .ops       = &imx_ep_ops,
+            .maxpacket = INT_MAX_SIZE,
+        },
+        .dev       = &memory,
+        .wMaxPacketSize    = INT_MAX_SIZE,
+        .fifosize  = 32,
+        .bEndpointAddress = USB_DIR_IN | 4,
+        .bmAttributes  = USB_ENDPOINT_XFER_INT,
+    },
+    .ep[5] = {
+        .ep = {
+            .name      = "ep5out-int",
+            .ops       = &imx_ep_ops,
+            .maxpacket = INT_MAX_SIZE,
+        },
+        .dev       = &memory,
+        .wMaxPacketSize    = INT_MAX_SIZE,
+        .fifosize  = 32,
+        .bEndpointAddress = 5,
+        .bmAttributes  = USB_ENDPOINT_XFER_INT,
+    },
+
+#endif /* !CONFIG_USB_IMX_SMALL */
+};
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+static const char proc_node_name [] = "driver/udc";
+
+static int
+udc_proc_read(char *page, char **start, off_t off, int count, int *eof, void *_dev)
+{
+    char            *buf = page;
+    struct imx_udc  *dev = _dev;
+    char            *next = buf;
+    unsigned        size = count;
+    unsigned long   flags;
+    int             i, t;
+
+    if (off != 0)
+        return 0;
+
+    local_irq_save(flags);
+
+    /* basic device status */
+    t = scnprintf(next, size, DRIVER_DESC "\n"
+        "%s version: %s\nGadget driver: %s\nHost %s\n",
+        driver_name, DRIVER_VERSION,
+        dev->driver ? dev->driver->driver.name : "(none)",
+        is_usb_connected() ? "full speed" : "disconnected");
+    size -= t;
+    next += t;
+
+    /* registers for device and ep0 */
+    t = scnprintf(next, size,
+        "USB_CTRL %08x, USB_STAT %08x, USB_ENAB %08x "
+        "USB_FRAME %08x, USB_INTR %08x, USB_MASK %08x\n",
+        USB_CTRL,USB_STAT,USB_ENAB,USB_FRAME,USB_INTR,USB_MASK);
+    size -= t;
+    next += t;
+
+    if (!is_usb_connected() || !dev->driver)
+        goto done;
+
+    t = scnprintf(next, size, "ep0 IN %lu/%lu, OUT %lu/%lu\nirqs %lu\n\n",
+        dev->stats.write.bytes, dev->stats.write.ops,
+        dev->stats.read.bytes, dev->stats.read.ops,
+        dev->stats.irqs);
+    size -= t;
+    next += t;
+
+    /* dump endpoint queues */
+    for (i = 0; i < IMX_USB_NB_EP; i++) {
+        struct imx_ep  *ep = &dev->ep [i];
+        struct imx_request *req;
+
+        if (i != 0) {
+            const struct usb_endpoint_descriptor   *d;
+
+            d = ep->desc;
+            if (!d)
+                continue;
+        } else /* ep0 should only have one transfer queued */
+            t = scnprintf(next, size, "ep0 irqs %lu\n",
+                ep->irqs);
+        if (t <= 0 || t > size)
+            goto done;
+        size -= t;
+        next += t;
+
+        if (list_empty(&ep->queue)) {
+            t = scnprintf(next, size, "\t(nothing queued)\n");
+            if (t <= 0 || t > size)
+                goto done;
+            size -= t;
+            next += t;
+            continue;
+        }
+        list_for_each_entry(req, &ep->queue, queue) {
+            t = scnprintf(next, size,
+                "\treq %p len %d/%d buf %p\n",
+                &req->req, req->req.actual,
+                req->req.length, req->req.buf);
+            if (t <= 0 || t > size)
+                goto done;
+            size -= t;
+            next += t;
+        }
+    }
+
+    t = scnprintf(next, size,
+        "USB_EP1_FCTRL %08x, USB_EP1_STAT %08x, USB_EP1_FSTAT %08x "
+        "USB_EP1_INTR %08x, USB_EP1_MASK %08x, USB_EP_FALRM %08x\n",
+        USB_EP_FCTRL(1),USB_EP_STAT(1),USB_EP_FSTAT(1),USB_EP_INTR(1),
+        USB_EP_MASK(1),USB_EP_FALRM(1));
+    size -= t;
+    next += t;
+
+    t = scnprintf(next, size,
+        "USB_EP2_FCTRL %08x, USB_EP2_STAT %08x, USB_EP2_FSTAT %08x "
+        "USB_EP2_INTR %08x, USB_EP2_MASK %08x, USB_EP2_FALRM %08x\n",
+        USB_EP_FCTRL(2),USB_EP_STAT(2),USB_EP_FSTAT(2),USB_EP_INTR(2),
+        USB_EP_MASK(2),USB_EP_FALRM(2));
+    size -= t;
+    next += t;
+
+    t = scnprintf(next, size,"position flags <%s>; loop flags <%s>\n",p_flags,l_flags);
+    size -= t;
+    next += t;
+
+done:
+    local_irq_restore(flags);
+    *eof = 1;
+    return count - size;
+}
+
+#define create_proc_files() \
+    create_proc_read_entry(proc_node_name, 0, NULL, udc_proc_read, dev)
+#define remove_proc_files() \
+    remove_proc_entry(proc_node_name, NULL)
+
+#else  /* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+#endif /* CONFIG_USB_GADGET_DEBUG_FILES */
+
+irqreturn_t(*intr_handler(int i))(int, void *, struct pt_regs *) 
+{
+    switch (i) {
+    case 0:
+        return imx_udc_ctrl_irq;
+    case 1:
+    case 2:
+        return imx_udc_bulk_irq;
+    case 3:
+    case 4:
+    case 5:
+        return imx_udc_int_irq;
+    case 6:
+        return imx_udc_irq;
+    }
+    return imx_udc_irq;
+}
+
+/*
+ *  probe - binds to the platform device
+ */
+static int __init imx_udc_probe(struct device *_dev)
+{
+    struct imx_udc *dev = &memory;
+    int retval = 0;
+    int i;
+    
+    /* TODO: probe for IMX cpu */
+    
+    if (!imx_get_usb_clk()) {
+        WARN("USB clock should be 48MHz, but is not\n");
+        return -EIO;
+    } else
+        D2("USB clock %uHz detected\n",imx_get_usb_clk());
+    
+    /* 
+    * USB general purpose IRQ:  ep0, state changes, dma, etc
+    * irq setup after old hardware state is cleaned up
+    */
+    for (i = 0; i < IMX_USB_NB_EP + 1; i++) 
+    {
+        retval = request_irq(USBD_INT0 + i, intr_handler(i), SA_INTERRUPT, driver_name, dev);
+        if (retval != 0) {
+            printk(KERN_ERR "%s: can't get irq %i, err %d\n",
+            driver_name, USBD_INT0 + i, retval);
+            break;
+        }
+    }
+    
+    if (retval) {
+        for (--i; i >= 0; i--)
+            free_irq(USBD_INT0 + i, dev);
+        return -EBUSY;
+    }
+    
+    dev->dev = _dev;
+    
+    device_initialize(&dev->gadget.dev);
+    dev->gadget.dev.parent = _dev;
+    dev->gadget.dev.dma_mask = _dev->dma_mask;
+    
+    the_controller = dev;
+    dev_set_drvdata(_dev, dev);
+    
+    udc_disable(dev);
+    udc_hardinit(dev);
+    udc_reinit(dev);
+    
+    create_proc_files();
+    
+    return 0;
+}
+
+static int __exit imx_udc_remove(struct device *_dev)
+{
+    struct imx_udc *dev = dev_get_drvdata(_dev);
+    
+    udc_disable(dev);
+    remove_proc_files();
+    usb_gadget_unregister_driver(dev->driver);
+    
+    free_irq(USBD_INT6, dev);
+    free_irq(USBD_INT5, dev);
+    free_irq(USBD_INT4, dev);
+    free_irq(USBD_INT3, dev);
+    free_irq(USBD_INT2, dev);
+    free_irq(USBD_INT1, dev);
+    free_irq(USBD_INT0, dev);
+    dev_set_drvdata(_dev, NULL);
+    the_controller = NULL;
+    return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+#define    imx_udc_suspend NULL
+#define    imx_udc_resume  NULL
+#else
+#define    imx_udc_suspend NULL
+#define    imx_udc_resume  NULL
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+static struct device_driver udc_driver = {
+    .name      = "imx-usb",
+    .bus       = &platform_bus_type,
+    .probe     = imx_udc_probe,
+    .remove        = __exit_p(imx_udc_remove),
+    .suspend   = imx_udc_suspend,
+    .resume        = imx_udc_resume,
+};
+
+static int __init udc_init(void)
+{
+    INFO("%s version: %s\n", driver_name, DRIVER_VERSION);
+    return driver_register(&udc_driver);
+}
+module_init(udc_init);
+
+static void __exit udc_exit(void)
+{
+    driver_unregister(&udc_driver);
+}
+module_exit(udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Mike Lee, Torsten Koschorrek");
+MODULE_LICENSE("GPL");
+
diff -urN linux-2.6.12/drivers/usb/gadget/imx_udc.h linux-2.6.12.work/drivers/usb/gadget/imx_udc.h
--- linux-2.6.12/drivers/usb/gadget/imx_udc.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/imx_udc.h	2005-06-20 15:18:29.000000000 +0800
@@ -0,0 +1,263 @@
+/*
+ *	driver/usb/gadget/imx_udc.h
+ *
+ *	Copyright (C) 2005 Mike Lee(eemike@gmail.com)
+ *	
+ *	This udc driver is now under testing and code is based on pxa2xx_udc.h
+ *	Please use it with your own risk!
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_USB_GADGET_IMX_H
+#define __LINUX_USB_GADGET_IMX_H
+
+#include <linux/types.h>
+
+/*-------------------------------------------------------------------------*/
+
+struct imx_udc;
+
+#define EP_NO(ep)	((ep->bEndpointAddress) & ~USB_DIR_IN)
+#define EP_DIR(ep)	((ep->bEndpointAddress) & USB_DIR_IN ? 1 : 0) // IN:1 , OUT:0
+struct imx_ep {
+	struct usb_ep				ep;
+	struct imx_udc				*dev;
+
+	const struct usb_endpoint_descriptor	*desc;
+	struct list_head			queue;
+	unsigned long				irqs;
+
+	unsigned				wMaxPacketSize;
+	unsigned				fifosize;
+	u8					bEndpointAddress;
+	u8					bmAttributes;
+
+	unsigned				stopped : 1;
+};
+
+struct imx_request {
+	struct usb_request			req;
+	struct list_head			queue;
+};
+
+enum ep0_state { 
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_END_XFER,
+	EP0_STALL,
+};
+
+/*
+ * not yeah finish double buffering
+ * so use full fifo size be the max packet size
+ */
+#define EP0_MAX_SIZE	((unsigned)8)
+#define BULK_MAX_SIZE	((unsigned)64)
+#define ISO_MAX_SIZE	((unsigned)16)
+#define INT_MAX_SIZE	((unsigned)16)
+
+#define IMX_USB_NB_EP	6
+struct udc_stats {
+	struct ep0stats {
+		unsigned long		ops;
+		unsigned long		bytes;
+	} read, write;
+	unsigned long			irqs;
+};
+
+
+struct imx_udc {
+	struct usb_gadget			gadget;
+	struct usb_gadget_driver		*driver;
+
+	spinlock_t				lock;
+	enum ep0_state				ep0state;
+	struct udc_stats			stats;
+	unsigned				got_irq : 1,
+						set_config : 1;
+	int					dev_config;
+
+
+	struct device				*dev;
+	struct imx_ep			ep[IMX_USB_NB_EP];
+};
+
+/*-------------------------------------------------------------------------*/
+
+static struct imx_udc *the_controller;
+
+static inline int is_usb_connected(void)
+{
+//TODO: check connection
+	return 1;
+}
+
+static inline void make_usb_disappear(void)
+{
+	USB_CTRL = USB_CTRL | USB_FE_ENA;
+}
+
+static inline void let_usb_appear(void)
+{
+	USB_CTRL = USB_CTRL & ~USB_FE_ENA;
+}
+
+#define irq_to_ep(irq)	(irq >= USBD_INT0) || (irq <= USBD_INT6) ? (irq - USBD_INT0) \
+			: (USBD_INT6) /*should not happen*/
+#define ep_to_irq(ep)	EP_NO(ep) + USBD_INT0
+
+/*-------------------------------------------------------------------------*/
+
+#define DEBUG
+
+#ifdef DEBUG
+//#define LV4
+//#define LV3
+//#define LV2
+//#define LV1
+
+#define D(label,fmt,args...) while(0){printk(fmt,## args);}
+#define D1(fmt,args...) do{}while(0)
+#define D2(fmt,args...) do{}while(0)
+#define D3(fmt,args...) do{}while(0)
+#define D4(fmt,args...) do{}while(0)
+
+#ifdef LV1
+#define D1(fmt,args...) printk("udc lv1(%20s) " fmt,__FUNCTION__,## args)
+#endif
+#ifdef LV2
+#define D2(fmt,args...) printk("udc lv2(%20s) " fmt,__FUNCTION__,## args)
+#endif
+#ifdef LV3
+#define D3(fmt,args...) printk("udc lv3(%20s) " fmt,__FUNCTION__,## args)
+#endif
+#ifdef LV4
+#define D4(fmt,args...) printk("udc lv4(%20s) " fmt,__FUNCTION__,## args)
+#endif
+
+#ifdef LV3
+#define D(label,fmt,args...) printk("udc    (%20s) " fmt,label,## args)
+#endif
+static const char *state_name[] = {
+	"EP0_IDLE",
+	"EP0_IN_DATA_PHASE", "EP0_OUT_DATA_PHASE",
+	"EP0_END_XFER", "EP0_STALL"
+};
+
+static void __attribute__ ((__unused__))
+dump_ep_stat(const char *label,struct imx_ep *ep)
+{
+	int nb = EP_NO(ep);
+	D(label,"ep0[%s] ep%d_stat<%08x>=[%s%s%s%s%s]\n",
+		state_name[the_controller->ep0state], nb,
+		USB_EP_STAT(nb),
+		(USB_EP_STAT(nb) & USB_SIP) ? " sip" : "",
+		(USB_EP_STAT(nb) & USB_DIR) ? " in" : "",
+		(USB_EP_STAT(nb) & USB_ZLPS) ? " zlp" : "",
+		(USB_EP_STAT(nb) & USB_FLUSH) ? " fsh" : "",
+		(USB_EP_STAT(nb) & USB_STALL) ? " stall" : "");
+}
+static void __attribute__ ((__unused__))
+dump_ep_intr(const char *label,struct imx_ep *ep)
+{
+	int nb = EP_NO(ep);
+	D(label,"ep%d_intr<%08x>=[%s%s%s%s%s%s%s%s%s]\n",
+		nb,USB_EP_INTR(nb),
+		(USB_EP_INTR(nb) & USB_FIFO_FULL) ? " full" : "",
+		(USB_EP_INTR(nb) & USB_FIFO_EMPTY) ? " fempty" : "",
+		(USB_EP_INTR(nb) & USB_FIFO_ERROR) ? " ferr" : "",
+		(USB_EP_INTR(nb) & USB_FIFO_HIGH) ? " fhigh" : "",
+		(USB_EP_INTR(nb) & USB_FIFO_LOW) ? " flow" : "",
+		(USB_EP_INTR(nb) & USB_MDEVREQ) ? " mreq" : "",
+		(USB_EP_INTR(nb) & USB_EOF) ? " eof" : "",
+		(USB_EP_INTR(nb) & USB_DEVREQ) ? " req" : "",
+		(USB_EP_INTR(nb) & USB_EOT) ? " eot" : ""
+		);
+}
+static void __attribute__ ((__unused__))
+dump_intr(const char *label)
+{
+	D(label,"usb_intr<%08x>=[%s%s%s%s%s%s%s%s%s]\n",
+		USB_INTR,
+		(USB_INTR & USB_WAKEUP) ? " wak" : "",
+		(USB_INTR & USB_MSOF) ? " msof" : "",
+		(USB_INTR & USB_SOF) ? " sof" : "",
+		(USB_INTR & USB_RES) ? " res" : "",
+		(USB_INTR & USB_SUSP) ? " sus" : "",
+		(USB_INTR & USB_RESET_STOP) ? " res_stop" : "",
+		(USB_INTR & USB_RESET_START) ? " res_start" : "",
+		(USB_INTR & USB_FRAME_MATCH) ? " f_match" : "",
+		(USB_INTR & USB_CFG_CHG) ? " cfg" : ""
+		);
+}
+
+static void __attribute__ ((__unused__))
+dump_ep_fstat(const char *label,struct imx_ep *ep)
+{
+	int nb = EP_NO(ep);
+	D(label,"%s %08X =framebit[%04x],[%s%s%s%s%s%s%s]\n",
+		state_name[the_controller->ep0state], USB_EP_FSTAT(nb),
+		(USB_EP_FSTAT(nb) & USB_FRAME_STAT) >> 24,
+		(USB_EP_FSTAT(nb) & USB_ERR) ? " err" : "",
+		(USB_EP_FSTAT(nb) & USB_UF) ? " uf" : "",
+		(USB_EP_FSTAT(nb) & USB_OF) ? " of" : "",
+		(USB_EP_FSTAT(nb) & USB_FR) ? " fr" : "",
+		(USB_EP_FSTAT(nb) & USB_FULL) ? " full" : "",
+		(USB_EP_FSTAT(nb) & USB_ALRM) ? " alrm" : "",
+		(USB_EP_FSTAT(nb) & USB_EMPTY) ? " empty" : "");
+}
+static void __attribute__ ((__unused__))
+dump_state(const char *label)
+{
+}
+
+static void __attribute__ ((__unused__))
+dump_req(struct usb_request *req){
+#ifdef LV4
+	if (!req || !req->buf) {
+		D(__FUNCTION__, "req or req buf is free\n");
+		return;
+	}
+
+	int i=0;
+	printk("dump req <");
+	for (;i<req->length;i++){
+		printk("%02x-",*((u8*)req->buf+i));
+	}
+	printk(">\n");
+#endif
+}
+
+
+#else
+
+#define D(label,fmt,args...) do{}while(0)
+#define D1(fmt,args...) do{}while(0)
+#define D2(fmt,args...) do{}while(0)
+#define D3(fmt,args...) do{}while(0)
+#define D4(fmt,args...) do{}while(0)
+
+#define dump_ep_stat(x,y)  do{}while(0)
+#define dump_ep_fstat(x,y) do{}while(0)
+#define dump_ep_intr(x,y)  do{}while(0)
+#define dump_intr(x)       do{}while(0)
+#define dump_ep_fstat(x,y) do{}while(0)
+#define dump_req(req)      while(0){req=req;}
+
+#endif
+
+#define WARN(stuff...) printk(KERN_WARNING "usb: " stuff)
+#define INFO(stuff...) printk(KERN_INFO "usb: " stuff)
+
+
+#endif /* __LINUX_USB_GADGET_IMX_H */

diff -urN linux-2.6.12/drivers/usb/gadget/Kconfig linux-2.6.12.work/drivers/usb/gadget/Kconfig
--- linux-2.6.12/drivers/usb/gadget/Kconfig	2004-12-25 05:34:30.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/Kconfig	2005-06-20 15:12:26.000000000 +0800
@@ -116,6 +116,26 @@
 	default y if USB_ETH
 	default y if USB_G_SERIAL
 
+config USB_GADGET_IMX
+	boolean "i.MX: MX1, MXL"
+	depends on ARCH_IMX
+	help
+	   Freescale's i.MX series include an integrated full speed 
+	   USB 1.1 device controller.  The controllers in the i.MX series
+	   are register-compatible.
+
+	   It has Six fixed-function endpoints, as well as endpoint
+	   zero (for control transfers).
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "imx_udc" and force all
+	   gadget drivers to also be dynamically linked.
+
+config USB_IMX
+	tristate
+	depends on USB_GADGET_IMX
+	default USB_GADGET
+
 config USB_GADGET_GOKU
 	boolean "Toshiba TC86C001 'Goku-S'"
 	depends on PCI

diff -urN linux-2.6.12/drivers/usb/gadget/Makefile linux-2.6.12.work/drivers/usb/gadget/Makefile
--- linux-2.6.12/drivers/usb/gadget/Makefile	2004-12-25 05:33:59.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/Makefile	2005-06-20 15:12:26.000000000 +0800
@@ -4,6 +4,7 @@
 obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
 obj-$(CONFIG_USB_PXA2XX)	+= pxa2xx_udc.o
+obj-$(CONFIG_USB_IMX)		+= imx_udc.o
 obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
 obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
 obj-$(CONFIG_USB_LH7A40X)	+= lh7a40x_udc.o

diff -urN linux-2.6.12/drivers/usb/gadget/zero.c linux-2.6.12.work/drivers/usb/gadget/zero.c
--- linux-2.6.12/drivers/usb/gadget/zero.c	2004-12-25 05:34:32.000000000 +0800
+++ linux-2.6.12.work/drivers/usb/gadget/zero.c	2005-06-20 15:12:26.000000000 +0800
@@ -59,8 +59,8 @@
  * driver does).
  */
 
-#define DEBUG 1
-// #define VERBOSE
+#define DEBUG
+#define VERBOSE
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -218,8 +218,13 @@
  * This device advertises two configurations; these numbers work
  * on a pxa250 as well as more flexible hardware.
  */
+#ifndef CONFIG_ARCH_IMX
 #define	CONFIG_SOURCE_SINK	3
 #define	CONFIG_LOOPBACK		2
+#else
+#define	CONFIG_SOURCE_SINK	1
+#define	CONFIG_LOOPBACK		2
+#endif
 
 static struct usb_device_descriptor
 device_desc = {
@@ -1197,6 +1202,8 @@
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0212);
 	} else if (gadget_is_at91(gadget)) {
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0213);
+	} else if (gadget_is_imx (gadget)) {
+		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0214);
 	} else {
 		/* gadget zero is so simple (for now, no altsettings) that
 		 * it SHOULD NOT have problems with bulk-capable hardware.

diff -urN linux-2.6.12/include/asm-arm/arch-imx/hardware.h linux-2.6.12.work/include/asm-arm/arch-imx/hardware.h
--- linux-2.6.12/include/asm-arm/arch-imx/hardware.h	2004-12-25 05:33:59.000000000 +0800
+++ linux-2.6.12.work/include/asm-arm/arch-imx/hardware.h	2005-06-20 15:12:26.000000000 +0800
@@ -24,6 +24,8 @@
 #include "imx-regs.h"
 
 #ifndef __ASSEMBLY__
+# define __REG8(x)	(*((volatile u8 *)IO_ADDRESS(x)))
+
 # define __REG(x)	(*((volatile u32 *)IO_ADDRESS(x)))
 
 # define __REG2(x,y)        (*(volatile u32 *)((u32)&__REG(x) + (y)))
@@ -81,6 +83,7 @@
 extern unsigned int imx_get_perclk3(void); /* SSI                      */
 extern unsigned int imx_get_hclk(void);    /* SDRAM, CSI, Memory Stick,*/
                                            /* I2C, DMA                 */
+extern unsigned int imx_get_usb_clk(void); /* USB clock*/
 #endif
 
 #define MAXIRQNUM                       62

diff -urN linux-2.6.12/include/asm-arm/arch-imx/imx-regs.h linux-2.6.12.work/include/asm-arm/arch-imx/imx-regs.h
--- linux-2.6.12/include/asm-arm/arch-imx/imx-regs.h	2004-12-25 05:34:26.000000000 +0200
+++ linux-2.6.12.work/include/asm-arm/arch-imx/imx-regs.h	2005-06-20 15:12:26.000000000 +0200
@@ -166,7 +166,7 @@
 #define PB19_AF_SSI_TXCLK    ( GPIO_PORTB | GPIO_AF | 19 )
 #define PB20_PF_USBD_AFE     ( GPIO_PORTB | GPIO_PF | 20 )
 #define PB21_PF_USBD_OE      ( GPIO_PORTB | GPIO_PF | 21 )
-#define PB22_PFUSBD_RCV      ( GPIO_PORTB | GPIO_PF | 22 )
+#define PB22_PF_USBD_RCV     ( GPIO_PORTB | GPIO_PF | 22 )
 #define PB23_PF_USBD_SUSPND  ( GPIO_PORTB | GPIO_PF | 23 )
 #define PB24_PF_USBD_VP      ( GPIO_PORTB | GPIO_PF | 24 )
 #define PB25_PF_USBD_VM      ( GPIO_PORTB | GPIO_PF | 25 )
@@ -569,4 +569,146 @@
 #define  UTS_RXFULL 	 (1<<3)	 /* RxFIFO full */
 #define  UTS_SOFTRST	 (1<<0)	 /* Software reset */
 
+/*
+ * CSI register
+ */
+#define  CSICR1        __REG(0x00 + IMX_CSI_BASE)
+#define  CSICR2        __REG(0x04 + IMX_CSI_BASE)
+#define  CSISR         __REG(0x08 + IMX_CSI_BASE)
+#define  CSISTATR      __REG(0x0C + IMX_CSI_BASE)
+#define  CSIRXR        __REG(0x10 + IMX_CSI_BASE)
+
+/* CSI bit fields */
+#define CSICR1_RXOR_INTEN      (1<<24)
+#define CSICR1_RXFF_INTEN      (1<<18)
+#define CSICR1_RXFF_LEVEL(x)   ((x & 0x3)<<19)
+#define CSICR1_SOF_POL         (1<<17)
+#define CSICR1_SOF_INTEN       (1<<16)
+#define CSICR1_MCLKDIV(x)      ((x & 0xf)<<12)
+#define CSICR1_MCLKEN          (1<<9)
+#define CSICR1_FCC             (1<<8)
+#define CSICR1_BIG_ENDIAN      (1<<7)
+#define CSICR1_CLR_STATFIFO    (1<<6)
+#define CSICR1_CLR_RXFIFO      (1<<5)
+#define CSICR1_GCLK_MODE       (1<<4)
+#define CSICR1_INV_DATA        (1<<3)
+#define CSICR1_REDGE           (1<<1)
+#define CSICR1_ENABLE          (1)
+
+/*
+ * USB register
+ */
+#define  USB_FRAME         __REG(0x00 + IMX_USBD_BASE)             /* USB frame */
+#define  USB_SPEC          __REG(0x04 + IMX_USBD_BASE)             /* USB Spec */
+#define  USB_STAT          __REG(0x08 + IMX_USBD_BASE)             /* USB Status */
+#define  USB_CTRL          __REG(0x0C + IMX_USBD_BASE)             /* USB Control */
+#define  USB_DADR          __REG(0x10 + IMX_USBD_BASE)             /* USB Descriptor RAM address */
+#define  USB_DDAT          __REG(0x14 + IMX_USBD_BASE)             /* USB Descriptor RAM/Endpoint buffer data */
+#define  USB_INTR          __REG(0x18 + IMX_USBD_BASE)             /* USB interrupt */
+#define  USB_MASK          __REG(0x1C + IMX_USBD_BASE)             /* USB Mask */
+#define  USB_ENAB          __REG(0x24 + IMX_USBD_BASE)             /* USB Enable */
+#define  USB_EP_STAT(x)    __REG(0x30 + IMX_USBD_BASE + (x*0x30))  /* USB status/control */
+#define  USB_EP_INTR(x)    __REG(0x34 + IMX_USBD_BASE + (x*0x30))  /* USB interrupt */
+#define  USB_EP_MASK(x)    __REG(0x38 + IMX_USBD_BASE + (x*0x30))  /* USB mask */
+#define  USB_EP_FDAT(x)    __REG(0x3C + IMX_USBD_BASE + (x*0x30))  /* USB FIFO data */
+#define  USB_EP_FDAT0(x)   __REG8(0x3C + IMX_USBD_BASE + (x*0x30)) /* USB FIFO data */
+#define  USB_EP_FDAT1(x)   __REG8(0x3D + IMX_USBD_BASE + (x*0x30)) /* USB FIFO data */
+#define  USB_EP_FDAT2(x)   __REG8(0x3E + IMX_USBD_BASE + (x*0x30)) /* USB FIFO data */
+#define  USB_EP_FDAT3(x)   __REG8(0x3F + IMX_USBD_BASE + (x*0x30)) /* USB FIFO data */
+#define  USB_EP_FSTAT(x)   __REG(0x40 + IMX_USBD_BASE + (x*0x30))  /* USB FIFO status */
+#define  USB_EP_FCTRL(x)   __REG(0x44 + IMX_USBD_BASE + (x*0x30))  /* USB FIFO control */
+#define  USB_EP_LRFP(x)    __REG(0x48 + IMX_USBD_BASE + (x*0x30))  /* USB last read frame pointer */
+#define  USB_EP_LWFP(x)    __REG(0x4C + IMX_USBD_BASE + (x*0x30))  /* USB last write frame pointer */
+#define  USB_EP_FALRM(x)   __REG(0x50 + IMX_USBD_BASE + (x*0x30))  /* USB FIFO alarm */
+#define  USB_EP_FRDP(x)    __REG(0x54 + IMX_USBD_BASE + (x*0x30))  /* USB FIFO read pointer */
+#define  USB_EP_FWRP(x)    __REG(0x58 + IMX_USBD_BASE + (x*0x30))  /* USB FIFO write pointer */
+
+/* USB Control Register Bit Fields.*/
+#define USB_CMDOVER    (1<<6)			/* UDC status */
+#define USB_CMDERROR   (1<<5)			/* UDC status */
+#define USB_FE_ENA     (1<<3)			/* Enable Font End logic */
+#define USB_UDC_RST    (1<<2)			/* UDC reset */
+#define USB_AFE_ENA    (1<<1)			/* Analog Font end enable */
+#define USB_RESUME     (1<<0)			/* UDC resume */
+
+/* USB Descriptor Ram Bit Fields */
+#define USB_CFG            (1<<31)			/* Configuration */
+#define USB_BSY            (1<<30)			/* Busy status */
+#define USB_DADR_DESC      (0x1FF)			/* Descriptor Ram Address */
+#define USB_DDAT_DESC      (0xFF)			/* Descriptor Endpoint Buffer */
+
+/* USB Endpoint Bit fields */
+/* USB Endpoint status bit fields */
+#define USB_FIFO_BCOUNT    (0x7F<<16)		/* Endpoint FIFO byte count */
+#define USB_SIP            (1<<8)			/* Endpoint setup in progress */
+#define USB_DIR            (1<<7)			/* Endpoint transfer direction */
+#define USB_MAX            (3<<5)			/* Endpoint Max packet size */
+#define USB_TYP            (3<<3)			/* Endpoint type */
+#define USB_ZLPS           (1<<2)			/* Send zero length packet */
+#define USB_FLUSH          (1<<1)			/* Endpoint FIFO Flush */
+#define USB_STALL          (1<<0)			/* Force stall */
+/* USB Endpoint FIFO status bit fields */
+#define USB_FRAME_STAT     (0xF<<24)		/* Frame status bit [0-3] */
+#define USB_ERR            (1<<22)			/* FIFO error */
+#define USB_UF             (1<<21)			/* FIFO underflow */
+#define USB_OF             (1<<20)			/* FIFO overflow */
+#define USB_FR             (1<<19)			/* FIFO frame ready */
+#define USB_FULL           (1<<18)			/* FIFO full */
+#define USB_ALRM           (1<<17)			/* FIFO alarm */
+#define USB_EMPTY          (1<<16)			/* FIFO empty */
+/* USB Endpoint FIFO control bit fields */
+#define USB_WFR            (1<<29)			/* Write frame end */
+/* USB Endpoint FIFO interrupt bit fields */
+#define USB_FIFO_FULL      (1<<8)			/* fifo full */
+#define USB_FIFO_EMPTY     (1<<7)			/* fifo empty */
+#define USB_FIFO_ERROR     (1<<6)			/* fifo error */
+#define USB_FIFO_HIGH      (1<<5)			/* fifo high */
+#define USB_FIFO_LOW       (1<<4)			/* fifo low */
+#define USB_MDEVREQ        (1<<3)			/* multi Device request */
+#define USB_EOT            (1<<2)			/* fifo end of transfer */
+#define USB_DEVREQ         (1<<1)			/* Device request */
+#define USB_EOF            (1<<0)			/* fifo end of frame */
+
+/* USB Interrupt Bit fields */
+#define USB_WAKEUP         (1<<31)			/* Wake up Interrupt */
+#define USB_MSOF           (1<<7)			/* Missed Start of Frame */
+#define USB_SOF            (1<<6)			/* Start of Frame */
+#define USB_RESET_STOP     (1<<5)			/* Reset Signaling stop */
+#define USB_RESET_START    (1<<4)			/* Reset Signaling start */
+#define USB_RES            (1<<3)			/* Suspend to resume */
+#define USB_SUSP           (1<<2)			/* Active to suspend */
+#define USB_FRAME_MATCH    (1<<1)			/* Frame matched */
+#define USB_CFG_CHG        (1<<0)			/* Configuration change occurred */
+
+/* USB Enable Register Bit Fields.*/
+#define USB_RST            (1<<31)			/* Reset USB modules */
+#define USB_ENA            (1<<30)			/* Enable USB modules*/
+#define USB_SUSPEND        (1<<29)			/* Suspend USB modules */
+#define USB_ENDIAN         (1<<28)			/* Endian of USB modules */
+#define USB_POWER          (1<<0)			/* Power mode of USB modules */
+
+/* 
+ * SSI register
+ */
+#define     SSI_STX            	__REG(IMX_SSI_BASE)
+#define     SSI_SRX            	__REG(IMX_SSI_BASE + 0x4)
+#define     SSI_SCSR           	__REG(IMX_SSI_BASE + 0x8)	
+#define     SSI_STCR           	__REG(IMX_SSI_BASE + 0xC) 
+#define     SSI_SRCR           	__REG(IMX_SSI_BASE + 0x10) 
+#define     SSI_STCCR          	__REG(IMX_SSI_BASE + 0x14) 
+#define     SSI_SRCCR          	__REG(IMX_SSI_BASE + 0x18) 
+#define     SSI_STSR           	__REG(IMX_SSI_BASE + 0x1C) 
+#define     SSI_SFCSR          	__REG(IMX_SSI_BASE + 0x20) 
+#define     SSI_STR            	__REG(IMX_SSI_BASE + 0x24) 
+#define     SSI_SOR            	__REG(IMX_SSI_BASE + 0x28) 
+
+#define SPI1_RXDATA        __REG(IMX_SPI1_BASE + 0x0) 
+#define SPI1_TXDATA        __REG(IMX_SPI1_BASE + 0x4) 
+#define SPI1_CONTROL       __REG(IMX_SPI1_BASE + 0x8) 
+#define SPI1_INT           __REG(IMX_SPI1_BASE + 0xC) 
+#define SPI1_TEST          __REG(IMX_SPI1_BASE + 0x10) 
+#define SPI1_PERIOD        __REG(IMX_SPI1_BASE + 0x14) 
+#define SPI1_DMA           __REG(IMX_SPI1_BASE + 0x18) 
+#define SPI1_RESET         __REG(IMX_SPI1_BASE + 0x1C) 
+
 #endif				// _IMX_REGS_H
 