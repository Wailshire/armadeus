Subject: arm: scatter-gather DMA emulation for i.MX/MX1
From: Pavel Pisa <pisa@cmp.felk.cvut.cz>

This patch contains bunch of changes to add scatter-gather emulation
capability into MX1 DMA support. The result should provide infrastructure
for next combination of DMA transfers
  Statter-Gather/linear/2D/FIFO to linear/2D/FIFO
  linear/2D/FIFO to Statter-Gather/2D/FIFO/SG
The patch corrects channel priority allocation to be compatible
with MX1 hardware implementation.
Previous code has not been adapted from PXA  original.
Code is little more close to generic ARM DMA version
and integration/hiding under generic DMA would be possible
if it is desirable.

Signed-off-by: Pavel Pisa <pisa@cmp.felk.cvut.cz>

 arch/arm/mach-imx/dma.c            |  511 ++++++++++++++++++++++++++++++++-----
 include/asm-arm/arch-imx/dma.h     |   17 -
 include/asm-arm/arch-imx/imx-dma.h |   90 ++++++
 3 files changed, 541 insertions(+), 77 deletions(-)

Index: linux-2.6.16/include/asm-arm/arch-imx/dma.h
===================================================================
--- linux-2.6.16.orig/include/asm-arm/arch-imx/dma.h
+++ linux-2.6.16/include/asm-arm/arch-imx/dma.h
@@ -17,27 +17,16 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+
 #ifndef __ASM_ARCH_DMA_H
 #define __ASM_ARCH_DMA_H
 
-/*
- * DMA registration
- */
-
 typedef enum {
 	DMA_PRIO_HIGH = 0,
-	DMA_PRIO_MEDIUM = 3,
-	DMA_PRIO_LOW = 6
+	DMA_PRIO_MEDIUM = 1,
+	DMA_PRIO_LOW = 2
 } imx_dma_prio;
 
-int imx_request_dma(char *name, imx_dma_prio prio,
-		    void (*irq_handler) (int, void *, struct pt_regs *),
-		    void (*err_handler) (int, void *, struct pt_regs *),
-		    void *data);
-
-void imx_free_dma(int dma_ch);
-
-
 #define DMA_REQ_UART3_T        2
 #define DMA_REQ_UART3_R        3
 #define DMA_REQ_SSI2_T         4
Index: linux-2.6.16/arch/arm/mach-imx/dma.c
===================================================================
--- linux-2.6.16.orig/arch/arm/mach-imx/dma.c
+++ linux-2.6.16/arch/arm/mach-imx/dma.c
@@ -7,11 +7,18 @@
  *  it under the terms of the GNU General Public License version 2 as
  *  published by the Free Software Foundation.
  *
- *  03/03/2004 Sascha Hauer <sascha@saschahauer.de>
+ *  2004-03-03 Sascha Hauer <sascha@saschahauer.de>
  *             initial version heavily inspired by
  *             linux/arch/arm/mach-pxa/dma.c
+ *
+ *  2005-04-17 Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ *             Changed to support scatter gather DMA
+ *             by taking Russell's code from RiscPC
+ *
  */
 
+#undef DEBUG
+
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -22,69 +29,368 @@
 #include <asm/irq.h>
 #include <asm/hardware.h>
 #include <asm/dma.h>
+#include <asm/arch/imx-dma.h>
+
+struct imx_dma_channel imx_dma_channels[IMX_DMA_CHANNELS];
+
+/*
+ * imx_dma_sg_next - prepare next chunk for scatter-gather DMA emulation
+ * @dma_ch: i.MX DMA channel number
+ * @lastcount: number of bytes transferred during last transfer
+ *
+ * Functions prepares DMA controller for next sg data chunk transfer.
+ * The @lastcount argument informs function about number of bytes transferred
+ * during last block. Zero value can be used for @lastcount to setup DMA
+ * for the first chunk.
+ */
+static inline int imx_dma_sg_next(imx_dmach_t dma_ch, unsigned int lastcount)
+{
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
+	unsigned int nextcount;
+	unsigned int nextaddr;
+
+	if (!imxdma->name) {
+		printk(KERN_CRIT "%s: called for  not allocated channel %d\n",
+		       __FUNCTION__, dma_ch);
+		return 0;
+	}
+
+	imxdma->resbytes -= lastcount;
+
+	if (!imxdma->sg) {
+		pr_debug("imxdma%d: no sg data\n", dma_ch);
+		return 0;
+	}
+
+	imxdma->sgbc += lastcount;
+	if ((imxdma->sgbc >= imxdma->sg->length) || !imxdma->resbytes) {
+		if ((imxdma->sgcount <= 1) || !imxdma->resbytes) {
+			pr_debug("imxdma%d: sg transfer limit reached\n",
+				 dma_ch);
+			imxdma->sgcount=0;
+			imxdma->sg = NULL;
+			return 0;
+		} else {
+			imxdma->sgcount--;
+			imxdma->sg++;
+			imxdma->sgbc = 0;
+		}
+	}
+	nextcount = imxdma->sg->length - imxdma->sgbc;
+	nextaddr = imxdma->sg->dma_address + imxdma->sgbc;
+
+	if(imxdma->resbytes < nextcount)
+		nextcount = imxdma->resbytes;
 
-static struct dma_channel {
-	char *name;
-	void (*irq_handler) (int, void *, struct pt_regs *);
-	void (*err_handler) (int, void *, struct pt_regs *);
-	void *data;
-} dma_channels[11];
+	if ((imxdma->dma_mode & DMA_MODE_MASK) == DMA_MODE_READ)
+		DAR(dma_ch) = nextaddr;
+	else
+		SAR(dma_ch) = nextaddr;
+
+	CNTR(dma_ch) = nextcount;
+	pr_debug("imxdma%d: next sg chunk dst 0x%08x, src 0x%08x, size 0x%08x\n",
+		 dma_ch, DAR(dma_ch), SAR(dma_ch), CNTR(dma_ch));
 
-/* set err_handler to NULL to have the standard info-only error handler */
+	return nextcount;
+}
+
+/*
+ * imx_dma_setup_sg_base - scatter-gather DMA emulation
+ * @dma_ch: i.MX DMA channel number
+ * @sg: pointer to the scatter-gather list/vector
+ * @sgcount: scatter-gather list hungs count
+ *
+ * Functions sets up i.MX DMA state for emulated scatter-gather transfer
+ * and sets up channel registers to be ready for the first chunk
+ */
+static int
+imx_dma_setup_sg_base(imx_dmach_t dma_ch,
+		      struct scatterlist *sg, unsigned int sgcount)
+{
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
+
+	imxdma->sg = sg;
+	imxdma->sgcount = sgcount;
+	imxdma->sgbc = 0;
+	return imx_dma_sg_next(dma_ch, 0);
+}
+
+/**
+ * imx_dma_setup_single - setup i.MX DMA channel for linear memory to/from device transfer
+ * @dma_ch: i.MX DMA channel number
+ * @dma_address: the DMA/physical memory address of the linear data block
+ *		to transfer
+ * @dma_length: length of the data block in bytes
+ * @dev_addr: physical device port address
+ * @dmamode: DMA transfer mode, %DMA_MODE_READ from the device to the memory
+ *           or %DMA_MODE_WRITE from memory to the device
+ *
+ * The function setups DMA channel source and destination addresses for transfer
+ * specified by provided parameters. The scatter-gather emulation is disabled,
+ * because linear data block
+ * form the physical address range is transfered.
+ * Return value: if incorrect parameters are provided -%EINVAL.
+ *		Zero indicates success.
+ */
 int
-imx_request_dma(char *name, imx_dma_prio prio,
-		void (*irq_handler) (int, void *, struct pt_regs *),
-		void (*err_handler) (int, void *, struct pt_regs *), void *data)
+imx_dma_setup_single(imx_dmach_t dma_ch, dma_addr_t dma_address,
+		     unsigned int dma_length, unsigned int dev_addr,
+		     dmamode_t dmamode)
 {
-	unsigned long flags;
-	int i, found = 0;
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
 
-	/* basic sanity checks */
-	if (!name || !irq_handler)
+	imxdma->sg = NULL;
+	imxdma->sgcount = 0;
+	imxdma->dma_mode = dmamode;
+	imxdma->resbytes = dma_length;
+
+	if (!dma_address) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_single null address\n",
+		       dma_ch);
 		return -EINVAL;
+	}
 
-	local_irq_save(flags);
+	if (!dma_length) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_single zero length\n",
+		       dma_ch);
+		return -EINVAL;
+	}
 
-	/* try grabbing a DMA channel with the requested priority */
-	for (i = prio; i < prio + (prio == DMA_PRIO_LOW) ? 8 : 4; i++) {
-		if (!dma_channels[i].name) {
-			found = 1;
-			break;
-		}
+	if ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {
+		pr_debug("imxdma%d: mx_dma_setup_single2dev dma_addressg=0x%08x dma_length=%d dev_addr=0x%08x for read\n",
+			dma_ch, (unsigned int)dma_address, dma_length,
+			dev_addr);
+		SAR(dma_ch) = dev_addr;
+		DAR(dma_ch) = (unsigned int)dma_address;
+	} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {
+		pr_debug("imxdma%d: mx_dma_setup_single2dev dma_addressg=0x%08x dma_length=%d dev_addr=0x%08x for write\n",
+			dma_ch, (unsigned int)dma_address, dma_length,
+			dev_addr);
+		SAR(dma_ch) = (unsigned int)dma_address;
+		DAR(dma_ch) = dev_addr;
+	} else {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_single bad dmamode\n",
+		       dma_ch);
+		return -EINVAL;
 	}
 
-	if (!found) {
-		/* requested prio group is full, try hier priorities */
-		for (i = prio - 1; i >= 0; i--) {
-			if (!dma_channels[i].name) {
-				found = 1;
-				break;
-			}
-		}
+	CNTR(dma_ch) = dma_length;
+
+	return 0;
+}
+
+/**
+ * imx_dma_setup_sg - setup i.MX DMA channel SG list to/from device transfer
+ * @dma_ch: i.MX DMA channel number
+ * @sg: pointer to the scatter-gather list/vector
+ * @sgcount: scatter-gather list hungs count
+ * @dma_length: total length of the transfer request in bytes
+ * @dev_addr: physical device port address
+ * @dmamode: DMA transfer mode, %DMA_MODE_READ from the device to the memory
+ *           or %DMA_MODE_WRITE from memory to the device
+ *
+ * The function setups DMA channel state and registers to be ready for transfer
+ * specified by provided parameters. The scatter-gather emulation is set up
+ * according to the parameters.
+ *
+ * The full preparation of the transfer requires setup of more register
+ * by the caller before imx_dma_enable() can be called.
+ *
+ * %BLR(dma_ch) holds transfer burst length in bytes, 0 means 64 bytes
+ *
+ * %RSSR(dma_ch) has to be set to the DMA request line source %DMA_REQ_xxx
+ *
+ * %CCR(dma_ch) has to specify transfer parameters, the next settings is typical
+ * for linear or simple scatter-gather transfers if %DMA_MODE_READ is specified
+ *
+ * %CCR_DMOD_LINEAR | %CCR_DSIZ_32 | %CCR_SMOD_FIFO | %CCR_SSIZ_x
+ *
+ * The typical setup for %DMA_MODE_WRITE is specified by next options combination
+ *
+ * %CCR_SMOD_LINEAR | %CCR_SSIZ_32 | %CCR_DMOD_FIFO | %CCR_DSIZ_x
+ *
+ * Be carefull there and do not mistakenly mix source and target device
+ * port sizes constants, they are really different:
+ * %CCR_SSIZ_8, %CCR_SSIZ_16, %CCR_SSIZ_32,
+ * %CCR_DSIZ_8, %CCR_DSIZ_16, %CCR_DSIZ_32
+ *
+ * Return value: if incorrect parameters are provided -%EINVAL.
+ * Zero indicates success.
+ */
+int
+imx_dma_setup_sg(imx_dmach_t dma_ch,
+		 struct scatterlist *sg, unsigned int sgcount, unsigned int dma_length,
+		 unsigned int dev_addr, dmamode_t dmamode)
+{
+	int res;
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
+
+	imxdma->sg = NULL;
+	imxdma->sgcount = 0;
+	imxdma->dma_mode = dmamode;
+	imxdma->resbytes = dma_length;
+
+	if (!sg || !sgcount) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg epty sg list\n",
+		       dma_ch);
+		return -EINVAL;
 	}
 
-	if (found) {
-		DIMR &= ~(1 << i);
-		dma_channels[i].name = name;
-		dma_channels[i].irq_handler = irq_handler;
-		dma_channels[i].err_handler = err_handler;
-		dma_channels[i].data = data;
+	if (!sg->length) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg zero length\n",
+		       dma_ch);
+		return -EINVAL;
+	}
+
+	if ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {
+		pr_debug("imxdma%d: mx_dma_setup_sg2dev sg=%p sgcount=%d total length=%d dev_addr=0x%08x for read\n",
+			dma_ch, sg, sgcount, dma_length, dev_addr);
+		SAR(dma_ch) = dev_addr;
+	} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {
+		pr_debug("imxdma%d: mx_dma_setup_sg2dev sg=%p sgcount=%d total length=%d dev_addr=0x%08x for write\n",
+			dma_ch, sg, sgcount, dma_length, dev_addr);
+		DAR(dma_ch) = dev_addr;
 	} else {
-		printk(KERN_WARNING "No more available DMA channels for %s\n",
-		       name);
-		i = -ENODEV;
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg bad dmamode\n",
+		       dma_ch);
+		return -EINVAL;
 	}
 
+	res = imx_dma_setup_sg_base(dma_ch, sg, sgcount);
+	if (res <= 0) {
+		printk(KERN_ERR "imxdma%d: no sg chunk ready\n", dma_ch);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * imx_dma_setup_handlers - setup i.MX DMA channel end and error notification handlers
+ * @dma_ch: i.MX DMA channel number
+ * @irq_handler: the pointer to the function called if the transfer
+ *		ends successfully
+ * @err_handler: the pointer to the function called if the premature
+ *		end caused by error occurs
+ * @data: user specified value to be passed to the handlers
+ */
+int
+imx_dma_setup_handlers(imx_dmach_t dma_ch,
+		       void (*irq_handler) (int, void *, struct pt_regs *),
+		       void (*err_handler) (int, void *, struct pt_regs *),
+		       void *data)
+{
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
+	unsigned long flags;
+
+	if (!imxdma->name) {
+		printk(KERN_CRIT "%s: called for  not allocated channel %d\n",
+		       __FUNCTION__, dma_ch);
+		return -ENODEV;
+	}
+
+	local_irq_save(flags);
+	DISR = (1 << dma_ch);
+	imxdma->irq_handler = irq_handler;
+	imxdma->err_handler = err_handler;
+	imxdma->data = data;
 	local_irq_restore(flags);
-	return i;
+	return 0;
 }
 
-void
-imx_free_dma(int dma_ch)
+/**
+ * imx_dma_enable - function to start i.MX DMA channel operation
+ * @dma_ch: i.MX DMA channel number
+ *
+ * The channel has to be allocated by driver through imx_dma_request()
+ * or imx_dma_request_by_prio() function.
+ * The transfer parameters has to be set to the channel registers through
+ * call of the imx_dma_setup_single() or imx_dma_setup_sg() function
+ * and registers %BLR(dma_ch), %RSSR(dma_ch) and %CCR(dma_ch) has to
+ * be set prior this function call by the channel user.
+ */
+void imx_dma_enable(imx_dmach_t dma_ch)
 {
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
 	unsigned long flags;
 
-	if (!dma_channels[dma_ch].name) {
+	pr_debug("imxdma%d: imx_dma_enable\n", dma_ch);
+
+	if (!imxdma->name) {
+		printk(KERN_CRIT "%s: called for  not allocated channel %d\n",
+		       __FUNCTION__, dma_ch);
+		return;
+	}
+
+	local_irq_save(flags);
+	DISR = (1 << dma_ch);
+	DIMR &= ~(1 << dma_ch);
+	CCR(dma_ch) |= CCR_CEN;
+	local_irq_restore(flags);
+}
+
+/**
+ * imx_dma_disable - stop, finish i.MX DMA channel operatin
+ * @dma_ch: i.MX DMA channel number
+ */
+void imx_dma_disable(imx_dmach_t dma_ch)
+{
+	unsigned long flags;
+
+	pr_debug("imxdma%d: imx_dma_disable\n", dma_ch);
+
+	local_irq_save(flags);
+	DIMR |= (1 << dma_ch);
+	CCR(dma_ch) &= ~CCR_CEN;
+	DISR = (1 << dma_ch);
+	local_irq_restore(flags);
+}
+
+/**
+ * imx_dma_request - request/allocate specified channel number
+ * @dma_ch: i.MX DMA channel number
+ * @name: the driver/caller own non-%NULL identification
+ */
+int imx_dma_request(imx_dmach_t dma_ch, const char *name)
+{
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
+	unsigned long flags;
+
+	/* basic sanity checks */
+	if (!name)
+		return -EINVAL;
+
+	if (dma_ch >= IMX_DMA_CHANNELS) {
+		printk(KERN_CRIT "%s: called for  non-existed channel %d\n",
+		       __FUNCTION__, dma_ch);
+		return -EINVAL;
+	}
+
+	local_irq_save(flags);
+	if (imxdma->name) {
+		local_irq_restore(flags);
+		return -ENODEV;
+	}
+
+	imxdma->name = name;
+	imxdma->irq_handler = NULL;
+	imxdma->err_handler = NULL;
+	imxdma->data = NULL;
+	imxdma->sg = NULL;
+	local_irq_restore(flags);
+	return 0;
+}
+
+/**
+ * imx_dma_free - release previously acquired channel
+ * @dma_ch: i.MX DMA channel number
+ */
+void imx_dma_free(imx_dmach_t dma_ch)
+{
+	unsigned long flags;
+	struct imx_dma_channel *imxdma = &imx_dma_channels[dma_ch];
+
+	if (!imxdma->name) {
 		printk(KERN_CRIT
 		       "%s: trying to free channel %d which is already freed\n",
 		       __FUNCTION__, dma_ch);
@@ -92,27 +398,84 @@ imx_free_dma(int dma_ch)
 	}
 
 	local_irq_save(flags);
-	DIMR &= ~(1 << dma_ch);
-	dma_channels[dma_ch].name = NULL;
+	/* Disable interrupts */
+	DIMR |= (1 << dma_ch);
+	CCR(dma_ch) &= ~CCR_CEN;
+	imxdma->name = NULL;
 	local_irq_restore(flags);
 }
 
-static irqreturn_t
-dma_err_handler(int irq, void *dev_id, struct pt_regs *regs)
+/**
+ * imx_dma_request_by_prio - find and request some of free channels best suiting requested priority
+ * @dma_ch: i.MX DMA channel number
+ * @name: the driver/caller own non-%NULL identification
+ * @prio: one of the hardware distinguished priority level:
+ *        %DMA_PRIO_HIGH, %DMA_PRIO_MEDIUM, %DMA_PRIO_LOW
+ *
+ * This function tries to find free channel in the specified priority group
+ * if the priority cannot be achieved it tries to look for free channel
+ * in the higher and then even lower priority groups.
+ *
+ * Return value: If there is no free channel to allocate, -%ENODEV is returned.
+ *               Zero value indicates successful channel allocation.
+ */
+int
+imx_dma_request_by_prio(imx_dmach_t * pdma_ch, const char *name,
+			imx_dma_prio prio)
+{
+	int i;
+	int best;
+
+	switch (prio) {
+	case (DMA_PRIO_HIGH):
+		best = 8;
+		break;
+	case (DMA_PRIO_MEDIUM):
+		best = 4;
+		break;
+	case (DMA_PRIO_LOW):
+	default:
+		best = 0;
+		break;
+	}
+
+	for (i = best; i < IMX_DMA_CHANNELS; i++) {
+		if (!imx_dma_request(i, name)) {
+			*pdma_ch = i;
+			return 0;
+		}
+	}
+
+	for (i = best - 1; i >= 0; i--) {
+		if (!imx_dma_request(i, name)) {
+			*pdma_ch = i;
+			return 0;
+		}
+	}
+
+	printk(KERN_ERR "%s: no free DMA channel found\n", __FUNCTION__);
+
+	return -ENODEV;
+}
+
+static irqreturn_t dma_err_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	int i, disr = DISR;
-	struct dma_channel *channel;
+	struct imx_dma_channel *channel;
 	unsigned int err_mask = DBTOSR | DRTOSR | DSESR | DBOSR;
 
 	DISR = disr;
-	for (i = 0; i < 11; i++) {
-		channel = &dma_channels[i];
+	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
+		channel = &imx_dma_channels[i];
 
-		if ( (err_mask & 1<<i) && channel->name && channel->err_handler) {
+		if ((err_mask & 1 << i) && channel->name
+		    && channel->err_handler) {
 			channel->err_handler(i, channel->data, regs);
 			continue;
 		}
 
+		imx_dma_channels[i].sg = NULL;
+
 		if (DBTOSR & (1 << i)) {
 			printk(KERN_WARNING
 			       "Burst timeout on channel %d (%s)\n",
@@ -141,17 +504,27 @@ dma_err_handler(int irq, void *dev_id, s
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t
-dma_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t dma_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	int i, disr = DISR;
 
+	pr_debug("imxdma: dma_irq_handler called, disr=0x%08x\n",
+		     disr);
+
 	DISR = disr;
-	for (i = 0; i < 11; i++) {
+	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
 		if (disr & (1 << i)) {
-			struct dma_channel *channel = &dma_channels[i];
-			if (channel->name && channel->irq_handler) {
-				channel->irq_handler(i, channel->data, regs);
+			struct imx_dma_channel *channel = &imx_dma_channels[i];
+			if (channel->name) {
+				if (imx_dma_sg_next(i, CNTR(i))) {
+					CCR(i) &= ~CCR_CEN;
+					mb();
+					CCR(i) |= CCR_CEN;
+				} else {
+					if (channel->irq_handler)
+						channel->irq_handler(i,
+							channel->data, regs);
+				}
 			} else {
 				/*
 				 * IRQ for an unregistered DMA channel:
@@ -165,10 +538,10 @@ dma_irq_handler(int irq, void *dev_id, s
 	return IRQ_HANDLED;
 }
 
-static int __init
-imx_dma_init(void)
+static int __init imx_dma_init(void)
 {
 	int ret;
+	int i;
 
 	/* reset DMA module */
 	DCR = DCR_DRST;
@@ -189,15 +562,27 @@ imx_dma_init(void)
 	DCR = DCR_DEN;
 
 	/* clear all interrupts */
-	DISR = 0x3ff;
+	DISR = (1 << IMX_DMA_CHANNELS) - 1;
 
 	/* enable interrupts */
-	DIMR = 0;
+	DIMR = (1 << IMX_DMA_CHANNELS) - 1;
+
+	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
+		imx_dma_channels[i].sg = NULL;
+		imx_dma_channels[i].dma_num = i;
+	}
 
 	return ret;
 }
 
 arch_initcall(imx_dma_init);
 
-EXPORT_SYMBOL(imx_request_dma);
-EXPORT_SYMBOL(imx_free_dma);
+EXPORT_SYMBOL(imx_dma_setup_single);
+EXPORT_SYMBOL(imx_dma_setup_sg);
+EXPORT_SYMBOL(imx_dma_setup_handlers);
+EXPORT_SYMBOL(imx_dma_enable);
+EXPORT_SYMBOL(imx_dma_disable);
+EXPORT_SYMBOL(imx_dma_request);
+EXPORT_SYMBOL(imx_dma_free);
+EXPORT_SYMBOL(imx_dma_request_by_prio);
+EXPORT_SYMBOL(imx_dma_channels);
Index: linux-2.6.16/include/asm-arm/arch-imx/imx-dma.h
===================================================================
--- /dev/null
+++ linux-2.6.16/include/asm-arm/arch-imx/imx-dma.h
@@ -0,0 +1,90 @@
+/*
+ *  linux/include/asm-arm/imxads/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/dma.h>
+
+#ifndef __ASM_ARCH_IMX_DMA_H
+#define __ASM_ARCH_IMX_DMA_H
+
+#define IMX_DMA_CHANNELS  11
+
+/*
+ * struct imx_dma_channel - i.MX specific DMA extension
+ * @name: name specified by DMA client
+ * @irq_handler: client callback for end of transfer
+ * @err_handler: client callback for error condition
+ * @data: clients context data for callbacks
+ * @dma_mode: direction of the transfer %DMA_MODE_READ or %DMA_MODE_WRITE
+ * @sg: pointer to the actual read/written chunk for scatter-gather emulation
+ * @sgbc: counter of processed bytes in the actual read/written chunk
+ * @resbytes: total residual number of bytes to transfer
+ *            (it can be lower or same as sum of SG mapped chunk sizes)
+ * @sgcount: number of chunks to be read/written
+ *
+ * Structure is used for IMX DMA processing. It would be probably good
+ * @struct dma_struct in the future for external interfacing and use
+ * @struct imx_dma_channel only as extension to it.
+ */
+
+struct imx_dma_channel {
+	const char *name;
+	void (*irq_handler) (int, void *, struct pt_regs *);
+	void (*err_handler) (int, void *, struct pt_regs *);
+	void *data;
+	dmamode_t  dma_mode;
+	struct scatterlist *sg;
+	unsigned int sgbc;
+	unsigned int sgcount;
+	unsigned int resbytes;
+	int dma_num;
+};
+
+extern struct imx_dma_channel imx_dma_channels[IMX_DMA_CHANNELS];
+
+
+/* The type to distinguish channel numbers parameter from ordinal int type */
+typedef int imx_dmach_t;
+
+int
+imx_dma_setup_single(imx_dmach_t dma_ch, dma_addr_t dma_address,
+		unsigned int dma_length, unsigned int dev_addr, dmamode_t dmamode);
+
+int
+imx_dma_setup_sg(imx_dmach_t dma_ch,
+		 struct scatterlist *sg, unsigned int sgcount, unsigned int dma_length,
+		 unsigned int dev_addr, dmamode_t dmamode);
+
+int
+imx_dma_setup_handlers(imx_dmach_t dma_ch,
+		void (*irq_handler) (int, void *, struct pt_regs *),
+		void (*err_handler) (int, void *, struct pt_regs *), void *data);
+
+void imx_dma_enable(imx_dmach_t dma_ch);
+
+void imx_dma_disable(imx_dmach_t dma_ch);
+
+int imx_dma_request(imx_dmach_t dma_ch, const char *name);
+
+void imx_dma_free(imx_dmach_t dma_ch);
+
+int imx_dma_request_by_prio(imx_dmach_t *pdma_ch, const char *name, imx_dma_prio prio);
+
+
+#endif	/* _ASM_ARCH_IMX_DMA_H */
